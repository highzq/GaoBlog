{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/assets/yapi-img.png","path":"assets/yapi-img.png","modified":0,"renderable":0},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/avatar.jpg","path":"avatar/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"source/assets/事件冒泡图.png","path":"assets/事件冒泡图.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/archer/.eslintrc.json","hash":"35eeca97fa5a2d0c6d78ef1257c58f03c42d43df","modified":1614005306695},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1614005306695},{"_id":"themes/archer/.gitignore","hash":"55cbfa5bcac7f7bb37b3dcd03aa88a80f41b77ed","modified":1614005306695},{"_id":"themes/archer/.prettierignore","hash":"58caf761f07e5df9cdc21f7f19f0670fde41089b","modified":1614005306695},{"_id":"themes/archer/.prettierrc.js","hash":"875b0b95f6eb24a23e4ea83a75709b97897135e0","modified":1614005306695},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1614005306695},{"_id":"themes/archer/README.md","hash":"97edb54cb7aecff714f132110ed4ba8215da7136","modified":1614005306695},{"_id":"themes/archer/_config.yml","hash":"09268de7134eebd4db090ef96f9f9132dfd9dfa9","modified":1614005306695},{"_id":"themes/archer/gulpfile.js","hash":"46dfe693b00ac4dea4d1b1af56f5ced4ee095c10","modified":1614005306703},{"_id":"themes/archer/package.json","hash":"531fe40833ca63493f62adfa249b6434310a2d0a","modified":1614005306707},{"_id":"themes/archer/webpack.config.js","hash":"d20b6350c50e2981484cb9356a3e21a2124bcd72","modified":1614005306723},{"_id":"themes/archer/webpack.prod.js","hash":"48de76cfa6274895801d3afc89ecbf04ee182a1c","modified":1614005306723},{"_id":"source/_posts/BFC理解原理.md","hash":"aa58e666af2288d6ec013ce0edabd05430d4fa29","modified":1616949334280},{"_id":"source/_posts/Ubuntu系统服务器获取root权限.md","hash":"04237ad832e0752be86075e27725225279e13fdd","modified":1614005306691},{"_id":"source/_posts/forEach兼容写法.md","hash":"1c4553e5c888b5910e49b76e6b4886d3ea8b2be9","modified":1614005306691},{"_id":"source/_posts/react-Context-上下文方法使用.md","hash":"11c59f7331e01ce0a303696741b3fffa9a16971a","modified":1614005306691},{"_id":"source/_posts/使用hexo搭建博客时遇到的问题.md","hash":"cf2bfc3b325f1f2e86fb03a33a0077c546f93b5f","modified":1614005306691},{"_id":"source/_posts/测试1244253.md","hash":"d8d6a01fc6c7918c13c51a8e8c4a3bcd6afd4079","modified":1614006302381},{"_id":"source/_posts/让h5页面强制横屏.md","hash":"13d720ae9ea9176667bbdef2ee7870c26c0a68c2","modified":1614005306691},{"_id":"source/_posts/遇到问题最后解决的文章收藏.md","hash":"37ddcf0a15d3a7bca739c302f8318ed86827a24f","modified":1614005306691},{"_id":"source/_posts/部署Yapi遇到的问题.md","hash":"d6dd02d670a2c716c96b759986dbc792598cd7a3","modified":1614005306691},{"_id":"source/assets/yapi-img.png","hash":"51138f04c054864a2882fe9f5b369e6005b98cef","modified":1614005306695},{"_id":"source/categories/index.md","hash":"c838304e0c43d4ed20d012943da53282d4e47eac","modified":1614005306695},{"_id":"source/tags/index.md","hash":"13d75ba9b54990e92b96961571a6ef5b734885ec","modified":1614005306695},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1614005306695},{"_id":"themes/archer/docs/README-en.md","hash":"f325565c0bb94501fd046268659c7752709895d1","modified":1614005306695},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1614005306695},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"effc2bc9e0cecfd228b19283337ff29649ea5985","modified":1614005306695},{"_id":"themes/archer/languages/default.yml","hash":"d56b6923c70efdef09cd1f0270d7adc9cc338f6b","modified":1614005306703},{"_id":"themes/archer/languages/en.yml","hash":"ad75d3e5f7f5f0463d3077e1b5a26f40938a1faa","modified":1614005306703},{"_id":"themes/archer/layout/404.ejs","hash":"879641b1b5e49c43f2e096cad281f7d74df05127","modified":1614005306703},{"_id":"themes/archer/layout/about.ejs","hash":"06019d835c0a51fed8aa086d1dfcf368f9921b42","modified":1614005306703},{"_id":"themes/archer/layout/index.ejs","hash":"716ba4a30860e36077dfdfffa02c1cd60301d8a3","modified":1614005306703},{"_id":"themes/archer/layout/layout.ejs","hash":"08ebd10c1b2bfc11be8f5115a836a98e6c6ba13c","modified":1614005306703},{"_id":"themes/archer/layout/post.ejs","hash":"904a7325e6435ad32ced095b5799d62382cb1637","modified":1614005306703},{"_id":"themes/archer/layout/site-meta.ejs","hash":"d866aa1a892d4bfe3368f6dbd0f1baa8c5831947","modified":1614005306703},{"_id":"source/_posts/问题整理.md","hash":"4d18acea55cfa3b8db1c692e68edf6c8bdc47afc","modified":1614005306695},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"2f5f9073378f628a9124792b5301c1540bc5a264","modified":1614005306703},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"82203d9a1c6e16ef2d37b8b587f56bf6d16edaf2","modified":1614005306703},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"7bfb8af21f7d30780d1a3af5484760b07b4fbb1d","modified":1614005306703},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"f2e8d4dfd11d879491a4b10f74f8c886cd392240","modified":1614005306703},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"12e28693dc53cab5f6fd389f15ea0f811c9c37e9","modified":1614005306703},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"2aea84cb43f4479131620b3c3dfd7cebe9be36ba","modified":1614005306703},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"743d97452d4ac358e631c43c9c2120aafdfd3e24","modified":1614005306703},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"2d068432031b3bebf9438c775370a2d1b4492d6b","modified":1614005306703},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"418559ab11726f69621c3a58cd21903adff1e48e","modified":1614005306703},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"cd0d34a811dc4666980d57c00d70dd82bd5450eb","modified":1614005306703},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1614005306711},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1614005306711},{"_id":"themes/archer/source/assets/favicon.ico","hash":"d6d9068d1928f9f69ddb2772816fccc01c74cde5","modified":1614005306711},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1614005306711},{"_id":"themes/archer/source/avatar/avatar.jpg","hash":"061fcb1e751dd9f2d73e9abe1a841b107f84e792","modified":1614005306711},{"_id":"themes/archer/source/css/mobile.css","hash":"51d7b5cf26c8f82a3daad4bc55518673fdf281f5","modified":1614005306711},{"_id":"themes/archer/source/css/style.css","hash":"5d5e869db0c62957d59c6865baaecd1428c51804","modified":1614005306711},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1614005306711},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1614005306711},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1614005306723},{"_id":"themes/archer/source/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1614005306723},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1614005306723},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1614005306723},{"_id":"themes/archer/src/js/browser.js","hash":"ce061db99db5b880db0ddb768246352ca885b13c","modified":1614005306723},{"_id":"themes/archer/src/js/fancybox.js","hash":"0daf0e83deca055102268e3bd95cb1962acc2264","modified":1614005306723},{"_id":"themes/archer/src/js/init.js","hash":"346c6ef75ae85e4350c1b0811985172fdaa0d3a5","modified":1614005306723},{"_id":"themes/archer/src/js/initSidebar.js","hash":"b25615ff254913db83e2a20263d445f35083843b","modified":1614005306723},{"_id":"themes/archer/src/js/main.js","hash":"e1a48d5822326792e38d44efee86e01473549eba","modified":1614005306723},{"_id":"themes/archer/src/js/mobile.js","hash":"228a68d851517b5e47d2132f1d499cb812a64171","modified":1614005306723},{"_id":"themes/archer/src/js/scroll.js","hash":"aa2315a80daaa183a7e462c7e879ff9d2f050933","modified":1614005306723},{"_id":"themes/archer/src/js/search.js","hash":"2e59ac745da7c22801d9029cf9904a4fc3c384f1","modified":1614005306723},{"_id":"themes/archer/src/js/share.js","hash":"1314b19a852e291e35d6809f7f58652d3e7c524c","modified":1614005306723},{"_id":"themes/archer/src/js/sidebar.js","hash":"68d5fe0ee5e86df810d304e5efe11e5e1fddc46d","modified":1614005306723},{"_id":"themes/archer/src/js/tag.js","hash":"e0f0a914c02922e42977d78dc4993b3855167cd8","modified":1614005306723},{"_id":"themes/archer/src/js/toc.js","hash":"b3482031e4c8728535d480bfaec76229469e3aba","modified":1614005306723},{"_id":"themes/archer/src/js/util.js","hash":"27de6446892bcf399430dd5776df0b8759ca0eea","modified":1614005306723},{"_id":"themes/archer/src/scss/_common.scss","hash":"dedc313b082e0a16daf87213badd21b13be11af8","modified":1614005306723},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"e7deb20a16868ae9d3e35ba3c5693de71fdf6999","modified":1614005306723},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1614005306723},{"_id":"themes/archer/src/scss/_variables.scss","hash":"136e5d990c4f8eadf6cabdfa5a053941e90bcd20","modified":1614005306723},{"_id":"themes/archer/src/scss/mobile.scss","hash":"aadc2fbf37fefc2ad391d8172d5b61817f9db0c5","modified":1614005306723},{"_id":"themes/archer/src/scss/style.scss","hash":"78e31370d45089b97fa91929345f1a29f2e6a0a2","modified":1614005306723},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1614005306703},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1614005306711},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1614005306711},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1614005306711},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1614005306715},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1614005306723},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"7691642fb9375607e0ac988a7420999e242cb2c9","modified":1614005306703},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cadd97820a23d01d8b7e2f19a86e5290cef5a8a6","modified":1614005306703},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"794647a8a4ac9e1d01d74c07717175a141b1e01c","modified":1614005306703},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"b27469f19f35ec2037c7bce736a12e9dfb5e360b","modified":1614005306703},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"2154360e330dab94540e168e9d301c7b7091968e","modified":1614005306703},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"790d76f2667377db78a7d04bad8d629e47e7aab0","modified":1614005306703},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"c03e16a7741908c207bf58363dcd1349cb639ef8","modified":1614005306703},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"291cc0a4a444a93b93c32e2c39383c70e36e46de","modified":1614005306703},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"2d38af7cb5aabc0af99de239bd180c516ec4c56c","modified":1614005306703},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"daa78b17a773bca569f1c8ca2c916495ca138da6","modified":1614005306703},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"147214469c4909eb94943599883f9fa0f3cc090d","modified":1614005306703},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"d6e1a192cac5dcf365ce1a52df4f23feafeeb849","modified":1614005306703},{"_id":"themes/archer/package-lock.json","hash":"89a3b67d32f6916cdc21d590d87e43d8a44be8c3","modified":1614005306707},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"a2b56f441a9a44d7f5b9b41eaa8136321328d7e9","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"c679578d2feb0bd7d3f80c2f693ba58cbca4428b","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"fa993cf0bbe0086cd8ec3d9a639b2d5b28ccfa8e","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7c557844850d53cc4fc36aaf6d59847d8f238947","modified":1614005306723},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1614005306703},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1614005306715},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1614005306719},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"726c543ee066e0b3222b236d9b4ef0109c0bdddf","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"77003ff22b1a10fae2d2768938277959b3f93a72","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"a1569f39eccd64a12425d81b794c53df126a4d87","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"0c986b52ce9083f08c37c5c9b5de045ac5e1d2fa","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"f2514031f9d7e4ed4a126694e78618ce6ff3a574","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"9c9a4e470da8732c9a3be3d5ce0d2f80f53714fe","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"14bc42292873880c61b5fa9f47ee9d2e08d46871","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"9ab6f96d0df0c4ad4c72e2515fa2599d487d8f1a","modified":1614005306723},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"981a94978535769cb51c29e12b627f83c6fcedc5","modified":1614005306723},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1614005306719},{"_id":"public/content.json","hash":"1d4dca39eb0a82253efc37dea546d5f1b120477e","modified":1623076475735},{"_id":"public/categories/index.html","hash":"b03d2f37581cccfa77cb5ff140ee65f2d2838a7c","modified":1623076403732},{"_id":"public/tags/index.html","hash":"33ee99c1fd46cce05e4c0f1c583fc023d7d7659d","modified":1623076403733},{"_id":"public/2021/02/22/测试1244253/index.html","hash":"8f7f9f0e897e12253b82cafa6ca1a4a78165bc6c","modified":1614006395981},{"_id":"public/2021/01/10/遇到问题最后解决的文章收藏/index.html","hash":"5f4b9160e95be1e0c09126f9bda4c2b26706dbaa","modified":1623076405955},{"_id":"public/2020/12/01/部署Yapi遇到的问题/index.html","hash":"725526469131b62071dea0cd0ea82aec766f07ab","modified":1623076405955},{"_id":"public/2020/11/15/Ubuntu系统服务器获取root权限/index.html","hash":"f46570cc8760c5dcc94b205e7f2eabf8ddc1374e","modified":1623076405955},{"_id":"public/2020/07/13/问题整理/index.html","hash":"f6ef844f625aa17d8debfdaa92a4d720ea60a65d","modified":1623076405955},{"_id":"public/2020/07/13/BFC理解原理/index.html","hash":"7abc2f17fd850c0792558842a9b5a576e1ea75f7","modified":1623076405955},{"_id":"public/2019/03/29/react-Context-上下文方法使用/index.html","hash":"fc851887b18b4601e20d6408f6e6bf5a943ab70d","modified":1623076405958},{"_id":"public/2018/07/25/forEach兼容写法/index.html","hash":"4aea156567425441840a8529149b0bb3cbcc115e","modified":1623076405958},{"_id":"public/2018/07/25/让h5页面强制横屏/index.html","hash":"d68834b854efb974ccd7e60fd96ec14dfc244a27","modified":1623076405955},{"_id":"public/2018/07/13/使用hexo搭建博客时遇到的问题/index.html","hash":"37e4639bf409388976fda01daeb20f59491972a4","modified":1623076405959},{"_id":"public/archives/index.html","hash":"e1b225c04beff9aeff0fa91dce8e3cfcac344c5d","modified":1623076478510},{"_id":"public/archives/page/2/index.html","hash":"a8c0d55d2ac1259596130ede46e42e41170c00ab","modified":1623076405962},{"_id":"public/archives/2018/index.html","hash":"2076807b18624b88e8647efc622ef5bdafde4cbe","modified":1623076405962},{"_id":"public/archives/2018/07/index.html","hash":"2076807b18624b88e8647efc622ef5bdafde4cbe","modified":1623076405962},{"_id":"public/archives/2019/index.html","hash":"47bb2fa539e88037769289164f02ca2babda3729","modified":1623076405962},{"_id":"public/archives/2019/03/index.html","hash":"47bb2fa539e88037769289164f02ca2babda3729","modified":1623076405962},{"_id":"public/archives/2020/index.html","hash":"378aad649c68f4b69f571bd2b799bbe1c582b091","modified":1623076405962},{"_id":"public/archives/2020/07/index.html","hash":"566d18de6b33ffbede887ebdaedb491161ed61d2","modified":1623076405963},{"_id":"public/archives/2020/11/index.html","hash":"a6dcd253f911d3bb8da58aaa27ae7d8c26e17a9a","modified":1623076405963},{"_id":"public/archives/2020/12/index.html","hash":"09fab394a4faedb3d25b64b58ebd9394a484beeb","modified":1623076405963},{"_id":"public/archives/2021/index.html","hash":"7f29692824a63d4b7d125bb71e8e265679fe99ca","modified":1623076478510},{"_id":"public/archives/2021/01/index.html","hash":"fb6e014eb9fd586ad6a728fcbcd30469289c8508","modified":1623076405966},{"_id":"public/archives/2021/02/index.html","hash":"23edda91418012b92a88245a0edb2183a86bec8e","modified":1615540250193},{"_id":"public/categories/技术/index.html","hash":"87ab48644a0535b01d74a6cc6aa30bf6300a6389","modified":1623076478510},{"_id":"public/categories/转载记录/index.html","hash":"a6dcd253f911d3bb8da58aaa27ae7d8c26e17a9a","modified":1623076405958},{"_id":"public/categories/记录/index.html","hash":"3b18938a22aad15c7bc423d36773fea72b508cf7","modified":1623076405958},{"_id":"public/categories/分类/index.html","hash":"46d24e9d8a37e994163deb4370f5f9d47c1a8f7c","modified":1615905314562},{"_id":"public/index.html","hash":"751b6c56042d1e0db9a9a4232cf959bbd08a47ba","modified":1623076478510},{"_id":"public/page/2/index.html","hash":"a525bdbed638c901b9f574926e62253d27f2f279","modified":1623076405958},{"_id":"public/tags/HTML/index.html","hash":"c77c28cf44cf298d9dd0ea4c701167ac1babcb7b","modified":1623076405958},{"_id":"public/tags/服务器/index.html","hash":"a6dcd253f911d3bb8da58aaa27ae7d8c26e17a9a","modified":1623076405958},{"_id":"public/tags/javaScript/index.html","hash":"829fc9cfeb9b78671631c046a6b52df6b12e4a70","modified":1623076405958},{"_id":"public/tags/react/index.html","hash":"868ec62d93f9365819f163d6e72f548704be0d15","modified":1623076405959},{"_id":"public/tags/心得/index.html","hash":"3b18938a22aad15c7bc423d36773fea72b508cf7","modified":1623076405959},{"_id":"public/tags/文章/index.html","hash":"f130bb0b5abbefc507425b3e14222a7105648c63","modified":1623076405962},{"_id":"public/tags/标签/index.html","hash":"46d24e9d8a37e994163deb4370f5f9d47c1a8f7c","modified":1615905314563},{"_id":"public/tags/技巧/index.html","hash":"69d28e0f78892168be0ce6d06175a9ec833f3bb3","modified":1623076405959},{"_id":"public/assets/yapi-img.png","hash":"51138f04c054864a2882fe9f5b369e6005b98cef","modified":1614006305159},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1614006305159},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1614006305159},{"_id":"public/assets/favicon.ico","hash":"d6d9068d1928f9f69ddb2772816fccc01c74cde5","modified":1614006305159},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1614006305159},{"_id":"public/avatar/avatar.jpg","hash":"061fcb1e751dd9f2d73e9abe1a841b107f84e792","modified":1614006305159},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1614006305160},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1614006305160},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1614006305165},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1614006305166},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1614006305166},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1614006305166},{"_id":"public/css/mobile.css","hash":"51d7b5cf26c8f82a3daad4bc55518673fdf281f5","modified":1614006305172},{"_id":"public/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1614006305172},{"_id":"public/lib/webfontloader.min.js","hash":"bc6ffe9c0d8b3285564619a445c6ca575eb9d0f5","modified":1614006305178},{"_id":"public/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1614006305182},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1614006305182},{"_id":"public/css/style.css","hash":"5d5e869db0c62957d59c6865baaecd1428c51804","modified":1614006305218},{"_id":"public/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1614006305218},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1614006305219},{"_id":"public/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1614006305226},{"_id":"public/lib/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1614006305252},{"_id":"source/_posts/test01.md","hash":"9c1fdd70d147aa89dc0570532f1e2ea81d17607b","modified":1614006393608},{"_id":"public/2021/02/22/test01/index.html","hash":"20c2bcc81c40919d3e7364d73a712c4742266a05","modified":1615540250188},{"_id":"public/categories/测试/index.html","hash":"23edda91418012b92a88245a0edb2183a86bec8e","modified":1615540250193},{"_id":"public/tags/测试/index.html","hash":"23edda91418012b92a88245a0edb2183a86bec8e","modified":1615540250194},{"_id":"source/_posts/React.memo() 使用.md","hash":"29f1e5fb6b7fc157187bd2f73624385045c9e3d3","modified":1615451764250},{"_id":"public/2021/03/11/React.memo() 使用/index.html","hash":"8ef68e04a57cfabbabedaeb5bf8feb6800971c75","modified":1623076405955},{"_id":"public/tags/前端/index.html","hash":"3828a680c5d6326dffb2d4349d0243032ae4c7f9","modified":1623076405959},{"_id":"public/archives/2021/03/index.html","hash":"7ffa50b457dd2b7ab5ce09179afd5fe25ffce746","modified":1623076405966},{"_id":"source/_posts/高阶组件.md","hash":"b219969997e135153b86c1f66eb01ba9edffeb08","modified":1615452065979},{"_id":"public/2021/03/11/高阶组件/index.html","hash":"cf3b041fb0435018f16b29ab3ec9151029802b00","modified":1623076405955},{"_id":"source/_posts/react 海量数据优化-时间分片，虚拟列表.md","hash":"eea3e18da3b8ecc6a2f7b0b141b22b34751c906b","modified":1615540247487},{"_id":"public/2021/03/11/react 海量数据优化-时间分片，虚拟列表/index.html","hash":"a730ea43f3db7cda534748974d5539564d8445a8","modified":1623076405955},{"_id":"public/tags/性能优化/index.html","hash":"4d0d5bebb1378df2d7a63e785c254924503f9d21","modified":1623076405959},{"_id":"source/_posts/测试111111.md","hash":"1c672691cec02368d345ff2c14d741339ed746b0","modified":1615905307122},{"_id":"public/2021/03/16/测试111111/index.html","hash":"c9d1883986d3361f1586ebfbf9bc67cb95f16d46","modified":1615905314528},{"_id":"source/_posts/promise和async，await区别.md","hash":"c733b492904d53811abde42f9610003f6dd6f34e","modified":1616146746127},{"_id":"public/2021/03/19/promise和async，await区别/index.html","hash":"871795ba9366c89b4d5d6f84d64cda2de2bc4d0b","modified":1623076405955},{"_id":"public/categories/技术/page/2/index.html","hash":"5ff58e924016cbfe62429403d321ce9196fffc07","modified":1623076405958},{"_id":"public/tags/es6/index.html","hash":"31a92a9c4b30bb61898715d42c5a49fee78570ab","modified":1623076405959},{"_id":"source/_posts/一个正则表达式解析.md","hash":"775bbd08c2519e9ab9105c36852e4fef5c29183b","modified":1616336004038},{"_id":"public/2021/03/19/一个正则表达式解析/index.html","hash":"cdbe971b367b02a3dd06348e4a0003c13dd83031","modified":1623076405955},{"_id":"public/tags/正则/index.html","hash":"1013f5ef3dbfab4d0bd7ccf5392b9f3cc6cf66e2","modified":1623076405962},{"_id":"source/_posts/Decorator（修饰器）的用法及参数.md","hash":"1cdd24b58b16de19b73d7a0a8538eebe141e71ac","modified":1616408434000},{"_id":"source/_posts/测试.md","hash":"476f6faca886f0cbc453ce5ff6a2d03d833f9789","modified":1616408326000},{"_id":"public/2020/12/01/测试/index.html","hash":"92a6b81b1a77d3f6656fb548bdc3b7f58d2b835a","modified":1616408385293},{"_id":"public/2021/03/22/Decorator（修饰器）的用法及参数/index.html","hash":"49e4afee2daca27223e2faa9f23020268b349199","modified":1623076405955},{"_id":"source/_posts/js事件循环队列.md","hash":"aebae25ae49e7878b16b9338541e9e166ff98cb6","modified":1616688481655},{"_id":"public/2021/03/22/js事件循环队列/index.html","hash":"5034b68209d205c942b7b2d5baff63d2bdc8b912","modified":1623076405954},{"_id":"source/_posts/input禁止自动回填方法.md","hash":"52d94a7bea53d25c55248b5d59fb7de78203123c","modified":1616551735060},{"_id":"public/2021/03/24/input禁止自动回填方法/index.html","hash":"21f65fa041f85ffe8cb73db3a7cf4a7a0d44b746","modified":1623076405954},{"_id":"public/archives/page/3/index.html","hash":"8725a980e3b92ee91a446f2a85c4bd5188ee8202","modified":1623076405962},{"_id":"public/archives/2021/page/2/index.html","hash":"b93ed8c252438fde2c0e0ce995d69bcd3b016031","modified":1623076405966},{"_id":"public/page/3/index.html","hash":"5db4a6a74dfec5c291e81e863ac904bdf9023098","modified":1623076405958},{"_id":"source/_posts/h5离线存储 manifest.md","hash":"b2bbd0826bc9c61814080b0f7c043b16200e9105","modified":1616949529310},{"_id":"public/2021/03/28/h5离线存储 manifest/index.html","hash":"b4c5229e1ee2c2359e27a14e48e9414d3d665bc0","modified":1623076405954},{"_id":"public/tags/前端/page/2/index.html","hash":"989959eb6e9022d4a5509af36c7c11c04d60c1fd","modified":1623076405959},{"_id":"public/archives/2021/03/page/2/index.html","hash":"1967f01e5df1c9b7c60557cb0c26d03b3b20fd55","modified":1623076405966},{"_id":"source/_posts/HTTP缓存.md","hash":"8d109c0a04e22e156f3b6c65b9f249851ad8af67","modified":1617549356478},{"_id":"public/2021/04/04/HTTP缓存/index.html","hash":"c80910d872f54339bf66a4c100a718ca3b4d614c","modified":1623076405954},{"_id":"public/archives/2021/04/index.html","hash":"a5c4192afcfaedb4399fb6d94e857c02fdace8b1","modified":1623076405966},{"_id":"source/_posts/xss和csrf介绍.md","hash":"9066c7409eb2ed7d111b446b2d5358df374b820d","modified":1618246517174},{"_id":"public/2021/04/13/xss和csrf介绍/index.html","hash":"1e576765bd16bfea2efc1171b9890b8daf850b72","modified":1623076405954},{"_id":"source/_posts/事件冒泡.md","hash":"a78c98b783f5950611f9795d306c32ee43d68a37","modified":1618293651805},{"_id":"source/assets/事件冒泡图.png","hash":"b7d6a6be16a38862812ed7d41d859c80d67612b2","modified":1618291884244},{"_id":"public/2021/04/13/事件冒泡/index.html","hash":"070d8867aad40df7ac39ce2cd2e06d8d96577a5c","modified":1623076405910},{"_id":"public/categories/技术/page/3/index.html","hash":"dde304e9cdff6d51eab45b88be09349dadaa269c","modified":1623076405966},{"_id":"public/assets/事件冒泡图.png","hash":"b7d6a6be16a38862812ed7d41d859c80d67612b2","modified":1618291999485},{"_id":"source/_posts/React16 中生命周期废旧立新的思考.md","hash":"6029f0ed2f5e84b2379223f38f63064670521af2","modified":1618332212784},{"_id":"public/2021/04/14/React16 中生命周期废旧立新的思考/index.html","hash":"62dfe05bd73673fbb95fc7073dcd9303a6c2804d","modified":1618332260416},{"_id":"source/_posts/React16 中生命周期废旧立新的思考（为什么要废弃三个API）.md","hash":"637866213d3a9da45388285a5822e115f44f2fa1","modified":1618333117283},{"_id":"public/2021/04/14/React16 中生命周期废旧立新的思考（为什么要废弃三个API）/index.html","hash":"58258f9e59f17cb1b76bbf9b870eba1fbbfeae39","modified":1623076405954},{"_id":"source/_posts/React15 和 React16 生命周期区别对比.md","hash":"0f4cdab6687f19e9e326025ae730c287ce5df6d4","modified":1618333029440},{"_id":"public/2021/04/14/React15 和 React16 生命周期区别对比/index.html","hash":"81c62fd8d1afc581df044d1d9fd0716a45ed48e7","modified":1623076405950},{"_id":"source/_posts/React Fiber架构设计原理.md","hash":"4f9eaaa64e257609a9566afbb0916ad3da5c1377","modified":1618332974195},{"_id":"public/2021/04/14/React Fiber架构设计原理/index.html","hash":"f9cf30c288cdfdfe6d3051e72bf9e481abe7d860","modified":1623076405949},{"_id":"source/_posts/Object对象下的方法.md","hash":"739b7d205204e41dc4db917a729f73a4d48a6845","modified":1618409764804},{"_id":"public/2021/04/14/Object对象下的方法/index.html","hash":"9b71ff4cf9d912aacb1459749634bfce039020cf","modified":1623076405837},{"_id":"public/page/4/index.html","hash":"c5082570d31f55beac08b2d1f9d322a1fd45f0fd","modified":1623076405962},{"_id":"public/archives/page/4/index.html","hash":"44bec2afa7a04c3d35d652f4b097d1de77d404d6","modified":1623076405966},{"_id":"public/archives/2021/page/3/index.html","hash":"59244fc28d3cfeb54ba4bee6cec8bb2b8de18630","modified":1623076405966},{"_id":"source/_posts/手动实现一个new方法.md","hash":"6e759aeb555f5b38a720e9ad7fbe1d68c6095a44","modified":1618417160667},{"_id":"public/2021/04/15/手动实现一个new方法/index.html","hash":"976c5bdfdd1a34eea394974d5c7d1893e8347f6c","modified":1623076405824},{"_id":"public/tags/前端/page/3/index.html","hash":"594683d97787f4766096a0eef9b5de38cefca650","modified":1623076405959},{"_id":"source/_posts/移动端适配.md","hash":"2c9505aa3faded0f3a564b78bda5a624eed1e689","modified":1619665087272},{"_id":"public/2021/04/29/移动端适配/index.html","hash":"0d63893f7f7ae1bc986191998a0ca3ea9c1866ca","modified":1623076405836},{"_id":"public/archives/2021/04/page/2/index.html","hash":"77990750fa8b4bd141821cb9e6ce8c4527b7b5d2","modified":1623076405966},{"_id":"source/_posts/Mac git 代码提交太慢问题解决.md","hash":"b48e978369d927817dd1795f24c7880843163c24","modified":1623076470405},{"_id":"public/2021/06/07/Mac git 代码提交太慢问题解决/index.html","hash":"84aec24747a6688c543e267dcb8d6ab07a4fe71e","modified":1623076478502},{"_id":"public/tags/git/index.html","hash":"2dba159eac6aaad89ba4a088d3d5f6a09646acc7","modified":1623076478510},{"_id":"public/archives/2021/06/index.html","hash":"2dba159eac6aaad89ba4a088d3d5f6a09646acc7","modified":1623076478510}],"Category":[{"name":"技术","_id":"cklgpoic70004jxwh8k1ktj79"},{"name":"转载记录","_id":"cklgpoicd0009jxwhnjwt7hs6"},{"name":"记录","_id":"cklgpoicq000ljxwhbi6vu8ua"},{"name":"分类","_id":"cklgpoics000rjxwhz3neq5b2"},{"name":"测试","_id":"cklgpqgoe0001r9whcmjhfevf"}],"Data":[],"Page":[{"title":"文章分类","date":"2019-03-29T09:17:36.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-03-29 17:17:36\ntype: \"categories\"   #这部分是新添加的\n---\n","updated":"2021-02-22T14:48:26.695Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cklgpoic30001jxwhlz50t87t","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2019-03-29T09:18:23.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-03-29 17:18:23\ntype: \"tags\" #新添加的内容\n\n---\n","updated":"2021-02-22T14:48:26.695Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cklgpoic50003jxwhhhiondjs","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"BFC理解原理","date":"2020-07-13T06:26:43.000Z","copyright":false,"_content":"\n## 一、常见定位方案\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n- 普通流 (normal flow)\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n- 浮动 (float)\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n- 绝对定位 (absolute positioning)\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n## 二、BFC 概念\nFormatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n\n那么 BFC 是什么呢？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n## 三、触发 BFC\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素\n- 浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n","source":"_posts/BFC理解原理.md","raw":"---\ntitle: BFC理解原理\ndate: 2020-07-13 14:26:43\ntags: HTML\ncategories: 技术\ncopyright: false\n---\n\n## 一、常见定位方案\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n- 普通流 (normal flow)\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n- 浮动 (float)\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n- 绝对定位 (absolute positioning)\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n## 二、BFC 概念\nFormatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n\n那么 BFC 是什么呢？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n## 三、触发 BFC\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素\n- 浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n","slug":"BFC理解原理","published":1,"updated":"2021-03-28T16:35:34.280Z","_id":"cklgpoiby0000jxwhljy5ie06","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、常见定位方案\"><a href=\"#一、常见定位方案\" class=\"headerlink\" title=\"一、常见定位方案\"></a>一、常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<ul>\n<li>普通流 (normal flow)<blockquote>\n<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n</blockquote>\n</li>\n<li>浮动 (float)<blockquote>\n<p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n</blockquote>\n</li>\n<li>绝对定位 (absolute positioning)<blockquote>\n<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"二、BFC-概念\"><a href=\"#二、BFC-概念\" class=\"headerlink\" title=\"二、BFC 概念\"></a>二、BFC 概念</h2><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p>那么 BFC 是什么呢？</p>\n<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p>\n<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>\n<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h2 id=\"三、触发-BFC\"><a href=\"#三、触发-BFC\" class=\"headerlink\" title=\"三、触发 BFC\"></a>三、触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素</li>\n<li>浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、常见定位方案\"><a href=\"#一、常见定位方案\" class=\"headerlink\" title=\"一、常见定位方案\"></a>一、常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<ul>\n<li>普通流 (normal flow)<blockquote>\n<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n</blockquote>\n</li>\n<li>浮动 (float)<blockquote>\n<p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n</blockquote>\n</li>\n<li>绝对定位 (absolute positioning)<blockquote>\n<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"二、BFC-概念\"><a href=\"#二、BFC-概念\" class=\"headerlink\" title=\"二、BFC 概念\"></a>二、BFC 概念</h2><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p>那么 BFC 是什么呢？</p>\n<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p>\n<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>\n<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h2 id=\"三、触发-BFC\"><a href=\"#三、触发-BFC\" class=\"headerlink\" title=\"三、触发 BFC\"></a>三、触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素</li>\n<li>浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n"},{"title":"Ubuntu系统服务器获取root权限","date":"2020-11-15T09:20:42.000Z","description":null,"copyright":{"enable":true,"permalink":"https://blog.csdn.net/SSS_Benjamin/article/details/88415895"},"_content":"\n刚重装好的ubuntu系统只能用普通账户登录没有root权限，有时候会出现没有权限的提示。\n\n###### 解决方法\n首先用SSH工具登录服务器，我用的Finalshell，输入以下指令并回车，设置root账户密码（ 为了方便记忆，可以设置成和ubuntu账户相同的密码）\n```\nsudo passwd root   \n```\n![image](https://img-blog.csdnimg.cn/20190312101939693.png#pic_center)\n\n按照提示设置好密码后，输入以下指令并回车，修改sshd_config文件\n```\nsudo vi /etc/ssh/sshd_config\n```\n![image](https://img-blog.csdnimg.cn/20190312102310568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTU19CZW5qYW1pbg==,size_16,color_FFFFFF,t_70#pic_center)\n\n用键盘向下翻，找到如下图所示的内容\n![image](https://img-blog.csdnimg.cn/20190312102402699.png#pic_center)\n\n此时是命令行模式，无法对文件进行修改，按i键并回车进入插入模式就可以修改了\n将PermitRootLogin后面的内容改为yes，如下图\n![image](https://img-blog.csdnimg.cn/20190312102600657.png#pic_center)\n\n按Esc键回到命令行模式，再按Shift+分号组合键（就是输入冒号的组合键），输入wq并回车，保存并退出\n![image](https://img-blog.csdnimg.cn/20190312102814911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTU19CZW5qYW1pbg==,size_16,color_FFFFFF,t_70#pic_center)\n\n回车后就会回到之前的界面\n![image](https://img-blog.csdnimg.cn/20190312102942967.png#pic_center)\n\n输入以下指令并回车，重启ssh服务\n```\nsudo service ssh restart\n```\n![image](https://img-blog.csdnimg.cn/2019031210345468.png#pic_center)\n\n然后关掉SSH工具重新打开，修改之前的登录信息或者新建一个连接，用户名是root，密码是本文开头设置的那个密码，就可以直接登录root账户了\n\n","source":"_posts/Ubuntu系统服务器获取root权限.md","raw":"---\ntitle: Ubuntu系统服务器获取root权限\ndate: 2020-11-15 17:20:42\ntags: 服务器\ndescription:\ncategories: 转载记录\ncopyright:\n  enable: true\n  permalink: https://blog.csdn.net/SSS_Benjamin/article/details/88415895\n\n---\n\n刚重装好的ubuntu系统只能用普通账户登录没有root权限，有时候会出现没有权限的提示。\n\n###### 解决方法\n首先用SSH工具登录服务器，我用的Finalshell，输入以下指令并回车，设置root账户密码（ 为了方便记忆，可以设置成和ubuntu账户相同的密码）\n```\nsudo passwd root   \n```\n![image](https://img-blog.csdnimg.cn/20190312101939693.png#pic_center)\n\n按照提示设置好密码后，输入以下指令并回车，修改sshd_config文件\n```\nsudo vi /etc/ssh/sshd_config\n```\n![image](https://img-blog.csdnimg.cn/20190312102310568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTU19CZW5qYW1pbg==,size_16,color_FFFFFF,t_70#pic_center)\n\n用键盘向下翻，找到如下图所示的内容\n![image](https://img-blog.csdnimg.cn/20190312102402699.png#pic_center)\n\n此时是命令行模式，无法对文件进行修改，按i键并回车进入插入模式就可以修改了\n将PermitRootLogin后面的内容改为yes，如下图\n![image](https://img-blog.csdnimg.cn/20190312102600657.png#pic_center)\n\n按Esc键回到命令行模式，再按Shift+分号组合键（就是输入冒号的组合键），输入wq并回车，保存并退出\n![image](https://img-blog.csdnimg.cn/20190312102814911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTU19CZW5qYW1pbg==,size_16,color_FFFFFF,t_70#pic_center)\n\n回车后就会回到之前的界面\n![image](https://img-blog.csdnimg.cn/20190312102942967.png#pic_center)\n\n输入以下指令并回车，重启ssh服务\n```\nsudo service ssh restart\n```\n![image](https://img-blog.csdnimg.cn/2019031210345468.png#pic_center)\n\n然后关掉SSH工具重新打开，修改之前的登录信息或者新建一个连接，用户名是root，密码是本文开头设置的那个密码，就可以直接登录root账户了\n\n","slug":"Ubuntu系统服务器获取root权限","published":1,"updated":"2021-02-22T14:48:26.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklgpoic40002jxwhb4rn38gm","content":"<p>刚重装好的ubuntu系统只能用普通账户登录没有root权限，有时候会出现没有权限的提示。</p>\n<h6 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h6><p>首先用SSH工具登录服务器，我用的Finalshell，输入以下指令并回车，设置root账户密码（ 为了方便记忆，可以设置成和ubuntu账户相同的密码）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo passwd root</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190312101939693.png#pic_center\" alt=\"image\"></p>\n<p>按照提示设置好密码后，输入以下指令并回车，修改sshd_config文件<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190312102310568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTU19CZW5qYW1pbg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>用键盘向下翻，找到如下图所示的内容<br><img src=\"https://img-blog.csdnimg.cn/20190312102402699.png#pic_center\" alt=\"image\"></p>\n<p>此时是命令行模式，无法对文件进行修改，按i键并回车进入插入模式就可以修改了<br>将PermitRootLogin后面的内容改为yes，如下图<br><img src=\"https://img-blog.csdnimg.cn/20190312102600657.png#pic_center\" alt=\"image\"></p>\n<p>按Esc键回到命令行模式，再按Shift+分号组合键（就是输入冒号的组合键），输入wq并回车，保存并退出<br><img src=\"https://img-blog.csdnimg.cn/20190312102814911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTU19CZW5qYW1pbg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>回车后就会回到之前的界面<br><img src=\"https://img-blog.csdnimg.cn/20190312102942967.png#pic_center\" alt=\"image\"></p>\n<p>输入以下指令并回车，重启ssh服务<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo service ssh restart</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019031210345468.png#pic_center\" alt=\"image\"></p>\n<p>然后关掉SSH工具重新打开，修改之前的登录信息或者新建一个连接，用户名是root，密码是本文开头设置的那个密码，就可以直接登录root账户了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>刚重装好的ubuntu系统只能用普通账户登录没有root权限，有时候会出现没有权限的提示。</p>\n<h6 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h6><p>首先用SSH工具登录服务器，我用的Finalshell，输入以下指令并回车，设置root账户密码（ 为了方便记忆，可以设置成和ubuntu账户相同的密码）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo passwd root</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190312101939693.png#pic_center\" alt=\"image\"></p>\n<p>按照提示设置好密码后，输入以下指令并回车，修改sshd_config文件<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190312102310568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTU19CZW5qYW1pbg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>用键盘向下翻，找到如下图所示的内容<br><img src=\"https://img-blog.csdnimg.cn/20190312102402699.png#pic_center\" alt=\"image\"></p>\n<p>此时是命令行模式，无法对文件进行修改，按i键并回车进入插入模式就可以修改了<br>将PermitRootLogin后面的内容改为yes，如下图<br><img src=\"https://img-blog.csdnimg.cn/20190312102600657.png#pic_center\" alt=\"image\"></p>\n<p>按Esc键回到命令行模式，再按Shift+分号组合键（就是输入冒号的组合键），输入wq并回车，保存并退出<br><img src=\"https://img-blog.csdnimg.cn/20190312102814911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NTU19CZW5qYW1pbg==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"image\"></p>\n<p>回车后就会回到之前的界面<br><img src=\"https://img-blog.csdnimg.cn/20190312102942967.png#pic_center\" alt=\"image\"></p>\n<p>输入以下指令并回车，重启ssh服务<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo service ssh restart</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019031210345468.png#pic_center\" alt=\"image\"></p>\n<p>然后关掉SSH工具重新打开，修改之前的登录信息或者新建一个连接，用户名是root，密码是本文开头设置的那个密码，就可以直接登录root账户了</p>\n"},{"title":"forEach兼容写法","date":"2018-07-25T07:51:43.000Z","_content":"\n最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。\n\n最后在网上找到这段(兼容IE8)\n\n```\n\n    if ( !Array.prototype.forEach ) {\n        Array.prototype.forEach = function forEach( callback, thisArg ) {\n            var T, k;\n            if ( this == null ) {\n                throw new TypeError( \"this is null or not defined\" );\n            }\n            var O = Object(this);\n            var len = O.length >>> 0;\n            if ( typeof callback !== \"function\" ) {\n                throw new TypeError( callback + \" is not a function\" );\n            }\n            if ( arguments.length > 1 ) {\n                T = thisArg;\n            }\n            k = 0;\n            while( k < len ) {\n    \n                var kValue;\n                if ( k in O ) {\n                    kValue = O[ k ];\n                    callback.call( T, kValue, k, O );\n                }\n                k++;\n            }\n        };\n    }\n\n```\n","source":"_posts/forEach兼容写法.md","raw":"---\ntitle: forEach兼容写法\ndate: 2018-07-25 15:51:43\ntags: javaScript\ncategories: 技术\n---\n\n最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。\n\n最后在网上找到这段(兼容IE8)\n\n```\n\n    if ( !Array.prototype.forEach ) {\n        Array.prototype.forEach = function forEach( callback, thisArg ) {\n            var T, k;\n            if ( this == null ) {\n                throw new TypeError( \"this is null or not defined\" );\n            }\n            var O = Object(this);\n            var len = O.length >>> 0;\n            if ( typeof callback !== \"function\" ) {\n                throw new TypeError( callback + \" is not a function\" );\n            }\n            if ( arguments.length > 1 ) {\n                T = thisArg;\n            }\n            k = 0;\n            while( k < len ) {\n    \n                var kValue;\n                if ( k in O ) {\n                    kValue = O[ k ];\n                    callback.call( T, kValue, k, O );\n                }\n                k++;\n            }\n        };\n    }\n\n```\n","slug":"forEach兼容写法","published":1,"updated":"2021-02-22T14:48:26.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklgpoic90006jxwhjesvmxr3","content":"<p>最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。</p>\n<p>最后在网上找到这段(兼容IE8)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if ( !Array.prototype.forEach ) &#123;</span><br><span class=\"line\">    Array.prototype.forEach = function forEach( callback, thisArg ) &#123;</span><br><span class=\"line\">        var T, k;</span><br><span class=\"line\">        if ( this == null ) &#123;</span><br><span class=\"line\">            throw new TypeError( &quot;this is null or not defined&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var O = Object(this);</span><br><span class=\"line\">        var len = O.length &gt;&gt;&gt; 0;</span><br><span class=\"line\">        if ( typeof callback !== &quot;function&quot; ) &#123;</span><br><span class=\"line\">            throw new TypeError( callback + &quot; is not a function&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if ( arguments.length &gt; 1 ) &#123;</span><br><span class=\"line\">            T = thisArg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k = 0;</span><br><span class=\"line\">        while( k &lt; len ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            var kValue;</span><br><span class=\"line\">            if ( k in O ) &#123;</span><br><span class=\"line\">                kValue = O[ k ];</span><br><span class=\"line\">                callback.call( T, kValue, k, O );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。</p>\n<p>最后在网上找到这段(兼容IE8)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if ( !Array.prototype.forEach ) &#123;</span><br><span class=\"line\">    Array.prototype.forEach = function forEach( callback, thisArg ) &#123;</span><br><span class=\"line\">        var T, k;</span><br><span class=\"line\">        if ( this == null ) &#123;</span><br><span class=\"line\">            throw new TypeError( &quot;this is null or not defined&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var O = Object(this);</span><br><span class=\"line\">        var len = O.length &gt;&gt;&gt; 0;</span><br><span class=\"line\">        if ( typeof callback !== &quot;function&quot; ) &#123;</span><br><span class=\"line\">            throw new TypeError( callback + &quot; is not a function&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if ( arguments.length &gt; 1 ) &#123;</span><br><span class=\"line\">            T = thisArg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k = 0;</span><br><span class=\"line\">        while( k &lt; len ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            var kValue;</span><br><span class=\"line\">            if ( k in O ) &#123;</span><br><span class=\"line\">                kValue = O[ k ];</span><br><span class=\"line\">                callback.call( T, kValue, k, O );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"react Context(上下文方法使用)","date":"2019-03-29T06:41:51.000Z","_content":"\n> 使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件\n\n```\n//定义\nconst defaultValue = 'aaa';\nconst LocaleContext = React.createContext(defaultValue);\n\n//父组件\nclass LocaleProvider extends React.Component{\n    state = {\n        locale: defaultValue\n    }\n    render(){\n        return (\n            <LocaleContext.Provider value={this.state.locale}>\n                <button onClick={()=>this.setState({locale: 'bbb')})} >\n                    切换\n                </button>\n                {this.props.children]\n            </LocaleContext.Provider>\n        )\n    }\n}\n\n//子组件\nclass LocaledButtons extends React.Componet{\n    render(){\n        return (\n            <LocaleContext.Consumer>\n                {locale => (\n                    <div>\n                        <span>{locale}</span>\n                    </div>\n                }\n            </LocaleContext.Consumer>        \n        )\n    }\n}\n\n//实际使用\nexport default () => (\n    <LocaleProvider>\n        <LocaledButtons />\n    </LocaleProvider>\n)\n\n\n```\n","source":"_posts/react-Context-上下文方法使用.md","raw":"---\ntitle: react Context(上下文方法使用)\ndate: 2019-03-29 14:41:51\ntags: react\ncategories: 技术\n---\n\n> 使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件\n\n```\n//定义\nconst defaultValue = 'aaa';\nconst LocaleContext = React.createContext(defaultValue);\n\n//父组件\nclass LocaleProvider extends React.Component{\n    state = {\n        locale: defaultValue\n    }\n    render(){\n        return (\n            <LocaleContext.Provider value={this.state.locale}>\n                <button onClick={()=>this.setState({locale: 'bbb')})} >\n                    切换\n                </button>\n                {this.props.children]\n            </LocaleContext.Provider>\n        )\n    }\n}\n\n//子组件\nclass LocaledButtons extends React.Componet{\n    render(){\n        return (\n            <LocaleContext.Consumer>\n                {locale => (\n                    <div>\n                        <span>{locale}</span>\n                    </div>\n                }\n            </LocaleContext.Consumer>        \n        )\n    }\n}\n\n//实际使用\nexport default () => (\n    <LocaleProvider>\n        <LocaledButtons />\n    </LocaleProvider>\n)\n\n\n```\n","slug":"react-Context-上下文方法使用","published":1,"updated":"2021-02-22T14:48:26.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklgpoica0007jxwhvgrjb97k","content":"<blockquote>\n<p>使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">const defaultValue = &apos;aaa&apos;;</span><br><span class=\"line\">const LocaleContext = React.createContext(defaultValue);</span><br><span class=\"line\"></span><br><span class=\"line\">//父组件</span><br><span class=\"line\">class LocaleProvider extends React.Component&#123;</span><br><span class=\"line\">    state = &#123;</span><br><span class=\"line\">        locale: defaultValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Provider value=&#123;this.state.locale&#125;&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;locale: &apos;bbb&apos;)&#125;)&#125; &gt;</span><br><span class=\"line\">                    切换</span><br><span class=\"line\">                &lt;/button&gt;</span><br><span class=\"line\">                &#123;this.props.children]</span><br><span class=\"line\">            &lt;/LocaleContext.Provider&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子组件</span><br><span class=\"line\">class LocaledButtons extends React.Componet&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Consumer&gt;</span><br><span class=\"line\">                &#123;locale =&gt; (</span><br><span class=\"line\">                    &lt;div&gt;</span><br><span class=\"line\">                        &lt;span&gt;&#123;locale&#125;&lt;/span&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &lt;/LocaleContext.Consumer&gt;        </span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//实际使用</span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">    &lt;LocaleProvider&gt;</span><br><span class=\"line\">        &lt;LocaledButtons /&gt;</span><br><span class=\"line\">    &lt;/LocaleProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">const defaultValue = &apos;aaa&apos;;</span><br><span class=\"line\">const LocaleContext = React.createContext(defaultValue);</span><br><span class=\"line\"></span><br><span class=\"line\">//父组件</span><br><span class=\"line\">class LocaleProvider extends React.Component&#123;</span><br><span class=\"line\">    state = &#123;</span><br><span class=\"line\">        locale: defaultValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Provider value=&#123;this.state.locale&#125;&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;locale: &apos;bbb&apos;)&#125;)&#125; &gt;</span><br><span class=\"line\">                    切换</span><br><span class=\"line\">                &lt;/button&gt;</span><br><span class=\"line\">                &#123;this.props.children]</span><br><span class=\"line\">            &lt;/LocaleContext.Provider&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子组件</span><br><span class=\"line\">class LocaledButtons extends React.Componet&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Consumer&gt;</span><br><span class=\"line\">                &#123;locale =&gt; (</span><br><span class=\"line\">                    &lt;div&gt;</span><br><span class=\"line\">                        &lt;span&gt;&#123;locale&#125;&lt;/span&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &lt;/LocaleContext.Consumer&gt;        </span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//实际使用</span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">    &lt;LocaleProvider&gt;</span><br><span class=\"line\">        &lt;LocaledButtons /&gt;</span><br><span class=\"line\">    &lt;/LocaleProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n"},{"title":"使用hexo搭建博客时遇到的问题","date":"2018-07-13T09:45:51.000Z","_content":"\n\n花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。\n\n\n\n\n\n\n\n\n\n","source":"_posts/使用hexo搭建博客时遇到的问题.md","raw":"---\ntitle: 使用hexo搭建博客时遇到的问题\ndate: 2018-07-13 17:45:51\ntags: [心得,文章]\ncategories: 记录\n---\n\n\n花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。\n\n\n\n\n\n\n\n\n\n","slug":"使用hexo搭建博客时遇到的问题","published":1,"updated":"2021-02-22T14:48:26.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklgpoicc0008jxwh1xyvtnxq","content":"<p>花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。</p>\n"},{"title":"让h5页面强制横屏","date":"2018-07-25T07:51:43.000Z","_content":"\n>转载至：https://blog.csdn.net/qq_36457584/article/details/80967278\n\n```\n//注意设置*{padding:0;margin:0;} 不然有滚动条\n/**\n    * H5强制横屏\n    * @param {Object}\n    */   \nvar wrapper = document.getElementById(\"root\");      \nvar mark = window.orientation == 90 || window.orientation == -90;    //初始角度\n//不同角度宽高需要互换\nvar width = document.documentElement[mark ? 'clientHeight' : 'clientWidth']; \nvar height = document.documentElement[mark ? 'clientWidth' : 'clientHeight'];                         \nvar detectOrient = function() {\n    var style = \"\";                            \n    if (window.orientation == 90 || window.orientation == -90) { //横屏                             \n        style += \"width:100%;\"; \n        style += \"height:100%;\";\n        style += \"-webkit-transform: rotate(0); transform: rotate(0);\";\n        style += \"-webkit-transform-origin: 0 0;\";\n        style += \"transform-origin: 0 0;\";\n    } else if(window.orientation == 180 || window.orientation == 0){ //竖屏                    \n        style += \"width:\" + height + \"px;\";// 注意旋转后的宽高切换\n        style += \"height:\"+  width + \"px;\";\n        style += \"-webkit-transform: rotate(90deg); transform: rotate(90deg);\";\n        // 注意旋转中点的处理\n        style += \"-webkit-transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n        style += \"transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n    }\n    style += \"visibility: initial;\";\n    wrapper.style.cssText = style;\n    $(\"#progress\").addClass(\"animate-progress\");\n}        \nwindow.addEventListener(\"load\", detectOrient, false);\nwindow.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", detectOrient, false);\ndetectOrient();  \n\n```","source":"_posts/让h5页面强制横屏.md","raw":"---\ntitle: 让h5页面强制横屏\ndate: 2018-07-25 15:51:43\ntags: [javaScript,技巧]\ncategories: 技术\n---\n\n>转载至：https://blog.csdn.net/qq_36457584/article/details/80967278\n\n```\n//注意设置*{padding:0;margin:0;} 不然有滚动条\n/**\n    * H5强制横屏\n    * @param {Object}\n    */   \nvar wrapper = document.getElementById(\"root\");      \nvar mark = window.orientation == 90 || window.orientation == -90;    //初始角度\n//不同角度宽高需要互换\nvar width = document.documentElement[mark ? 'clientHeight' : 'clientWidth']; \nvar height = document.documentElement[mark ? 'clientWidth' : 'clientHeight'];                         \nvar detectOrient = function() {\n    var style = \"\";                            \n    if (window.orientation == 90 || window.orientation == -90) { //横屏                             \n        style += \"width:100%;\"; \n        style += \"height:100%;\";\n        style += \"-webkit-transform: rotate(0); transform: rotate(0);\";\n        style += \"-webkit-transform-origin: 0 0;\";\n        style += \"transform-origin: 0 0;\";\n    } else if(window.orientation == 180 || window.orientation == 0){ //竖屏                    \n        style += \"width:\" + height + \"px;\";// 注意旋转后的宽高切换\n        style += \"height:\"+  width + \"px;\";\n        style += \"-webkit-transform: rotate(90deg); transform: rotate(90deg);\";\n        // 注意旋转中点的处理\n        style += \"-webkit-transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n        style += \"transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n    }\n    style += \"visibility: initial;\";\n    wrapper.style.cssText = style;\n    $(\"#progress\").addClass(\"animate-progress\");\n}        \nwindow.addEventListener(\"load\", detectOrient, false);\nwindow.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", detectOrient, false);\ndetectOrient();  \n\n```","slug":"让h5页面强制横屏","published":1,"updated":"2021-02-22T14:48:26.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklgpoicl000djxwhq0x5db66","content":"<blockquote>\n<p>转载至：<a href=\"https://blog.csdn.net/qq_36457584/article/details/80967278\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_36457584/article/details/80967278</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//注意设置*&#123;padding:0;margin:0;&#125; 不然有滚动条</span><br><span class=\"line\">/**</span><br><span class=\"line\">    * H5强制横屏</span><br><span class=\"line\">    * @param &#123;Object&#125;</span><br><span class=\"line\">    */   </span><br><span class=\"line\">var wrapper = document.getElementById(&quot;root&quot;);      </span><br><span class=\"line\">var mark = window.orientation == 90 || window.orientation == -90;    //初始角度</span><br><span class=\"line\">//不同角度宽高需要互换</span><br><span class=\"line\">var width = document.documentElement[mark ? &apos;clientHeight&apos; : &apos;clientWidth&apos;]; </span><br><span class=\"line\">var height = document.documentElement[mark ? &apos;clientWidth&apos; : &apos;clientHeight&apos;];                         </span><br><span class=\"line\">var detectOrient = function() &#123;</span><br><span class=\"line\">    var style = &quot;&quot;;                            </span><br><span class=\"line\">    if (window.orientation == 90 || window.orientation == -90) &#123; //横屏                             </span><br><span class=\"line\">        style += &quot;width:100%;&quot;; </span><br><span class=\"line\">        style += &quot;height:100%;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(0); transform: rotate(0);&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: 0 0;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: 0 0;&quot;;</span><br><span class=\"line\">    &#125; else if(window.orientation == 180 || window.orientation == 0)&#123; //竖屏                    </span><br><span class=\"line\">        style += &quot;width:&quot; + height + &quot;px;&quot;;// 注意旋转后的宽高切换</span><br><span class=\"line\">        style += &quot;height:&quot;+  width + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(90deg); transform: rotate(90deg);&quot;;</span><br><span class=\"line\">        // 注意旋转中点的处理</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    style += &quot;visibility: initial;&quot;;</span><br><span class=\"line\">    wrapper.style.cssText = style;</span><br><span class=\"line\">    $(&quot;#progress&quot;).addClass(&quot;animate-progress&quot;);</span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&quot;load&quot;, detectOrient, false);</span><br><span class=\"line\">window.addEventListener(&quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;, detectOrient, false);</span><br><span class=\"line\">detectOrient();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>转载至：<a href=\"https://blog.csdn.net/qq_36457584/article/details/80967278\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_36457584/article/details/80967278</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//注意设置*&#123;padding:0;margin:0;&#125; 不然有滚动条</span><br><span class=\"line\">/**</span><br><span class=\"line\">    * H5强制横屏</span><br><span class=\"line\">    * @param &#123;Object&#125;</span><br><span class=\"line\">    */   </span><br><span class=\"line\">var wrapper = document.getElementById(&quot;root&quot;);      </span><br><span class=\"line\">var mark = window.orientation == 90 || window.orientation == -90;    //初始角度</span><br><span class=\"line\">//不同角度宽高需要互换</span><br><span class=\"line\">var width = document.documentElement[mark ? &apos;clientHeight&apos; : &apos;clientWidth&apos;]; </span><br><span class=\"line\">var height = document.documentElement[mark ? &apos;clientWidth&apos; : &apos;clientHeight&apos;];                         </span><br><span class=\"line\">var detectOrient = function() &#123;</span><br><span class=\"line\">    var style = &quot;&quot;;                            </span><br><span class=\"line\">    if (window.orientation == 90 || window.orientation == -90) &#123; //横屏                             </span><br><span class=\"line\">        style += &quot;width:100%;&quot;; </span><br><span class=\"line\">        style += &quot;height:100%;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(0); transform: rotate(0);&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: 0 0;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: 0 0;&quot;;</span><br><span class=\"line\">    &#125; else if(window.orientation == 180 || window.orientation == 0)&#123; //竖屏                    </span><br><span class=\"line\">        style += &quot;width:&quot; + height + &quot;px;&quot;;// 注意旋转后的宽高切换</span><br><span class=\"line\">        style += &quot;height:&quot;+  width + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(90deg); transform: rotate(90deg);&quot;;</span><br><span class=\"line\">        // 注意旋转中点的处理</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    style += &quot;visibility: initial;&quot;;</span><br><span class=\"line\">    wrapper.style.cssText = style;</span><br><span class=\"line\">    $(&quot;#progress&quot;).addClass(&quot;animate-progress&quot;);</span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&quot;load&quot;, detectOrient, false);</span><br><span class=\"line\">window.addEventListener(&quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;, detectOrient, false);</span><br><span class=\"line\">detectOrient();</span><br></pre></td></tr></table></figure>"},{"title":"遇到问题最后解决的文章收藏","date":"2021-01-10T11:42:51.000Z","_content":"\n\n> [使用egg框架写项目时，前后端分离生成 token问题](https://blog.csdn.net/weixin_43704471/article/details/91633142)","source":"_posts/遇到问题最后解决的文章收藏.md","raw":"---\ntitle: 遇到问题最后解决的文章收藏\ndate: 2021-01-10 19:42:51\ntags: [心得,文章]\ncategories: 记录\n---\n\n\n> [使用egg框架写项目时，前后端分离生成 token问题](https://blog.csdn.net/weixin_43704471/article/details/91633142)","slug":"遇到问题最后解决的文章收藏","published":1,"updated":"2021-02-22T14:48:26.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklgpoico000hjxwhzqyuvhds","content":"<blockquote>\n<p><a href=\"https://blog.csdn.net/weixin_43704471/article/details/91633142\" target=\"_blank\" rel=\"noopener\">使用egg框架写项目时，前后端分离生成 token问题</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://blog.csdn.net/weixin_43704471/article/details/91633142\" target=\"_blank\" rel=\"noopener\">使用egg框架写项目时，前后端分离生成 token问题</a></p>\n</blockquote>\n"},{"title":"部署Yapi遇到的问题","date":"2020-11-30T16:00:00.000Z","_content":"\n\n> 在使用命令行的方式部署，到了这一步 npm run install-server 或者 node server/app.js 这个命令时报了一个MongoDB的错误\n```\nerror: MongoNetworkError: Authentication failed., mongodb Authenticatio\n```\n最后只需要把vendors文件夹同级的config.json里面的 \"user\" 和 \"pass\" 清空就好了（文件初始是带有默认值的） \n![image](/assets/yapi-img.png)","source":"_posts/部署Yapi遇到的问题.md","raw":"---\ntitle: 部署Yapi遇到的问题\ndate: 2020-12-01\ntags: [心得,文章]\ncategories: 记录\n---\n\n\n> 在使用命令行的方式部署，到了这一步 npm run install-server 或者 node server/app.js 这个命令时报了一个MongoDB的错误\n```\nerror: MongoNetworkError: Authentication failed., mongodb Authenticatio\n```\n最后只需要把vendors文件夹同级的config.json里面的 \"user\" 和 \"pass\" 清空就好了（文件初始是带有默认值的） \n![image](/assets/yapi-img.png)","slug":"部署Yapi遇到的问题","published":1,"updated":"2021-02-22T14:48:26.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklgpoicp000kjxwh37f8kw15","content":"<blockquote>\n<p>在使用命令行的方式部署，到了这一步 npm run install-server 或者 node server/app.js 这个命令时报了一个MongoDB的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">error: MongoNetworkError: Authentication failed., mongodb Authenticatio</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>最后只需要把vendors文件夹同级的config.json里面的 “user” 和 “pass” 清空就好了（文件初始是带有默认值的）<br><img src=\"/assets/yapi-img.png\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在使用命令行的方式部署，到了这一步 npm run install-server 或者 node server/app.js 这个命令时报了一个MongoDB的错误<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">error: MongoNetworkError: Authentication failed., mongodb Authenticatio</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>最后只需要把vendors文件夹同级的config.json里面的 “user” 和 “pass” 清空就好了（文件初始是带有默认值的）<br><img src=\"/assets/yapi-img.png\" alt=\"image\"></p>\n"},{"title":"问题整理","date":"2020-07-13T08:00:14.000Z","copyright":false,"_content":"\n### 介绍一下js的数据类型有哪些,值是如何存储的\n```\n一共有8种数据类型，7种基本数据类型\nString \nNumber \nBoolean \nNull \nUndefined \nSymbol（es6 新增类型，表示第一无二的值） \nBigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）\nObject（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）\n\n原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n\n引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n\n```\n### && 、 ||和!! 运算符分别能做什么\n```\n&& 并且符，使用时两边的值结果都必须为true才返回true\n|| 或者符，两边的值结果有一个为true最终判断结果就位true\n!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）\n\n```\n\n### JS的数据类型的转换\n```\n在 JS 中类型转换只有三种情况，分别是：\n\n- 转换为布尔值（调用Boolean()方法）\n- 转换为数字（调用Number()、parseInt()和parseFloat()方法）\n- 转换为字符串（调用.toString()或者String()方法）\n\nnull和underfined没有.toString方法\n\n```\n![image](https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()   \n>（1）typeof\n```\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object\n\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof\n```\n>（2）instanceof \n```\n//重点\ninstanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断\ninstanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。\n其意思就是判断对象是否是某一数据类型（如Array）的实例\n\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true    \n// console.log(undefined instanceof Undefined);      //报错\n// console.log(null instanceof Null);                //报错\n复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。\n我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，'str'不是实例，所以判断值为false。\n```\n>（3）constructor\n```\nconsole.log((2).constructor === Number); // true\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() {}).constructor === Function); // true\nconsole.log(({}).constructor === Object); // true\n\n这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了\n\nfunction Fn(){};\n \nFn.prototype=new Array();\n \nvar f=new Fn();\n \nconsole.log(f.constructor===Fn);    // false\nconsole.log(f.constructor===Array); // true\n```\n>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法\n```\nvar a = Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call('str'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n```\n### 介绍 JS 有哪些内置对象？\n```\n全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在\n全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n\n标准内置对象的分类\n\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。\n\n例如 Infinity、NaN、undefined、null 字面量\n\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n\n例如 eval()、parseFloat()、parseInt() 等\n\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。\n\n例如 Object、Function、Boolean、Symbol、Error 等\n\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。\n\n例如 Number、Math、Date\n\n（5）字符串，用来表示和操作字符串的对象。\n\n例如 String、RegExp\n\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。\n\n例如 Map、Set、WeakMap、WeakSet\n\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。\n\n例如 SIMD 等\n\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。\n\n例如 JSON 等\n\n（10）控制抽象对象\n\n例如 Promise、Generator 等\n\n（11）反射\n\n例如 Reflect、Proxy\n\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。\n\n例如 Intl、Intl.Collator 等\n\n（13）WebAssembly\n\n（14）其他\n\n例如 arguments\n```\n\n### undefined 与 undeclared 的区别？\n```\n已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。\n对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ\neof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 \"undefined\"。\n\n```\n\n### null 和 undefined 的区别？\n```\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，\nnull 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null\n主要用于赋值给一些可能会返回对象的变量，作为初始化。\n/*\n    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，\n    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。\n    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\n*/\nundefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它\n会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等\n号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n\n```\n\n### {}和[]的valueOf和toString的结果是什么？\n```\n{} 的 valueOf 结果为 {} ，toString 的结果为 \"[object Object]\"\n\n[] 的 valueOf 结果为 [] ，toString 的结果为 \"\"\n```\n\n### Javascript 的作用域和作用域链？\n```\n【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。\n【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。\n\n\n```\n### javascript 创建对象的几种方式？\n```\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n\n\n```\n\n### JavaScript 继承的几种实现方式？\n```\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。\n\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。\n\n```\n\n### 寄生式组合继承的实现？\n```\nPerson\nStudent\n\nfunction Person(name){\n    this.name = name;\n}\n\nPerson.prototype.sayName = function(){\n    console.log(123);\n}\n\nfunction Student(name, grade){\n    Person.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\nStudent.prototype.sayMyGrade = function() {\n  console.log(\"My grade is \" + this.grade + \".\");\n  \n}\n\n```\n\n### 谈谈你对this、call、apply和bind的理解\n```\n总结:\n1. 在浏览器里，在全局范围内this 指向window对象；\n2. 在函数中，this永远指向最后调用他的那个对象；\n3. 构造函数中，this指向new出来的那个新的对象；\n4. call、apply、bind中的this被强绑定在指定的那个对象上；\n5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；\n6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。\n\n区别:\n- call/apply改变了函数的this上下文后马上执行该函数\n- bind则是返回改变了上下文后的函数,不执行该函数\n```\n\n\n\n### JavaScript 原型，原型链？ 有什么特点？\n```\nprototype就是JS的原型，里面可以定义属性和方法\n当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。\n原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。\n\n```\n\n### js 获取原型的方法？\n```\np.proto\np.constructor.prototype\nObject.getPrototypeOf(p)\n```\n\n### 什么是闭包，为什么要用它？\n```\n闭包是指有权访问另一个函数作用域内变量的函数\n创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。\n\n闭包有两个常用的用途:\n- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\nfunction a(){\n    var n = 0;\n    function add(){\n       n++;\n       console.log(n);\n    }\n    return add;\n}\nvar a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；\na1();    //1\na1();    //2  第二次调用n变量还在内存中\n\n其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。\n\n```\n\n### 什么是 DOM 和 BOM？\n```\nDOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。\n\nBOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM\n的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）\n对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati\non 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对\n象的子对象。\n\n```\n\n### 三种事件模型是什么？\n```\nDOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。\nIE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\nDOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n```\n\n### 事件委托是什么？\n```\n事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到\n目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。\n使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。\n\n```\n\n### 什么是事件传播?\n```\n当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。\n事件传播有三个阶段：\n1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。\n2. 目标阶段–事件已达到目标元素。\n3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。\n\n\n```\n\n### 什么是事件捕获？\n```\n当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----> document----> html----> body ---->目标元素\n\nhtml:\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\njs:\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\n\n\n\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。\n\n\n```\n\n### 什么是事件冒泡？\n```\n事件冒泡刚好与事件捕获相反，当前元素---->body ----> html---->document ---->window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。\n假设有如下的 HTML 结构：\n\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\n对应的JS代码：\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。\n\n\n```\n\n### DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\n（1）创建新节点\n```\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n```\n（2）添加、移除、替换、插入\n```\nappendChild(node)\nremoveChild(node)\nreplaceChild(new,old)\ninsertBefore(new,old)\n```\n（3）查找\n```\ngetElementById();\ngetElementsByName();\ngetElementsByTagName();\ngetElementsByClassName();\nquerySelector();\nquerySelectorAll();\n```\n（4）属性操作\n```\ngetAttribute(key);\nsetAttribute(key, value);\nhasAttribute(key);\nremoveAttribute(key);\n```\n\n###  js数组和对象有哪些原生方法,列举一下\n![image](https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n![image](https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n### 常用的正则表达式\n\n### Ajax 是什么? 如何创建一个 Ajax？\n我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。\n创建步骤：\n![image](https://user-gold-cdn.xitu.io/2020/6/2/17274125a4cf4d61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n```\n//1：创建Ajax对象\nvar xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');    //兼容IE6及以下版本\n//2：配置 Ajax请求地址\nxhr.open('get','index.xml',true);\n//3：发送请求\nxhr.send(null); //严谨写法\n//4:监听请求，接受响应\nxhr.onreadysatechange = function(){\n    if(xhr.readySates == 4 && xhr.status == 200 || xhr.status == 304){\n        console.log(xhr.responsetXML);\n    }\n}\n```\npromise封装实现\n```\n// promise 封装实现：\n\nfunction getJSON(url) {\n  // 创建一个 promise 对象\n  let promise = new Promise(function(resolve, reject) {\n    let xhr = new XMLHttpRequest();\n\n    // 新建一个 http 请求\n    xhr.open(\"GET\", url, true);\n\n    // 设置状态的监听函数\n    xhr.onreadystatechange = function() {\n      if (this.readyState !== 4) return;\n\n      // 当请求成功或失败时，改变 promise 的状态\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n\n    // 设置错误监听函数\n    xhr.onerror = function() {\n      reject(new Error(this.statusText));\n    };\n\n    // 设置响应的数据类型\n    xhr.responseType = \"json\";\n\n    // 设置请求头信息\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n\n    // 发送 http 请求\n    xhr.send(null);\n  });\n\n  return promise;\n}\n\n```\n\n### js 延迟加载的方式有哪些？\n```\njs 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。\n我了解到的几种方式是：\n\n将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。\n给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。\n给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。\n动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。\n\n```\n\n### 谈谈你对模块化开发的理解？\n```\n我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念\n，但随着程序越来越复杂，代码的模块化开发变得越来越重要。\n由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污\n染，并且模块间没有联系。\n后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所\n有的所有的模块成员，外部代码可以修改内部属性的值。\n现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。\n```\n\n###  js 的几种模块规范？\n```\njs 中现在比较成熟的有四种模块加载方案：\n\n第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。\n第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。\n第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。\n第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。\n```\n\n### AMD和CMD 规范的区别？\n它们之间的主要区别有两个方面。\n\n1. 第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。\n2. 第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于\n    模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD\n    在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句\n    的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。\n\n```\n// CMD\ndefine(function(require, exports, module) {\n  var a = require(\"./a\");\n  a.doSomething();\n  // 此处略去 100 行\n  var b = require(\"./b\"); // 依赖可以就近书写\n  b.doSomething();\n  // ...\n});\n\n// AMD 默认推荐\ndefine([\"./a\", \"./b\"], function(a, b) {\n  // 依赖必须一开始就写好\n  a.doSomething();\n  // 此处略去 100 行\n  b.doSomething();\n  // ...\n});\n\n```\n\n### ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\n- 1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。\n- 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n### requireJS的核心原理是什么？ \nrequire.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。\n\n### 谈谈JS的运行机制\n1. js单线程\nJavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。\n>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n\n2. js事件循环\njs代码执行过程中会有很多任务，这些任务总的分成两类：\n- 同步任务\n- 异步任务\n当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：\n![image](https://user-gold-cdn.xitu.io/2020/6/2/172744a7fa2853c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n回答：\n1. 首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。\n2. 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务\n3. 当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。\n4. 任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。\n5. 当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。\n\n### arguments 的对象是什么？\narguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。\n我们可以使用Array.prototype.slice将arguments对象转换成一个数组。\n```\nfunction one() {\n  return Array.prototype.slice.call(arguments);\n}\n```\n注意:箭头函数中没有arguments对象。\n```\nfunction one() {\n  return arguments;\n}\nconst two = function () {\n  return arguments;\n}\nconst three = function three() {\n  return arguments;\n}\n\nconst four = () => arguments;\n\nfour(); // Throws an error  - arguments is not defined\n\n```\n\n### 为什么在调用这个函数时，代码中的b会变成一个全局变量?\n```\nfunction myFunc() {\n  let a = b = 0;\n}\n\nmyFunc();\n```\n原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：\n```\nfunction myFunc() {\n  let a = (b = 0);\n}\n\nmyFunc();\n```\n首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。\n\n我们可以通过在赋值之前先声明变量来解决这个问题。\n```\nfunction myFunc() {\n  let a,b;\n  a = b = 0;\n}\nmyFunc();\n```\n\n### 简单介绍一下V8引擎的垃圾回收机制\n```\nv8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。\n\n新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。\n\n新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：\n\n（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。\n\n（2）如果对象不存活，则释放对象的空间。\n\n（3）最后将 From 空间和 To 空间角色进行交换。\n\n新生代对象晋升到老生代有两个条件：\n\n（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。\n\n（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。\n\n老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。\n\n由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。\n\n```\n\n### 哪些操作会造成内存泄漏？ \n- 1.意外的全局变量\n- 2.被遗忘的计时器或回调函数\n- 3.脱离 DOM 的引用\n- 4.闭包\n\n- 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n- 第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n- 第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\n- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。\n\n### ECMAScript 是什么？\n```\nECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。\nECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件\n只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。\njavaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）\nECMAScript说什么JavaScript就得做什么！\nJavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！\n——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，\n那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。\n```\n### ECMAScript 2015（ES6）有哪些新特性？\n- 块作用域\n- 类\n- 箭头函数\n- 模板字符串\n- 加强的对象字面\n- 对象解构\n- Promise\n- 模块\n- Symbol\n- 代理（proxy）Set\n- 函数默认参数\n- rest 和展开\n\n### var,let和const的区别是什么？\nvar声明的变量会挂载在window上，而let和const声明的变量不会：\n```\nvar a = 100;\nconsole.log(a,window.a);    // 100 100\n\nlet b = 10;\nconsole.log(b,window.b);    // 10 undefined\n\nconst c = 1;\nconsole.log(c,window.c);    // 1 undefined\n```\nvar声明变量存在变量提升，let和const不存在变量提升:\n```\nconsole.log(a); // undefined  ===>  a已声明还没赋值，默认得到undefined值\nvar a = 100;\n\nconsole.log(b); // 报错：b is not defined  ===> 找不到b这个变量\nlet b = 10;\n\nconsole.log(c); // 报错：c is not defined  ===> 找不到c这个变量\nconst c = 10;\n```\nlet和const声明形成块作用域\n```\n\nif(1){\n  var a = 100;\n  let b = 10;\n}\n\nconsole.log(a); // 100\nconsole.log(b)  // 报错：b is not defined  ===> 找不到b这个变量\n\n-------------------------------------------------------------\n\nif(1){\n  var a = 100;\n  const c = 1;\n}\nconsole.log(a); // 100\nconsole.log(c)  // 报错：c is not defined  ===> 找不到c这个变量\n```\n同一作用域下let和const不能声明同名变量，而var可以\n```\nvar a = 100;\nconsole.log(a); // 100\n\nvar a = 10;\nconsole.log(a); // 10\n-------------------------------------\nlet a = 100;\nlet a = 10;\n\n//  控制台报错：Identifier 'a' has already been declared  ===> 标识符a已经被声明了。\n\n```\n暂存死区\n```\nvar a = 100;\n\nif(1){\n    a = 10;\n    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，\n    // 而这时，还未到声明时候，所以控制台Error:a is not defined\n    let a = 1;\n}\n```\nconst\n```\n\n/*\n* &emsp;&emsp;1、一旦声明必须赋值,不能使用null占位。\n*\n* &emsp;&emsp;2、声明后不能再修改\n*\n* &emsp;&emsp;3、如果声明的是复合类型数据，可以修改其属性\n*\n* */\n\nconst a = 100; \n\nconst list = [];\nlist[0] = 10;\nconsole.log(list);&emsp;&emsp;// [10]\n\nconst obj = {a:100};\nobj.name = 'apple';\nobj.a = 10000;\nconsole.log(obj);&emsp;&emsp;// {a:10000,name:'apple'}\n\n```\n\n### 什么是箭头函数？\n箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n```\n//ES5 Version\nvar getCurrentDate = function (){\n  return new Date();\n}\n\n//ES6 Version\nconst getCurrentDate = () => new Date();\n```\n在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。\n```\n//ES5 Version\nfunction greet(name) {\n  return 'Hello ' + name + '!';\n}\n\n//ES6 Version\nconst greet = (name) => `Hello ${name}`;\nconst greet2 = name => `Hello ${name}`;\n\n```\n我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。\n```\nconst getArgs = () => arguments\n\nconst getArgs2 = (...rest) => rest\n```\n箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。\n```\nconst data = {\n  result: 0,\n  nums: [1, 2, 3, 4, 5],\n  computeResult() {\n    // 这里的“this”指的是“data”对象\n    const addAll = () => {\n      return this.nums.reduce((total, cur) => total + cur, 0)\n    };\n    this.result = addAll();\n  }\n};\n\n```\n箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。\n\n\n### 什么是类？\n```\n类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。\n```\n\n### 什么是模板字符串？\n模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。\n```\n//ES5 Version\nvar greet = 'Hi I\\'m Mark';\n\n//ES6 Version\nlet greet = `Hi I'm Mark`;\n\n```\n在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：\n```\n//ES5 Version\nvar lastWords = '\\n'\n  + '   I  \\n'\n  + '   Am  \\n'\n  + 'Iron Man \\n';\n\n\n//ES6 Version\nlet lastWords = `\n    I\n    Am\n  Iron Man   \n`;\n\n```\n在ES5版本中，我们需要添加\\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。\n```\n//ES5 Version\nfunction greet(name) {\n  return 'Hello ' + name + '!';\n}\n\n\n//ES6 Version\nfunction greet(name) {\n  return `Hello ${name} !`;\n}\n\n```\n在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。\n\n### 什么是对象解构？ \n对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：\n```\nconst employee = {\n  firstName: \"Marko\",\n  lastName: \"Polo\",\n  position: \"Software Developer\",\n  yearHired: 2017\n};\n\n```\n从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。\n```\nvar firstName = employee.firstName;\nvar lastName = employee.lastName;\nvar position = employee.position;\nvar yearHired = employee.yearHired;\n\n```\n使用解构方式语法就变得简洁多了：\n```\n{ firstName, lastName, position, yearHired } = employee;\n\n```\n我们还可以为属性取别名：\n```\nlet { firstName: fName, lastName: lName, position, yearHired } = employee;\n\n```\n当然如果属性值为 undefined 时，我们还可以指定默认值，但是属性为null时指定的默认值则不生效：\n```\nlet { firstName = \"Mark\", lastName: lName, position, yearHired } = employee;\n```\n\n### 什么是Set对象，它是如何工作的？\nSet 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。\n\n我们可以使用Set构造函数创建Set实例。\n```\nconst set1 = new Set();\nconst set2 = new Set([\"a\",\"b\",\"c\",\"d\",\"d\",\"e\"]);\n\n```\n我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。\n```\nset2.add(\"f\");\nset2.add(\"g\").add(\"h\").add(\"i\").add(\"j\").add(\"k\").add(\"k\");\n// 后一个“k”不会被添加到set对象中，因为它已经存在了\n```\n我们可以使用has方法检查Set实例中是否存在特定的值。\n```\nset2.has(\"a\") // true\nset2.has(\"z\") // true\n\n```\n我们可以使用size属性获得Set实例的长度。\n```\nset2.size // returns 10\n\n```\n可以使用clear方法删除 Set 中的数据。\n```\nset2.clear();\n\n```\n我们可以使用Set对象来删除数组中重复的元素。\n```\nconst numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];\nconst uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]\n \n```\n另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。\n- Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n- WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。\n\n### 什么是Proxy？\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。\n\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\n### 写一个通用的事件侦听器函数？\n```\nconst EventUtils = {\n  // 视能力分别使用dom0||dom2||IE方式 来绑定事件\n  // 添加事件\n  addEvent: function(element, type, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(type, handler, false);\n    } else if (element.attachEvent) {\n      element.attachEvent(\"on\" + type, handler);\n    } else {\n      element[\"on\" + type] = handler;\n    }\n  },\n\n  // 移除事件\n  removeEvent: function(element, type, handler) {\n    if (element.removeEventListener) {\n      element.removeEventListener(type, handler, false);\n    } else if (element.detachEvent) {\n      element.detachEvent(\"on\" + type, handler);\n    } else {\n      element[\"on\" + type] = null;\n    }\n  },\n\n  // 获取事件目标\n  getTarget: function(event) {\n    return event.target || event.srcElement;\n  },\n\n  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event\n  getEvent: function(event) {\n    return event || window.event;\n  },\n\n  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）\n  stopPropagation: function(event) {\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      event.cancelBubble = true;\n    }\n  },\n\n  // 取消事件的默认行为\n  preventDefault: function(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n  }\n};\n\n```\n\n### 什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\n```\n函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。\n函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。\n函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。\n\n```\n\n### 什么是高阶函数？\n高阶函数只是将函数作为参数或返回值的函数。\n```\nfunction higherOrderFunction(param,callback){\n    return callback(param);\n}\n\n```\n\n### 为什么函数被称为一等公民？\n```\n在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:\n\n赋值（var func = function(){}）、\n传参(function func(x,callback){callback();})、\n返回(function(){return function(){}})，\n\n这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。\n\n```\n\n### 手动实现Array.prototype.map 方法\n```\nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\nfunction map(arr, mapCallback) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') { \n    return [];\n  } else {\n    let result = [];\n    // 每次调用此函数时，我们都会创建一个 result 数组\n    // 因为我们不想改变原始数组。\n    for (let i = 0, len = arr.length; i < len; i++) {\n      result.push(mapCallback(arr[i], i, arr)); \n      // 将 mapCallback 返回的结果 push 到 result 数组中\n    }\n    return result;\n  }\n}\n\n```\n\n### 手动实现Array.prototype.filter方法\n```\nfilter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。\nfunction filter(arr, filterCallback) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') \n  {\n    return [];\n  } else {\n    let result = [];\n     // 每次调用此函数时，我们都会创建一个 result 数组\n     // 因为我们不想改变原始数组。\n    for (let i = 0, len = arr.length; i < len; i++) {\n      // 检查 filterCallback 的返回值是否是真值\n      if (filterCallback(arr[i], i, arr)) { \n      // 如果条件为真，则将数组元素 push 到 result 中\n        result.push(arr[i]);\n      }\n    }\n    return result; // return the result array\n  }\n}\n\n```\n\n### 手动实现Array.prototype.reduce方法\n```\nreduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\nfunction reduce(arr, reduceCallback, initialValue) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function') \n  {\n    return [];\n  } else {\n    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue\n    let hasInitialValue = initialValue !== undefined;\n    let value = hasInitialValue ? initialValue : arr[0];\n   、\n\n    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始\n    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i < len; i++) {\n      value = reduceCallback(value, arr[i], i, arr); \n    }\n    return value;\n  }\n}\n```\n\n### js的深浅拷贝\n>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。\n- 浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\n- 深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。\n>浅拷贝的实现方式：\n- Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n- Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。\n- 拓展运算符...：\n```\nlet a = {\n    name: \"Jake\",\n    flag: {\n        title: \"better day by day\",\n        time: \"2020-05-31\"\n    }\n}\nlet b = {...a};\n\n```\n>深拷贝的实现方式：\n- 乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）\n- 基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）\n```\nfunction cloneDeep(target,map = new WeakMap()) {\n  if(typeOf taret ==='object'){\n     let cloneTarget = Array.isArray(target) ? [] : {};\n      \n     if(map.get(target)) {\n        return target;\n    }\n     map.set(target, cloneTarget);\n     for(const key in target){\n        cloneTarget[key] = cloneDeep(target[key], map);\n     }\n     return cloneTarget\n  }else{\n       return target\n  }\n \n}\n```\n- 终极版：\n```\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst objectTag = '[object Object]';\nconst argsTag = '[object Arguments]';\n\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst numberTag = '[object Number]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst errorTag = '[object Error]';\nconst regexpTag = '[object RegExp]';\nconst funcTag = '[object Function]';\n\nconst deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];\n\n\nfunction forEach(array, iteratee) {\n    let index = -1;\n    const length = array.length;\n    while (++index < length) {\n        iteratee(array[index], index);\n    }\n    return array;\n}\n\nfunction isObject(target) {\n    const type = typeof target;\n    return target !== null && (type === 'object' || type === 'function');\n}\n\nfunction getType(target) {\n    return Object.prototype.toString.call(target);\n}\n\nfunction getInit(target) {\n    const Ctor = target.constructor;\n    return new Ctor();\n}\n\nfunction cloneSymbol(targe) {\n    return Object(Symbol.prototype.valueOf.call(targe));\n}\n\nfunction cloneReg(targe) {\n    const reFlags = /\\w*$/;\n    const result = new targe.constructor(targe.source, reFlags.exec(targe));\n    result.lastIndex = targe.lastIndex;\n    return result;\n}\n\nfunction cloneFunction(func) {\n    const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n    const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n    const funcString = func.toString();\n    if (func.prototype) {\n        const param = paramReg.exec(funcString);\n        const body = bodyReg.exec(funcString);\n        if (body) {\n            if (param) {\n                const paramArr = param[0].split(',');\n                return new Function(...paramArr, body[0]);\n            } else {\n                return new Function(body[0]);\n            }\n        } else {\n            return null;\n        }\n    } else {\n        return eval(funcString);\n    }\n}\n\nfunction cloneOtherType(targe, type) {\n    const Ctor = targe.constructor;\n    switch (type) {\n        case boolTag:\n        case numberTag:\n        case stringTag:\n        case errorTag:\n        case dateTag:\n            return new Ctor(targe);\n        case regexpTag:\n            return cloneReg(targe);\n        case symbolTag:\n            return cloneSymbol(targe);\n        case funcTag:\n            return cloneFunction(targe);\n        default:\n            return null;\n    }\n}\n\nfunction clone(target, map = new WeakMap()) {\n\n    // 克隆原始类型\n    if (!isObject(target)) {\n        return target;\n    }\n\n    // 初始化\n    const type = getType(target);\n    let cloneTarget;\n    if (deepTag.includes(type)) {\n        cloneTarget = getInit(target, type);\n    } else {\n        return cloneOtherType(target, type);\n    }\n\n    // 防止循环引用\n    if (map.get(target)) {\n        return map.get(target);\n    }\n    map.set(target, cloneTarget);\n\n    // 克隆set\n    if (type === setTag) {\n        target.forEach(value => {\n            cloneTarget.add(clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆map\n    if (type === mapTag) {\n        target.forEach((value, key) => {\n            cloneTarget.set(key, clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆对象和数组\n    const keys = type === arrayTag ? undefined : Object.keys(target);\n    forEach(keys || target, (value, key) => {\n        if (keys) {\n            key = value;\n        }\n        cloneTarget[key] = clone(target[key], map);\n    });\n\n    return cloneTarget;\n}\n\nmodule.exports = {\n    clone\n};\n\n```\n\n### 手写call、apply及bind函数\ncall 函数的实现步骤：\n- 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 3.处理传入的参数，截取第一个参数后的所有参数。\n- 4.将函数作为上下文对象的一个属性。\n- 5.使用上下文对象来调用这个方法，并保存返回结果。\n- 6.删除刚才新增的属性。\n- 7.返回结果。\n```\n// call函数实现\nFunction.prototype.myCall = function(context) {\n  // 判断调用对象\n  if (typeof this !== \"function\") {\n    console.error(\"type error\");\n  }\n\n  // 获取参数\n  let args = [...arguments].slice(1),\n    result = null;\n\n  // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window;\n\n  // 将调用函数设为对象的方法\n  context.fn = this;\n\n  // 调用函数\n  result = context.fn(...args);\n\n  // 将属性删除\n  delete context.fn;\n\n  return result;\n};\n```\napply 函数的实现步骤：\n- 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 将函数作为上下文对象的一个属性。\n- 判断参数值是否传入\n- 使用上下文对象来调用这个方法，并保存返回结果。\n- 删除刚才新增的属性\n- 返回结果\n```\n\n// apply 函数实现\n\nFunction.prototype.myApply = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n\n  let result = null;\n\n  // 判断 context 是否存在，如果未传入则为 window\n  context = context || window;\n\n  // 将函数设为对象的方法\n  context.fn = this;\n\n  // 调用方法\n  if (arguments[1]) { \n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n\n  // 将属性删除\n  delete context.fn;\n\n  return result;\n};\n```\nbind 函数的实现步骤：\n- 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 2.保存当前函数的引用，获取其余传入参数值。\n- 3.创建一个函数返回\n- 4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n```\n// bind 函数实现\nFunction.prototype.myBind = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n\n  // 获取参数\n  var args = [...arguments].slice(1),\n    fn = this;\n\n  return function Fn() {\n    // 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      args.concat(...arguments)\n    );\n  };\n};\n```\n\n### 函数柯里化的实现\n```\n// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n\nfunction curry(fn, args) {\n  // 获取函数需要的参数长度\n  let length = fn.length;\n\n  args = args || [];\n\n  return function() {\n    let subArgs = args.slice(0);\n\n    // 拼接得到现有的所有参数\n    for (let i = 0; i < arguments.length; i++) {\n      subArgs.push(arguments[i]);\n    }\n\n    // 判断参数的长度是否已经满足函数所需参数的长度\n    if (subArgs.length >= length) {\n      // 如果满足，执行函数\n      return fn.apply(this, subArgs);\n    } else {\n      // 如果不满足，递归返回科里化的函数，等待参数的传入\n      return curry.call(this, fn, subArgs);\n    }\n  };\n}\n\n// es6 实现\nfunction curry(fn, ...args) {\n  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);\n}\n\n```\n\n### js模拟new操作符的实现\nnew 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作：\n1. 创建一个空的简单JavaScript对象（即{}）；\n2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；\n3. 将步骤1新创建的对象作为this的上下文 ；\n4. 如果该函数没有返回对象，则返回this。\n接下来我们看实现：\n```\nfunction Dog(name, color, age) {\n  this.name = name;\n  this.color = color;\n  this.age = age;\n}\n\nDog.prototype={\n  getName: function() {\n    return this.name\n  }\n}\n\nvar dog = new Dog('大黄', 'yellow', 3)\n\n```\n上面的代码相信不用解释，大家都懂。我们来看最后一行带new关键字的代码，按照上述的1,2,3,4步来解析new背后的操作。\n\n第一步：创建一个简单空对象\n```\nvar obj = {}\n```\n第二步：链接该对象到另一个对象（原型链）\n```\n// 设置原型链\nobj.__proto__ = Dog.prototype\n```\n第三步：将步骤1新创建的对象作为 this 的上下文\n```\n// this指向obj对象\nDog.apply(obj, ['大黄', 'yellow', 3])\n```\n第四步：如果该函数没有返回对象，则返回this\n```\n// 因为 Dog() 没有返回值，所以返回obj\nvar dog = obj\ndog.getName() // '大黄'\n```\n需要注意的是如果 Dog() 有 return 则返回 return的值\n```\nvar rtnObj = {}\nfunction Dog(name, color, age) {\n  // ...\n  //返回一个对象\n  return rtnObj\n}\n\nvar dog = new Dog('大黄', 'yellow', 3)\nconsole.log(dog === rtnObj) // true\n```\n接下来我们将以上步骤封装成一个对象实例化方法，即模拟new的操作：\n```\nfunction objectFactory(){\n    var obj = {};\n    //取得该方法的第一个参数(并删除第一个参数)，该参数是构造函数\n    var Constructor = [].shift.apply(arguments);\n    //将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法\n    obj.__proto__ = Constructor.prototype;\n    //取得构造函数的返回值\n    var ret = Constructor.apply(obj, arguments);\n    //如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象\n    return typeof ret === \"object\" ? ret : obj;\n}\n```\n### 什么是回调函数？回调函数有什么缺点\n回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。\n在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。\n\n### Promise是什么，可以手写实现一下吗？\nPromise，翻译过来是承诺，承诺它过一段时间会给你一个结果。从编程讲Promise 是异步编程的一种解决方案。下面是Promise在MDN的相关说明：\nPromise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。\n一个 Promise有以下几种状态:\n  - pending: 初始状态，既不是成功，也不是失败状态。\n  - fulfilled: 意味着操作成功完成。\n  - rejected: 意味着操作失败。\n这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 fulfilled/rejected 后，就不能再次改变。\n可能光看概念大家不理解Promise，我们举个简单的栗子；\n假如我有个女朋友，下周一是她生日，我答应她生日给她一个惊喜，那么从现在开始这个承诺就进入等待状态，等待下周一的到来，然后状态改变。如果下周一我如约给了女朋友惊喜，那么这个承诺的状态就会由pending切换为fulfilled，表示承诺成功兑现，一旦是这个结果了，就不会再有其他结果，即状态不会在发生改变；反之如果当天我因为工作太忙加班，把这事给忘了，说好的惊喜没有兑现，状态就会由pending切换为rejected，时间不可倒流，所以状态也不能再发生变化。\n上一条我们说过Promise可以解决回调地狱的问题，没错，pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，一旦状态改变，Promise 对象的 then 方法就会被调用；否则就会触发 catch。我们将上一条回调地狱的代码改写一下：\n```\nnew Promise((resolve，reject) => {\n     setTimeout(() => {\n            console.log(1)\n            resolve()\n        },1000)\n        \n}).then((res) => {\n    setTimeout(() => {\n            console.log(2)\n        },2000)\n}).then((res) => {\n    setTimeout(() => {\n            console.log(3)\n        },3000)\n}).catch((err) => {\nconsole.log(err)\n})\n\n```\n其实Promise也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。\n手写版本\n```\nfunction myPromise(constructor){\n    let self=this;\n    self.status=\"pending\" //定义状态改变前的初始状态\n    self.value=undefined;//定义状态为resolved的时候的状态\n    self.reason=undefined;//定义状态为rejected的时候的状态\n    function resolve(value){\n        //两个===\"pending\"，保证了状态的改变是不可逆的\n       if(self.status===\"pending\"){\n          self.value=value;\n          self.status=\"resolved\";\n       }\n    }\n    function reject(reason){\n        //两个===\"pending\"，保证了状态的改变是不可逆的\n       if(self.status===\"pending\"){\n          self.reason=reason;\n          self.status=\"rejected\";\n       }\n    }\n    //捕获构造异常\n    try{\n       constructor(resolve,reject);\n    }catch(e){\n       reject(e);\n    }\n}\n// 定义链式调用的then方法\nmyPromise.prototype.then=function(onFullfilled,onRejected){\n   let self=this;\n   switch(self.status){\n      case \"resolved\":\n        onFullfilled(self.value);\n        break;\n      case \"rejected\":\n        onRejected(self.reason);\n        break;\n      default:       \n   }\n}\n```\n### Iterator是什么，有什么作用？\nIterator是理解第61条的先决知识\nIterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n```\nconst obj = {\n    [Symbol.iterator]:function(){}\n}\n```\n[Symbol.iterator] 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。\n迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据\n每一次的 next 都会返回一个对象，该对象有两个属性\n- value 代表想要获取的数据\n- done 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束\nIterator 的作用有三个：\n1. 为各种数据结构，提供一个统一的、简便的访问接口；\n2. 使得数据结构的成员能够按某种次序排列；\n3. ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。\n遍历过程：\n1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n3. 不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n```\nlet arr = [{num:1},2,3]\nlet it = arr[Symbol.iterator]() // 获取数组中的迭代器\nconsole.log(it.next())  // { value: Object { num: 1 }, done: false }\nconsole.log(it.next())  // { value: 2, done: false }\nconsole.log(it.next())  // { value: 3, done: false }\nconsole.log(it.next())  // { value: undefined, done: true }\n```\n\n### Generator函数是什么，有什么作用？\n\n### 什么是 async/await及其如何工作,有什么优缺点？\n\n### instanceof的原理是什么，如何实现\n\n### js的节流与防抖\n\n### 什么是设计模式？\n\n### 9种前端常见的设计模式\n\n\n\n","source":"_posts/问题整理.md","raw":"---\ntitle: 问题整理\ndate: 2020-07-13 16:00:14\ntags: 文章\ncategories: 技术\ncopyright: false\n---\n\n### 介绍一下js的数据类型有哪些,值是如何存储的\n```\n一共有8种数据类型，7种基本数据类型\nString \nNumber \nBoolean \nNull \nUndefined \nSymbol（es6 新增类型，表示第一无二的值） \nBigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）\nObject（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）\n\n原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n\n引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n\n```\n### && 、 ||和!! 运算符分别能做什么\n```\n&& 并且符，使用时两边的值结果都必须为true才返回true\n|| 或者符，两边的值结果有一个为true最终判断结果就位true\n!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）\n\n```\n\n### JS的数据类型的转换\n```\n在 JS 中类型转换只有三种情况，分别是：\n\n- 转换为布尔值（调用Boolean()方法）\n- 转换为数字（调用Number()、parseInt()和parseFloat()方法）\n- 转换为字符串（调用.toString()或者String()方法）\n\nnull和underfined没有.toString方法\n\n```\n![image](https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()   \n>（1）typeof\n```\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object\n\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof\n```\n>（2）instanceof \n```\n//重点\ninstanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断\ninstanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。\n其意思就是判断对象是否是某一数据类型（如Array）的实例\n\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true    \n// console.log(undefined instanceof Undefined);      //报错\n// console.log(null instanceof Null);                //报错\n复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。\n我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，'str'不是实例，所以判断值为false。\n```\n>（3）constructor\n```\nconsole.log((2).constructor === Number); // true\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() {}).constructor === Function); // true\nconsole.log(({}).constructor === Object); // true\n\n这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了\n\nfunction Fn(){};\n \nFn.prototype=new Array();\n \nvar f=new Fn();\n \nconsole.log(f.constructor===Fn);    // false\nconsole.log(f.constructor===Array); // true\n```\n>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法\n```\nvar a = Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call('str'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n```\n### 介绍 JS 有哪些内置对象？\n```\n全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在\n全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n\n标准内置对象的分类\n\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。\n\n例如 Infinity、NaN、undefined、null 字面量\n\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n\n例如 eval()、parseFloat()、parseInt() 等\n\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。\n\n例如 Object、Function、Boolean、Symbol、Error 等\n\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。\n\n例如 Number、Math、Date\n\n（5）字符串，用来表示和操作字符串的对象。\n\n例如 String、RegExp\n\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。\n\n例如 Map、Set、WeakMap、WeakSet\n\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。\n\n例如 SIMD 等\n\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。\n\n例如 JSON 等\n\n（10）控制抽象对象\n\n例如 Promise、Generator 等\n\n（11）反射\n\n例如 Reflect、Proxy\n\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。\n\n例如 Intl、Intl.Collator 等\n\n（13）WebAssembly\n\n（14）其他\n\n例如 arguments\n```\n\n### undefined 与 undeclared 的区别？\n```\n已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。\n对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ\neof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 \"undefined\"。\n\n```\n\n### null 和 undefined 的区别？\n```\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，\nnull 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null\n主要用于赋值给一些可能会返回对象的变量，作为初始化。\n/*\n    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，\n    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。\n    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\n*/\nundefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它\n会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等\n号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n\n```\n\n### {}和[]的valueOf和toString的结果是什么？\n```\n{} 的 valueOf 结果为 {} ，toString 的结果为 \"[object Object]\"\n\n[] 的 valueOf 结果为 [] ，toString 的结果为 \"\"\n```\n\n### Javascript 的作用域和作用域链？\n```\n【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。\n【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。\n\n\n```\n### javascript 创建对象的几种方式？\n```\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n\n\n```\n\n### JavaScript 继承的几种实现方式？\n```\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。\n\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。\n\n```\n\n### 寄生式组合继承的实现？\n```\nPerson\nStudent\n\nfunction Person(name){\n    this.name = name;\n}\n\nPerson.prototype.sayName = function(){\n    console.log(123);\n}\n\nfunction Student(name, grade){\n    Person.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\nStudent.prototype.sayMyGrade = function() {\n  console.log(\"My grade is \" + this.grade + \".\");\n  \n}\n\n```\n\n### 谈谈你对this、call、apply和bind的理解\n```\n总结:\n1. 在浏览器里，在全局范围内this 指向window对象；\n2. 在函数中，this永远指向最后调用他的那个对象；\n3. 构造函数中，this指向new出来的那个新的对象；\n4. call、apply、bind中的this被强绑定在指定的那个对象上；\n5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；\n6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。\n\n区别:\n- call/apply改变了函数的this上下文后马上执行该函数\n- bind则是返回改变了上下文后的函数,不执行该函数\n```\n\n\n\n### JavaScript 原型，原型链？ 有什么特点？\n```\nprototype就是JS的原型，里面可以定义属性和方法\n当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。\n原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。\n\n```\n\n### js 获取原型的方法？\n```\np.proto\np.constructor.prototype\nObject.getPrototypeOf(p)\n```\n\n### 什么是闭包，为什么要用它？\n```\n闭包是指有权访问另一个函数作用域内变量的函数\n创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。\n\n闭包有两个常用的用途:\n- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\nfunction a(){\n    var n = 0;\n    function add(){\n       n++;\n       console.log(n);\n    }\n    return add;\n}\nvar a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；\na1();    //1\na1();    //2  第二次调用n变量还在内存中\n\n其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。\n\n```\n\n### 什么是 DOM 和 BOM？\n```\nDOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。\n\nBOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM\n的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）\n对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati\non 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对\n象的子对象。\n\n```\n\n### 三种事件模型是什么？\n```\nDOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。\nIE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\nDOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n```\n\n### 事件委托是什么？\n```\n事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到\n目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。\n使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。\n\n```\n\n### 什么是事件传播?\n```\n当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。\n事件传播有三个阶段：\n1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。\n2. 目标阶段–事件已达到目标元素。\n3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。\n\n\n```\n\n### 什么是事件捕获？\n```\n当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----> document----> html----> body ---->目标元素\n\nhtml:\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\njs:\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\n\n\n\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。\n\n\n```\n\n### 什么是事件冒泡？\n```\n事件冒泡刚好与事件捕获相反，当前元素---->body ----> html---->document ---->window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。\n假设有如下的 HTML 结构：\n\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\n对应的JS代码：\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。\n\n\n```\n\n### DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\n（1）创建新节点\n```\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n```\n（2）添加、移除、替换、插入\n```\nappendChild(node)\nremoveChild(node)\nreplaceChild(new,old)\ninsertBefore(new,old)\n```\n（3）查找\n```\ngetElementById();\ngetElementsByName();\ngetElementsByTagName();\ngetElementsByClassName();\nquerySelector();\nquerySelectorAll();\n```\n（4）属性操作\n```\ngetAttribute(key);\nsetAttribute(key, value);\nhasAttribute(key);\nremoveAttribute(key);\n```\n\n###  js数组和对象有哪些原生方法,列举一下\n![image](https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n![image](https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n### 常用的正则表达式\n\n### Ajax 是什么? 如何创建一个 Ajax？\n我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。\n创建步骤：\n![image](https://user-gold-cdn.xitu.io/2020/6/2/17274125a4cf4d61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n```\n//1：创建Ajax对象\nvar xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');    //兼容IE6及以下版本\n//2：配置 Ajax请求地址\nxhr.open('get','index.xml',true);\n//3：发送请求\nxhr.send(null); //严谨写法\n//4:监听请求，接受响应\nxhr.onreadysatechange = function(){\n    if(xhr.readySates == 4 && xhr.status == 200 || xhr.status == 304){\n        console.log(xhr.responsetXML);\n    }\n}\n```\npromise封装实现\n```\n// promise 封装实现：\n\nfunction getJSON(url) {\n  // 创建一个 promise 对象\n  let promise = new Promise(function(resolve, reject) {\n    let xhr = new XMLHttpRequest();\n\n    // 新建一个 http 请求\n    xhr.open(\"GET\", url, true);\n\n    // 设置状态的监听函数\n    xhr.onreadystatechange = function() {\n      if (this.readyState !== 4) return;\n\n      // 当请求成功或失败时，改变 promise 的状态\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n\n    // 设置错误监听函数\n    xhr.onerror = function() {\n      reject(new Error(this.statusText));\n    };\n\n    // 设置响应的数据类型\n    xhr.responseType = \"json\";\n\n    // 设置请求头信息\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n\n    // 发送 http 请求\n    xhr.send(null);\n  });\n\n  return promise;\n}\n\n```\n\n### js 延迟加载的方式有哪些？\n```\njs 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。\n我了解到的几种方式是：\n\n将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。\n给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。\n给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。\n动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。\n\n```\n\n### 谈谈你对模块化开发的理解？\n```\n我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念\n，但随着程序越来越复杂，代码的模块化开发变得越来越重要。\n由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污\n染，并且模块间没有联系。\n后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所\n有的所有的模块成员，外部代码可以修改内部属性的值。\n现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。\n```\n\n###  js 的几种模块规范？\n```\njs 中现在比较成熟的有四种模块加载方案：\n\n第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。\n第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。\n第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。\n第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。\n```\n\n### AMD和CMD 规范的区别？\n它们之间的主要区别有两个方面。\n\n1. 第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。\n2. 第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于\n    模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD\n    在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句\n    的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。\n\n```\n// CMD\ndefine(function(require, exports, module) {\n  var a = require(\"./a\");\n  a.doSomething();\n  // 此处略去 100 行\n  var b = require(\"./b\"); // 依赖可以就近书写\n  b.doSomething();\n  // ...\n});\n\n// AMD 默认推荐\ndefine([\"./a\", \"./b\"], function(a, b) {\n  // 依赖必须一开始就写好\n  a.doSomething();\n  // 此处略去 100 行\n  b.doSomething();\n  // ...\n});\n\n```\n\n### ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\n- 1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。\n- 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n### requireJS的核心原理是什么？ \nrequire.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。\n\n### 谈谈JS的运行机制\n1. js单线程\nJavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。\n>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n\n2. js事件循环\njs代码执行过程中会有很多任务，这些任务总的分成两类：\n- 同步任务\n- 异步任务\n当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：\n![image](https://user-gold-cdn.xitu.io/2020/6/2/172744a7fa2853c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n回答：\n1. 首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。\n2. 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务\n3. 当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。\n4. 任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。\n5. 当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。\n\n### arguments 的对象是什么？\narguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。\n我们可以使用Array.prototype.slice将arguments对象转换成一个数组。\n```\nfunction one() {\n  return Array.prototype.slice.call(arguments);\n}\n```\n注意:箭头函数中没有arguments对象。\n```\nfunction one() {\n  return arguments;\n}\nconst two = function () {\n  return arguments;\n}\nconst three = function three() {\n  return arguments;\n}\n\nconst four = () => arguments;\n\nfour(); // Throws an error  - arguments is not defined\n\n```\n\n### 为什么在调用这个函数时，代码中的b会变成一个全局变量?\n```\nfunction myFunc() {\n  let a = b = 0;\n}\n\nmyFunc();\n```\n原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：\n```\nfunction myFunc() {\n  let a = (b = 0);\n}\n\nmyFunc();\n```\n首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。\n\n我们可以通过在赋值之前先声明变量来解决这个问题。\n```\nfunction myFunc() {\n  let a,b;\n  a = b = 0;\n}\nmyFunc();\n```\n\n### 简单介绍一下V8引擎的垃圾回收机制\n```\nv8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。\n\n新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。\n\n新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：\n\n（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。\n\n（2）如果对象不存活，则释放对象的空间。\n\n（3）最后将 From 空间和 To 空间角色进行交换。\n\n新生代对象晋升到老生代有两个条件：\n\n（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。\n\n（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。\n\n老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。\n\n由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。\n\n```\n\n### 哪些操作会造成内存泄漏？ \n- 1.意外的全局变量\n- 2.被遗忘的计时器或回调函数\n- 3.脱离 DOM 的引用\n- 4.闭包\n\n- 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n- 第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n- 第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\n- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。\n\n### ECMAScript 是什么？\n```\nECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。\nECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件\n只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。\njavaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）\nECMAScript说什么JavaScript就得做什么！\nJavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！\n——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，\n那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。\n```\n### ECMAScript 2015（ES6）有哪些新特性？\n- 块作用域\n- 类\n- 箭头函数\n- 模板字符串\n- 加强的对象字面\n- 对象解构\n- Promise\n- 模块\n- Symbol\n- 代理（proxy）Set\n- 函数默认参数\n- rest 和展开\n\n### var,let和const的区别是什么？\nvar声明的变量会挂载在window上，而let和const声明的变量不会：\n```\nvar a = 100;\nconsole.log(a,window.a);    // 100 100\n\nlet b = 10;\nconsole.log(b,window.b);    // 10 undefined\n\nconst c = 1;\nconsole.log(c,window.c);    // 1 undefined\n```\nvar声明变量存在变量提升，let和const不存在变量提升:\n```\nconsole.log(a); // undefined  ===>  a已声明还没赋值，默认得到undefined值\nvar a = 100;\n\nconsole.log(b); // 报错：b is not defined  ===> 找不到b这个变量\nlet b = 10;\n\nconsole.log(c); // 报错：c is not defined  ===> 找不到c这个变量\nconst c = 10;\n```\nlet和const声明形成块作用域\n```\n\nif(1){\n  var a = 100;\n  let b = 10;\n}\n\nconsole.log(a); // 100\nconsole.log(b)  // 报错：b is not defined  ===> 找不到b这个变量\n\n-------------------------------------------------------------\n\nif(1){\n  var a = 100;\n  const c = 1;\n}\nconsole.log(a); // 100\nconsole.log(c)  // 报错：c is not defined  ===> 找不到c这个变量\n```\n同一作用域下let和const不能声明同名变量，而var可以\n```\nvar a = 100;\nconsole.log(a); // 100\n\nvar a = 10;\nconsole.log(a); // 10\n-------------------------------------\nlet a = 100;\nlet a = 10;\n\n//  控制台报错：Identifier 'a' has already been declared  ===> 标识符a已经被声明了。\n\n```\n暂存死区\n```\nvar a = 100;\n\nif(1){\n    a = 10;\n    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，\n    // 而这时，还未到声明时候，所以控制台Error:a is not defined\n    let a = 1;\n}\n```\nconst\n```\n\n/*\n* &emsp;&emsp;1、一旦声明必须赋值,不能使用null占位。\n*\n* &emsp;&emsp;2、声明后不能再修改\n*\n* &emsp;&emsp;3、如果声明的是复合类型数据，可以修改其属性\n*\n* */\n\nconst a = 100; \n\nconst list = [];\nlist[0] = 10;\nconsole.log(list);&emsp;&emsp;// [10]\n\nconst obj = {a:100};\nobj.name = 'apple';\nobj.a = 10000;\nconsole.log(obj);&emsp;&emsp;// {a:10000,name:'apple'}\n\n```\n\n### 什么是箭头函数？\n箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n```\n//ES5 Version\nvar getCurrentDate = function (){\n  return new Date();\n}\n\n//ES6 Version\nconst getCurrentDate = () => new Date();\n```\n在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。\n```\n//ES5 Version\nfunction greet(name) {\n  return 'Hello ' + name + '!';\n}\n\n//ES6 Version\nconst greet = (name) => `Hello ${name}`;\nconst greet2 = name => `Hello ${name}`;\n\n```\n我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。\n```\nconst getArgs = () => arguments\n\nconst getArgs2 = (...rest) => rest\n```\n箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。\n```\nconst data = {\n  result: 0,\n  nums: [1, 2, 3, 4, 5],\n  computeResult() {\n    // 这里的“this”指的是“data”对象\n    const addAll = () => {\n      return this.nums.reduce((total, cur) => total + cur, 0)\n    };\n    this.result = addAll();\n  }\n};\n\n```\n箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。\n\n\n### 什么是类？\n```\n类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。\n```\n\n### 什么是模板字符串？\n模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。\n```\n//ES5 Version\nvar greet = 'Hi I\\'m Mark';\n\n//ES6 Version\nlet greet = `Hi I'm Mark`;\n\n```\n在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：\n```\n//ES5 Version\nvar lastWords = '\\n'\n  + '   I  \\n'\n  + '   Am  \\n'\n  + 'Iron Man \\n';\n\n\n//ES6 Version\nlet lastWords = `\n    I\n    Am\n  Iron Man   \n`;\n\n```\n在ES5版本中，我们需要添加\\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。\n```\n//ES5 Version\nfunction greet(name) {\n  return 'Hello ' + name + '!';\n}\n\n\n//ES6 Version\nfunction greet(name) {\n  return `Hello ${name} !`;\n}\n\n```\n在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。\n\n### 什么是对象解构？ \n对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：\n```\nconst employee = {\n  firstName: \"Marko\",\n  lastName: \"Polo\",\n  position: \"Software Developer\",\n  yearHired: 2017\n};\n\n```\n从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。\n```\nvar firstName = employee.firstName;\nvar lastName = employee.lastName;\nvar position = employee.position;\nvar yearHired = employee.yearHired;\n\n```\n使用解构方式语法就变得简洁多了：\n```\n{ firstName, lastName, position, yearHired } = employee;\n\n```\n我们还可以为属性取别名：\n```\nlet { firstName: fName, lastName: lName, position, yearHired } = employee;\n\n```\n当然如果属性值为 undefined 时，我们还可以指定默认值，但是属性为null时指定的默认值则不生效：\n```\nlet { firstName = \"Mark\", lastName: lName, position, yearHired } = employee;\n```\n\n### 什么是Set对象，它是如何工作的？\nSet 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。\n\n我们可以使用Set构造函数创建Set实例。\n```\nconst set1 = new Set();\nconst set2 = new Set([\"a\",\"b\",\"c\",\"d\",\"d\",\"e\"]);\n\n```\n我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。\n```\nset2.add(\"f\");\nset2.add(\"g\").add(\"h\").add(\"i\").add(\"j\").add(\"k\").add(\"k\");\n// 后一个“k”不会被添加到set对象中，因为它已经存在了\n```\n我们可以使用has方法检查Set实例中是否存在特定的值。\n```\nset2.has(\"a\") // true\nset2.has(\"z\") // true\n\n```\n我们可以使用size属性获得Set实例的长度。\n```\nset2.size // returns 10\n\n```\n可以使用clear方法删除 Set 中的数据。\n```\nset2.clear();\n\n```\n我们可以使用Set对象来删除数组中重复的元素。\n```\nconst numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];\nconst uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]\n \n```\n另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。\n- Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n- WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。\n\n### 什么是Proxy？\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。\n\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\n### 写一个通用的事件侦听器函数？\n```\nconst EventUtils = {\n  // 视能力分别使用dom0||dom2||IE方式 来绑定事件\n  // 添加事件\n  addEvent: function(element, type, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(type, handler, false);\n    } else if (element.attachEvent) {\n      element.attachEvent(\"on\" + type, handler);\n    } else {\n      element[\"on\" + type] = handler;\n    }\n  },\n\n  // 移除事件\n  removeEvent: function(element, type, handler) {\n    if (element.removeEventListener) {\n      element.removeEventListener(type, handler, false);\n    } else if (element.detachEvent) {\n      element.detachEvent(\"on\" + type, handler);\n    } else {\n      element[\"on\" + type] = null;\n    }\n  },\n\n  // 获取事件目标\n  getTarget: function(event) {\n    return event.target || event.srcElement;\n  },\n\n  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event\n  getEvent: function(event) {\n    return event || window.event;\n  },\n\n  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）\n  stopPropagation: function(event) {\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      event.cancelBubble = true;\n    }\n  },\n\n  // 取消事件的默认行为\n  preventDefault: function(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n  }\n};\n\n```\n\n### 什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\n```\n函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。\n函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。\n函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。\n\n```\n\n### 什么是高阶函数？\n高阶函数只是将函数作为参数或返回值的函数。\n```\nfunction higherOrderFunction(param,callback){\n    return callback(param);\n}\n\n```\n\n### 为什么函数被称为一等公民？\n```\n在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:\n\n赋值（var func = function(){}）、\n传参(function func(x,callback){callback();})、\n返回(function(){return function(){}})，\n\n这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。\n\n```\n\n### 手动实现Array.prototype.map 方法\n```\nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\nfunction map(arr, mapCallback) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') { \n    return [];\n  } else {\n    let result = [];\n    // 每次调用此函数时，我们都会创建一个 result 数组\n    // 因为我们不想改变原始数组。\n    for (let i = 0, len = arr.length; i < len; i++) {\n      result.push(mapCallback(arr[i], i, arr)); \n      // 将 mapCallback 返回的结果 push 到 result 数组中\n    }\n    return result;\n  }\n}\n\n```\n\n### 手动实现Array.prototype.filter方法\n```\nfilter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。\nfunction filter(arr, filterCallback) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') \n  {\n    return [];\n  } else {\n    let result = [];\n     // 每次调用此函数时，我们都会创建一个 result 数组\n     // 因为我们不想改变原始数组。\n    for (let i = 0, len = arr.length; i < len; i++) {\n      // 检查 filterCallback 的返回值是否是真值\n      if (filterCallback(arr[i], i, arr)) { \n      // 如果条件为真，则将数组元素 push 到 result 中\n        result.push(arr[i]);\n      }\n    }\n    return result; // return the result array\n  }\n}\n\n```\n\n### 手动实现Array.prototype.reduce方法\n```\nreduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\nfunction reduce(arr, reduceCallback, initialValue) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function') \n  {\n    return [];\n  } else {\n    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue\n    let hasInitialValue = initialValue !== undefined;\n    let value = hasInitialValue ? initialValue : arr[0];\n   、\n\n    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始\n    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i < len; i++) {\n      value = reduceCallback(value, arr[i], i, arr); \n    }\n    return value;\n  }\n}\n```\n\n### js的深浅拷贝\n>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。\n- 浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\n- 深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。\n>浅拷贝的实现方式：\n- Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n- Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。\n- 拓展运算符...：\n```\nlet a = {\n    name: \"Jake\",\n    flag: {\n        title: \"better day by day\",\n        time: \"2020-05-31\"\n    }\n}\nlet b = {...a};\n\n```\n>深拷贝的实现方式：\n- 乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）\n- 基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）\n```\nfunction cloneDeep(target,map = new WeakMap()) {\n  if(typeOf taret ==='object'){\n     let cloneTarget = Array.isArray(target) ? [] : {};\n      \n     if(map.get(target)) {\n        return target;\n    }\n     map.set(target, cloneTarget);\n     for(const key in target){\n        cloneTarget[key] = cloneDeep(target[key], map);\n     }\n     return cloneTarget\n  }else{\n       return target\n  }\n \n}\n```\n- 终极版：\n```\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst objectTag = '[object Object]';\nconst argsTag = '[object Arguments]';\n\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst numberTag = '[object Number]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst errorTag = '[object Error]';\nconst regexpTag = '[object RegExp]';\nconst funcTag = '[object Function]';\n\nconst deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];\n\n\nfunction forEach(array, iteratee) {\n    let index = -1;\n    const length = array.length;\n    while (++index < length) {\n        iteratee(array[index], index);\n    }\n    return array;\n}\n\nfunction isObject(target) {\n    const type = typeof target;\n    return target !== null && (type === 'object' || type === 'function');\n}\n\nfunction getType(target) {\n    return Object.prototype.toString.call(target);\n}\n\nfunction getInit(target) {\n    const Ctor = target.constructor;\n    return new Ctor();\n}\n\nfunction cloneSymbol(targe) {\n    return Object(Symbol.prototype.valueOf.call(targe));\n}\n\nfunction cloneReg(targe) {\n    const reFlags = /\\w*$/;\n    const result = new targe.constructor(targe.source, reFlags.exec(targe));\n    result.lastIndex = targe.lastIndex;\n    return result;\n}\n\nfunction cloneFunction(func) {\n    const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n    const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n    const funcString = func.toString();\n    if (func.prototype) {\n        const param = paramReg.exec(funcString);\n        const body = bodyReg.exec(funcString);\n        if (body) {\n            if (param) {\n                const paramArr = param[0].split(',');\n                return new Function(...paramArr, body[0]);\n            } else {\n                return new Function(body[0]);\n            }\n        } else {\n            return null;\n        }\n    } else {\n        return eval(funcString);\n    }\n}\n\nfunction cloneOtherType(targe, type) {\n    const Ctor = targe.constructor;\n    switch (type) {\n        case boolTag:\n        case numberTag:\n        case stringTag:\n        case errorTag:\n        case dateTag:\n            return new Ctor(targe);\n        case regexpTag:\n            return cloneReg(targe);\n        case symbolTag:\n            return cloneSymbol(targe);\n        case funcTag:\n            return cloneFunction(targe);\n        default:\n            return null;\n    }\n}\n\nfunction clone(target, map = new WeakMap()) {\n\n    // 克隆原始类型\n    if (!isObject(target)) {\n        return target;\n    }\n\n    // 初始化\n    const type = getType(target);\n    let cloneTarget;\n    if (deepTag.includes(type)) {\n        cloneTarget = getInit(target, type);\n    } else {\n        return cloneOtherType(target, type);\n    }\n\n    // 防止循环引用\n    if (map.get(target)) {\n        return map.get(target);\n    }\n    map.set(target, cloneTarget);\n\n    // 克隆set\n    if (type === setTag) {\n        target.forEach(value => {\n            cloneTarget.add(clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆map\n    if (type === mapTag) {\n        target.forEach((value, key) => {\n            cloneTarget.set(key, clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆对象和数组\n    const keys = type === arrayTag ? undefined : Object.keys(target);\n    forEach(keys || target, (value, key) => {\n        if (keys) {\n            key = value;\n        }\n        cloneTarget[key] = clone(target[key], map);\n    });\n\n    return cloneTarget;\n}\n\nmodule.exports = {\n    clone\n};\n\n```\n\n### 手写call、apply及bind函数\ncall 函数的实现步骤：\n- 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 3.处理传入的参数，截取第一个参数后的所有参数。\n- 4.将函数作为上下文对象的一个属性。\n- 5.使用上下文对象来调用这个方法，并保存返回结果。\n- 6.删除刚才新增的属性。\n- 7.返回结果。\n```\n// call函数实现\nFunction.prototype.myCall = function(context) {\n  // 判断调用对象\n  if (typeof this !== \"function\") {\n    console.error(\"type error\");\n  }\n\n  // 获取参数\n  let args = [...arguments].slice(1),\n    result = null;\n\n  // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window;\n\n  // 将调用函数设为对象的方法\n  context.fn = this;\n\n  // 调用函数\n  result = context.fn(...args);\n\n  // 将属性删除\n  delete context.fn;\n\n  return result;\n};\n```\napply 函数的实现步骤：\n- 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 将函数作为上下文对象的一个属性。\n- 判断参数值是否传入\n- 使用上下文对象来调用这个方法，并保存返回结果。\n- 删除刚才新增的属性\n- 返回结果\n```\n\n// apply 函数实现\n\nFunction.prototype.myApply = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n\n  let result = null;\n\n  // 判断 context 是否存在，如果未传入则为 window\n  context = context || window;\n\n  // 将函数设为对象的方法\n  context.fn = this;\n\n  // 调用方法\n  if (arguments[1]) { \n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n\n  // 将属性删除\n  delete context.fn;\n\n  return result;\n};\n```\nbind 函数的实现步骤：\n- 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 2.保存当前函数的引用，获取其余传入参数值。\n- 3.创建一个函数返回\n- 4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n```\n// bind 函数实现\nFunction.prototype.myBind = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n\n  // 获取参数\n  var args = [...arguments].slice(1),\n    fn = this;\n\n  return function Fn() {\n    // 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      args.concat(...arguments)\n    );\n  };\n};\n```\n\n### 函数柯里化的实现\n```\n// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n\nfunction curry(fn, args) {\n  // 获取函数需要的参数长度\n  let length = fn.length;\n\n  args = args || [];\n\n  return function() {\n    let subArgs = args.slice(0);\n\n    // 拼接得到现有的所有参数\n    for (let i = 0; i < arguments.length; i++) {\n      subArgs.push(arguments[i]);\n    }\n\n    // 判断参数的长度是否已经满足函数所需参数的长度\n    if (subArgs.length >= length) {\n      // 如果满足，执行函数\n      return fn.apply(this, subArgs);\n    } else {\n      // 如果不满足，递归返回科里化的函数，等待参数的传入\n      return curry.call(this, fn, subArgs);\n    }\n  };\n}\n\n// es6 实现\nfunction curry(fn, ...args) {\n  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);\n}\n\n```\n\n### js模拟new操作符的实现\nnew 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作：\n1. 创建一个空的简单JavaScript对象（即{}）；\n2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；\n3. 将步骤1新创建的对象作为this的上下文 ；\n4. 如果该函数没有返回对象，则返回this。\n接下来我们看实现：\n```\nfunction Dog(name, color, age) {\n  this.name = name;\n  this.color = color;\n  this.age = age;\n}\n\nDog.prototype={\n  getName: function() {\n    return this.name\n  }\n}\n\nvar dog = new Dog('大黄', 'yellow', 3)\n\n```\n上面的代码相信不用解释，大家都懂。我们来看最后一行带new关键字的代码，按照上述的1,2,3,4步来解析new背后的操作。\n\n第一步：创建一个简单空对象\n```\nvar obj = {}\n```\n第二步：链接该对象到另一个对象（原型链）\n```\n// 设置原型链\nobj.__proto__ = Dog.prototype\n```\n第三步：将步骤1新创建的对象作为 this 的上下文\n```\n// this指向obj对象\nDog.apply(obj, ['大黄', 'yellow', 3])\n```\n第四步：如果该函数没有返回对象，则返回this\n```\n// 因为 Dog() 没有返回值，所以返回obj\nvar dog = obj\ndog.getName() // '大黄'\n```\n需要注意的是如果 Dog() 有 return 则返回 return的值\n```\nvar rtnObj = {}\nfunction Dog(name, color, age) {\n  // ...\n  //返回一个对象\n  return rtnObj\n}\n\nvar dog = new Dog('大黄', 'yellow', 3)\nconsole.log(dog === rtnObj) // true\n```\n接下来我们将以上步骤封装成一个对象实例化方法，即模拟new的操作：\n```\nfunction objectFactory(){\n    var obj = {};\n    //取得该方法的第一个参数(并删除第一个参数)，该参数是构造函数\n    var Constructor = [].shift.apply(arguments);\n    //将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法\n    obj.__proto__ = Constructor.prototype;\n    //取得构造函数的返回值\n    var ret = Constructor.apply(obj, arguments);\n    //如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象\n    return typeof ret === \"object\" ? ret : obj;\n}\n```\n### 什么是回调函数？回调函数有什么缺点\n回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。\n在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。\n\n### Promise是什么，可以手写实现一下吗？\nPromise，翻译过来是承诺，承诺它过一段时间会给你一个结果。从编程讲Promise 是异步编程的一种解决方案。下面是Promise在MDN的相关说明：\nPromise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。\n一个 Promise有以下几种状态:\n  - pending: 初始状态，既不是成功，也不是失败状态。\n  - fulfilled: 意味着操作成功完成。\n  - rejected: 意味着操作失败。\n这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 fulfilled/rejected 后，就不能再次改变。\n可能光看概念大家不理解Promise，我们举个简单的栗子；\n假如我有个女朋友，下周一是她生日，我答应她生日给她一个惊喜，那么从现在开始这个承诺就进入等待状态，等待下周一的到来，然后状态改变。如果下周一我如约给了女朋友惊喜，那么这个承诺的状态就会由pending切换为fulfilled，表示承诺成功兑现，一旦是这个结果了，就不会再有其他结果，即状态不会在发生改变；反之如果当天我因为工作太忙加班，把这事给忘了，说好的惊喜没有兑现，状态就会由pending切换为rejected，时间不可倒流，所以状态也不能再发生变化。\n上一条我们说过Promise可以解决回调地狱的问题，没错，pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，一旦状态改变，Promise 对象的 then 方法就会被调用；否则就会触发 catch。我们将上一条回调地狱的代码改写一下：\n```\nnew Promise((resolve，reject) => {\n     setTimeout(() => {\n            console.log(1)\n            resolve()\n        },1000)\n        \n}).then((res) => {\n    setTimeout(() => {\n            console.log(2)\n        },2000)\n}).then((res) => {\n    setTimeout(() => {\n            console.log(3)\n        },3000)\n}).catch((err) => {\nconsole.log(err)\n})\n\n```\n其实Promise也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。\n手写版本\n```\nfunction myPromise(constructor){\n    let self=this;\n    self.status=\"pending\" //定义状态改变前的初始状态\n    self.value=undefined;//定义状态为resolved的时候的状态\n    self.reason=undefined;//定义状态为rejected的时候的状态\n    function resolve(value){\n        //两个===\"pending\"，保证了状态的改变是不可逆的\n       if(self.status===\"pending\"){\n          self.value=value;\n          self.status=\"resolved\";\n       }\n    }\n    function reject(reason){\n        //两个===\"pending\"，保证了状态的改变是不可逆的\n       if(self.status===\"pending\"){\n          self.reason=reason;\n          self.status=\"rejected\";\n       }\n    }\n    //捕获构造异常\n    try{\n       constructor(resolve,reject);\n    }catch(e){\n       reject(e);\n    }\n}\n// 定义链式调用的then方法\nmyPromise.prototype.then=function(onFullfilled,onRejected){\n   let self=this;\n   switch(self.status){\n      case \"resolved\":\n        onFullfilled(self.value);\n        break;\n      case \"rejected\":\n        onRejected(self.reason);\n        break;\n      default:       \n   }\n}\n```\n### Iterator是什么，有什么作用？\nIterator是理解第61条的先决知识\nIterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n```\nconst obj = {\n    [Symbol.iterator]:function(){}\n}\n```\n[Symbol.iterator] 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。\n迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据\n每一次的 next 都会返回一个对象，该对象有两个属性\n- value 代表想要获取的数据\n- done 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束\nIterator 的作用有三个：\n1. 为各种数据结构，提供一个统一的、简便的访问接口；\n2. 使得数据结构的成员能够按某种次序排列；\n3. ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。\n遍历过程：\n1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n3. 不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n```\nlet arr = [{num:1},2,3]\nlet it = arr[Symbol.iterator]() // 获取数组中的迭代器\nconsole.log(it.next())  // { value: Object { num: 1 }, done: false }\nconsole.log(it.next())  // { value: 2, done: false }\nconsole.log(it.next())  // { value: 3, done: false }\nconsole.log(it.next())  // { value: undefined, done: true }\n```\n\n### Generator函数是什么，有什么作用？\n\n### 什么是 async/await及其如何工作,有什么优缺点？\n\n### instanceof的原理是什么，如何实现\n\n### js的节流与防抖\n\n### 什么是设计模式？\n\n### 9种前端常见的设计模式\n\n\n\n","slug":"问题整理","published":1,"updated":"2021-02-22T14:48:26.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklgpoidj001hjxwhb744vflm","content":"<h3 id=\"介绍一下js的数据类型有哪些-值是如何存储的\"><a href=\"#介绍一下js的数据类型有哪些-值是如何存储的\" class=\"headerlink\" title=\"介绍一下js的数据类型有哪些,值是如何存储的\"></a>介绍一下js的数据类型有哪些,值是如何存储的</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一共有8种数据类型，7种基本数据类型</span><br><span class=\"line\">String </span><br><span class=\"line\">Number </span><br><span class=\"line\">Boolean </span><br><span class=\"line\">Null </span><br><span class=\"line\">Undefined </span><br><span class=\"line\">Symbol（es6 新增类型，表示第一无二的值） </span><br><span class=\"line\">BigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）</span><br><span class=\"line\">Object（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）</span><br><span class=\"line\"></span><br><span class=\"line\">原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class=\"line\"></span><br><span class=\"line\">引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure>\n<h3 id=\"amp-amp-、-和-运算符分别能做什么\"><a href=\"#amp-amp-、-和-运算符分别能做什么\" class=\"headerlink\" title=\"&amp;&amp; 、 ||和!! 运算符分别能做什么\"></a>&amp;&amp; 、 ||和!! 运算符分别能做什么</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;&amp; 并且符，使用时两边的值结果都必须为true才返回true</span><br><span class=\"line\">|| 或者符，两边的值结果有一个为true最终判断结果就位true</span><br><span class=\"line\">!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）</span><br></pre></td></tr></table></figure>\n<h3 id=\"JS的数据类型的转换\"><a href=\"#JS的数据类型的转换\" class=\"headerlink\" title=\"JS的数据类型的转换\"></a>JS的数据类型的转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在 JS 中类型转换只有三种情况，分别是：</span><br><span class=\"line\"></span><br><span class=\"line\">- 转换为布尔值（调用Boolean()方法）</span><br><span class=\"line\">- 转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class=\"line\">- 转换为字符串（调用.toString()或者String()方法）</span><br><span class=\"line\"></span><br><span class=\"line\">null和underfined没有.toString方法</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\"><a href=\"#JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\" class=\"headerlink\" title=\"JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()\"></a>JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()</h3><blockquote>\n<p>（1）typeof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typeof 对于原始类型来说，除了 null 都可以显示正确的类型</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof 2);               // number</span><br><span class=\"line\">console.log(typeof true);            // boolean</span><br><span class=\"line\">console.log(typeof &apos;str&apos;);           // string</span><br><span class=\"line\">console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object</span><br><span class=\"line\">console.log(typeof function()&#123;&#125;);    // function</span><br><span class=\"line\">console.log(typeof &#123;&#125;);              // object</span><br><span class=\"line\">console.log(typeof undefined);       // undefined</span><br><span class=\"line\">console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object</span><br><span class=\"line\"></span><br><span class=\"line\">typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（2）instanceof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//重点</span><br><span class=\"line\">instanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断</span><br><span class=\"line\">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class=\"line\">其意思就是判断对象是否是某一数据类型（如Array）的实例</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(2 instanceof Number);                    // false</span><br><span class=\"line\">console.log(true instanceof Boolean);                // false </span><br><span class=\"line\">console.log(&apos;str&apos; instanceof String);                // false  </span><br><span class=\"line\">console.log([] instanceof Array);                    // true</span><br><span class=\"line\">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class=\"line\">console.log(&#123;&#125; instanceof Object);                   // true    </span><br><span class=\"line\">// console.log(undefined instanceof Undefined);      //报错</span><br><span class=\"line\">// console.log(null instanceof Null);                //报错</span><br><span class=\"line\">复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。</span><br><span class=\"line\">我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，&apos;str&apos;不是实例，所以判断值为false。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（3）constructor<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log((2).constructor === Number); // true</span><br><span class=\"line\">console.log((true).constructor === Boolean); // true</span><br><span class=\"line\">console.log((&apos;str&apos;).constructor === String); // true</span><br><span class=\"line\">console.log(([]).constructor === Array); // true</span><br><span class=\"line\">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class=\"line\">console.log((&#123;&#125;).constructor === Object); // true</span><br><span class=\"line\"></span><br><span class=\"line\">这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了</span><br><span class=\"line\"></span><br><span class=\"line\">function Fn()&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">Fn.prototype=new Array();</span><br><span class=\"line\"> </span><br><span class=\"line\">var f=new Fn();</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(f.constructor===Fn);    // false</span><br><span class=\"line\">console.log(f.constructor===Array); // true</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = Object.prototype.toString;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(a.call(2));</span><br><span class=\"line\">console.log(a.call(true));</span><br><span class=\"line\">console.log(a.call(&apos;str&apos;));</span><br><span class=\"line\">console.log(a.call([]));</span><br><span class=\"line\">console.log(a.call(function()&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(undefined));</span><br><span class=\"line\">console.log(a.call(null));</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"介绍-JS-有哪些内置对象？\"><a href=\"#介绍-JS-有哪些内置对象？\" class=\"headerlink\" title=\"介绍 JS 有哪些内置对象？\"></a>介绍 JS 有哪些内置对象？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class=\"line\">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class=\"line\"></span><br><span class=\"line\">标准内置对象的分类</span><br><span class=\"line\"></span><br><span class=\"line\">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Infinity、NaN、undefined、null 字面量</span><br><span class=\"line\"></span><br><span class=\"line\">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 eval()、parseFloat()、parseInt() 等</span><br><span class=\"line\"></span><br><span class=\"line\">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class=\"line\"></span><br><span class=\"line\">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Number、Math、Date</span><br><span class=\"line\"></span><br><span class=\"line\">（5）字符串，用来表示和操作字符串的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 String、RegExp</span><br><span class=\"line\"></span><br><span class=\"line\">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class=\"line\"></span><br><span class=\"line\">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Map、Set、WeakMap、WeakSet</span><br><span class=\"line\"></span><br><span class=\"line\">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 SIMD 等</span><br><span class=\"line\"></span><br><span class=\"line\">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 JSON 等</span><br><span class=\"line\"></span><br><span class=\"line\">（10）控制抽象对象</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Promise、Generator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（11）反射</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Reflect、Proxy</span><br><span class=\"line\"></span><br><span class=\"line\">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Intl、Intl.Collator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（13）WebAssembly</span><br><span class=\"line\"></span><br><span class=\"line\">（14）其他</span><br><span class=\"line\"></span><br><span class=\"line\">例如 arguments</span><br></pre></td></tr></table></figure>\n<h3 id=\"undefined-与-undeclared-的区别？\"><a href=\"#undefined-与-undeclared-的区别？\" class=\"headerlink\" title=\"undefined 与 undeclared 的区别？\"></a>undefined 与 undeclared 的区别？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。</span><br><span class=\"line\">对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ</span><br><span class=\"line\">eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</span><br></pre></td></tr></table></figure>\n<h3 id=\"null-和-undefined-的区别？\"><a href=\"#null-和-undefined-的区别？\" class=\"headerlink\" title=\"null 和 undefined 的区别？\"></a>null 和 undefined 的区别？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class=\"line\">undefined 代表的含义是未定义，</span><br><span class=\"line\">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class=\"line\">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class=\"line\">/*</span><br><span class=\"line\">    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，</span><br><span class=\"line\">    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class=\"line\">    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</span><br><span class=\"line\">*/</span><br><span class=\"line\">undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它</span><br><span class=\"line\">会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</span><br><span class=\"line\">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等</span><br><span class=\"line\">号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>\n<h3 id=\"和-的valueOf和toString的结果是什么？\"><a href=\"#和-的valueOf和toString的结果是什么？\" class=\"headerlink\" title=\"{}和[]的valueOf和toString的结果是什么？\"></a>{}和[]的valueOf和toString的结果是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Javascript-的作用域和作用域链？\"><a href=\"#Javascript-的作用域和作用域链？\" class=\"headerlink\" title=\"Javascript 的作用域和作用域链？\"></a>Javascript 的作用域和作用域链？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class=\"line\">【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</span><br></pre></td></tr></table></figure>\n<h3 id=\"javascript-创建对象的几种方式？\"><a href=\"#javascript-创建对象的几种方式？\" class=\"headerlink\" title=\"javascript 创建对象的几种方式？\"></a>javascript 创建对象的几种方式？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript-继承的几种实现方式？\"><a href=\"#JavaScript-继承的几种实现方式？\" class=\"headerlink\" title=\"JavaScript 继承的几种实现方式？\"></a>JavaScript 继承的几种实现方式？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生式组合继承的实现？\"><a href=\"#寄生式组合继承的实现？\" class=\"headerlink\" title=\"寄生式组合继承的实现？\"></a>寄生式组合继承的实现？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person</span><br><span class=\"line\">Student</span><br><span class=\"line\"></span><br><span class=\"line\">function Person(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Student(name, grade)&#123;</span><br><span class=\"line\">    Person.call(this,name);</span><br><span class=\"line\">    this.grade = grade;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype = Object.create(Person.prototype);</span><br><span class=\"line\">Student.prototype.constructor = Student;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.sayMyGrade = function() &#123;</span><br><span class=\"line\">  console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"谈谈你对this、call、apply和bind的理解\"><a href=\"#谈谈你对this、call、apply和bind的理解\" class=\"headerlink\" title=\"谈谈你对this、call、apply和bind的理解\"></a>谈谈你对this、call、apply和bind的理解</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结:</span><br><span class=\"line\">1. 在浏览器里，在全局范围内this 指向window对象；</span><br><span class=\"line\">2. 在函数中，this永远指向最后调用他的那个对象；</span><br><span class=\"line\">3. 构造函数中，this指向new出来的那个新的对象；</span><br><span class=\"line\">4. call、apply、bind中的this被强绑定在指定的那个对象上；</span><br><span class=\"line\">5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</span><br><span class=\"line\">6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</span><br><span class=\"line\"></span><br><span class=\"line\">区别:</span><br><span class=\"line\">- call/apply改变了函数的this上下文后马上执行该函数</span><br><span class=\"line\">- bind则是返回改变了上下文后的函数,不执行该函数</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript-原型，原型链？-有什么特点？\"><a href=\"#JavaScript-原型，原型链？-有什么特点？\" class=\"headerlink\" title=\"JavaScript 原型，原型链？ 有什么特点？\"></a>JavaScript 原型，原型链？ 有什么特点？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">prototype就是JS的原型，里面可以定义属性和方法</span><br><span class=\"line\">当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。</span><br><span class=\"line\">原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br></pre></td></tr></table></figure>\n<h3 id=\"js-获取原型的方法？\"><a href=\"#js-获取原型的方法？\" class=\"headerlink\" title=\"js 获取原型的方法？\"></a>js 获取原型的方法？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p.proto</span><br><span class=\"line\">p.constructor.prototype</span><br><span class=\"line\">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是闭包，为什么要用它？\"><a href=\"#什么是闭包，为什么要用它？\" class=\"headerlink\" title=\"什么是闭包，为什么要用它？\"></a>什么是闭包，为什么要用它？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">闭包是指有权访问另一个函数作用域内变量的函数</span><br><span class=\"line\">创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。</span><br><span class=\"line\"></span><br><span class=\"line\">闭包有两个常用的用途:</span><br><span class=\"line\">- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class=\"line\">- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</span><br><span class=\"line\"></span><br><span class=\"line\">function a()&#123;</span><br><span class=\"line\">    var n = 0;</span><br><span class=\"line\">    function add()&#123;</span><br><span class=\"line\">       n++;</span><br><span class=\"line\">       console.log(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span><br><span class=\"line\">a1();    //1</span><br><span class=\"line\">a1();    //2  第二次调用n变量还在内存中</span><br><span class=\"line\"></span><br><span class=\"line\">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是-DOM-和-BOM？\"><a href=\"#什么是-DOM-和-BOM？\" class=\"headerlink\" title=\"什么是 DOM 和 BOM？\"></a>什么是 DOM 和 BOM？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class=\"line\"></span><br><span class=\"line\">BOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM</span><br><span class=\"line\">的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）</span><br><span class=\"line\">对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati</span><br><span class=\"line\">on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对</span><br><span class=\"line\">象的子对象。</span><br></pre></td></tr></table></figure>\n<h3 id=\"三种事件模型是什么？\"><a href=\"#三种事件模型是什么？\" class=\"headerlink\" title=\"三种事件模型是什么？\"></a>三种事件模型是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class=\"line\">IE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class=\"line\">DOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件委托是什么？\"><a href=\"#事件委托是什么？\" class=\"headerlink\" title=\"事件委托是什么？\"></a>事件委托是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class=\"line\">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class=\"line\">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件传播\"><a href=\"#什么是事件传播\" class=\"headerlink\" title=\"什么是事件传播?\"></a>什么是事件传播?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。</span><br><span class=\"line\">事件传播有三个阶段：</span><br><span class=\"line\">1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class=\"line\">2. 目标阶段–事件已达到目标元素。</span><br><span class=\"line\">3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件捕获？\"><a href=\"#什么是事件捕获？\" class=\"headerlink\" title=\"什么是事件捕获？\"></a>什么是事件捕获？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----&gt; document----&gt; html----&gt; body ----&gt;目标元素</span><br><span class=\"line\"></span><br><span class=\"line\">html:</span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">js:</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件冒泡？\"><a href=\"#什么是事件冒泡？\" class=\"headerlink\" title=\"什么是事件冒泡？\"></a>什么是事件冒泡？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br><span class=\"line\">假设有如下的 HTML 结构：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">对应的JS代码：</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\"><a href=\"#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\" class=\"headerlink\" title=\"DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><p>（1）创建新节点<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">createDocumentFragment()    //创建一个DOM片段</span><br><span class=\"line\">createElement()   //创建一个具体的元素</span><br><span class=\"line\">createTextNode()   //创建一个文本节点</span><br></pre></td></tr></table></figure></p>\n<p>（2）添加、移除、替换、插入<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendChild(node)</span><br><span class=\"line\">removeChild(node)</span><br><span class=\"line\">replaceChild(new,old)</span><br><span class=\"line\">insertBefore(new,old)</span><br></pre></td></tr></table></figure></p>\n<p>（3）查找<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getElementById();</span><br><span class=\"line\">getElementsByName();</span><br><span class=\"line\">getElementsByTagName();</span><br><span class=\"line\">getElementsByClassName();</span><br><span class=\"line\">querySelector();</span><br><span class=\"line\">querySelectorAll();</span><br></pre></td></tr></table></figure></p>\n<p>（4）属性操作<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getAttribute(key);</span><br><span class=\"line\">setAttribute(key, value);</span><br><span class=\"line\">hasAttribute(key);</span><br><span class=\"line\">removeAttribute(key);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"js数组和对象有哪些原生方法-列举一下\"><a href=\"#js数组和对象有哪些原生方法-列举一下\" class=\"headerlink\" title=\"js数组和对象有哪些原生方法,列举一下\"></a>js数组和对象有哪些原生方法,列举一下</h3><p><img src=\"https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h3><h3 id=\"Ajax-是什么-如何创建一个-Ajax？\"><a href=\"#Ajax-是什么-如何创建一个-Ajax？\" class=\"headerlink\" title=\"Ajax 是什么? 如何创建一个 Ajax？\"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。<br>创建步骤：<br><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/17274125a4cf4d61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//1：创建Ajax对象</span><br><span class=\"line\">var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);    //兼容IE6及以下版本</span><br><span class=\"line\">//2：配置 Ajax请求地址</span><br><span class=\"line\">xhr.open(&apos;get&apos;,&apos;index.xml&apos;,true);</span><br><span class=\"line\">//3：发送请求</span><br><span class=\"line\">xhr.send(null); //严谨写法</span><br><span class=\"line\">//4:监听请求，接受响应</span><br><span class=\"line\">xhr.onreadysatechange = function()&#123;</span><br><span class=\"line\">    if(xhr.readySates == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304)&#123;</span><br><span class=\"line\">        console.log(xhr.responsetXML);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>promise封装实现<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// promise 封装实现：</span><br><span class=\"line\"></span><br><span class=\"line\">function getJSON(url) &#123;</span><br><span class=\"line\">  // 创建一个 promise 对象</span><br><span class=\"line\">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    let xhr = new XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 新建一个 http 请求</span><br><span class=\"line\">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置状态的监听函数</span><br><span class=\"line\">    xhr.onreadystatechange = function() &#123;</span><br><span class=\"line\">      if (this.readyState !== 4) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class=\"line\">      if (this.status === 200) &#123;</span><br><span class=\"line\">        resolve(this.response);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        reject(new Error(this.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置错误监听函数</span><br><span class=\"line\">    xhr.onerror = function() &#123;</span><br><span class=\"line\">      reject(new Error(this.statusText));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置响应的数据类型</span><br><span class=\"line\">    xhr.responseType = &quot;json&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置请求头信息</span><br><span class=\"line\">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 发送 http 请求</span><br><span class=\"line\">    xhr.send(null);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return promise;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"js-延迟加载的方式有哪些？\"><a href=\"#js-延迟加载的方式有哪些？\" class=\"headerlink\" title=\"js 延迟加载的方式有哪些？\"></a>js 延迟加载的方式有哪些？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class=\"line\">我了解到的几种方式是：</span><br><span class=\"line\"></span><br><span class=\"line\">将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class=\"line\">给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class=\"line\">给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class=\"line\">动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure>\n<h3 id=\"谈谈你对模块化开发的理解？\"><a href=\"#谈谈你对模块化开发的理解？\" class=\"headerlink\" title=\"谈谈你对模块化开发的理解？\"></a>谈谈你对模块化开发的理解？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念</span><br><span class=\"line\">，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class=\"line\">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污</span><br><span class=\"line\">染，并且模块间没有联系。</span><br><span class=\"line\">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所</span><br><span class=\"line\">有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class=\"line\">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure>\n<h3 id=\"js-的几种模块规范？\"><a href=\"#js-的几种模块规范？\" class=\"headerlink\" title=\"js 的几种模块规范？\"></a>js 的几种模块规范？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">js 中现在比较成熟的有四种模块加载方案：</span><br><span class=\"line\"></span><br><span class=\"line\">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class=\"line\">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class=\"line\">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class=\"line\">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</span><br></pre></td></tr></table></figure>\n<h3 id=\"AMD和CMD-规范的区别？\"><a href=\"#AMD和CMD-规范的区别？\" class=\"headerlink\" title=\"AMD和CMD 规范的区别？\"></a>AMD和CMD 规范的区别？</h3><p>它们之间的主要区别有两个方面。</p>\n<ol>\n<li>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</li>\n<li>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br> 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br> 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br> 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">  var a = require(&quot;./a&quot;);</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 此处略去 100 行</span><br><span class=\"line\">  var b = require(&quot;./b&quot;); // 依赖可以就近书写</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) &#123;</span><br><span class=\"line\">  // 依赖必须一开始就写好</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 此处略去 100 行</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\"><a href=\"#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\" class=\"headerlink\" title=\"ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><ul>\n<li>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>\n<li>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>\n</ul>\n<h3 id=\"requireJS的核心原理是什么？\"><a href=\"#requireJS的核心原理是什么？\" class=\"headerlink\" title=\"requireJS的核心原理是什么？\"></a>requireJS的核心原理是什么？</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p>\n<h3 id=\"谈谈JS的运行机制\"><a href=\"#谈谈JS的运行机制\" class=\"headerlink\" title=\"谈谈JS的运行机制\"></a>谈谈JS的运行机制</h3><ol>\n<li><p>js单线程<br>JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。</p>\n<blockquote>\n<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>\n</blockquote>\n</li>\n<li><p>js事件循环<br>js代码执行过程中会有很多任务，这些任务总的分成两类：</p>\n</li>\n</ol>\n<ul>\n<li>同步任务</li>\n<li>异步任务<br>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：<br><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/172744a7fa2853c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></li>\n</ul>\n<p>回答：</p>\n<ol>\n<li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li>\n<li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li>\n<li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li>\n<li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li>\n<li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li>\n</ol>\n<h3 id=\"arguments-的对象是什么？\"><a href=\"#arguments-的对象是什么？\" class=\"headerlink\" title=\"arguments 的对象是什么？\"></a>arguments 的对象是什么？</h3><p>arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。<br>我们可以使用Array.prototype.slice将arguments对象转换成一个数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function one() &#123;</span><br><span class=\"line\">  return Array.prototype.slice.call(arguments);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意:箭头函数中没有arguments对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function one() &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const two = function () &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const three = function three() &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const four = () =&gt; arguments;</span><br><span class=\"line\"></span><br><span class=\"line\">four(); // Throws an error  - arguments is not defined</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为什么在调用这个函数时，代码中的b会变成一个全局变量\"><a href=\"#为什么在调用这个函数时，代码中的b会变成一个全局变量\" class=\"headerlink\" title=\"为什么在调用这个函数时，代码中的b会变成一个全局变量?\"></a>为什么在调用这个函数时，代码中的b会变成一个全局变量?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a = b = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure>\n<p>原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a = (b = 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure></p>\n<p>首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。</p>\n<p>我们可以通过在赋值之前先声明变量来解决这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a,b;</span><br><span class=\"line\">  a = b = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"简单介绍一下V8引擎的垃圾回收机制\"><a href=\"#简单介绍一下V8引擎的垃圾回收机制\" class=\"headerlink\" title=\"简单介绍一下V8引擎的垃圾回收机制\"></a>简单介绍一下V8引擎的垃圾回收机制</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class=\"line\"></span><br><span class=\"line\">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class=\"line\"></span><br><span class=\"line\">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）如果对象不存活，则释放对象的空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class=\"line\"></span><br><span class=\"line\">新生代对象晋升到老生代有两个条件：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class=\"line\"></span><br><span class=\"line\">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"哪些操作会造成内存泄漏？\"><a href=\"#哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"哪些操作会造成内存泄漏？\"></a>哪些操作会造成内存泄漏？</h3><ul>\n<li>1.意外的全局变量</li>\n<li>2.被遗忘的计时器或回调函数</li>\n<li>3.脱离 DOM 的引用</li>\n<li><p>4.闭包</p>\n</li>\n<li><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p>\n</li>\n<li>第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>\n<li>第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>\n<li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>\n</ul>\n<h3 id=\"ECMAScript-是什么？\"><a href=\"#ECMAScript-是什么？\" class=\"headerlink\" title=\"ECMAScript 是什么？\"></a>ECMAScript 是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。</span><br><span class=\"line\">ECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件</span><br><span class=\"line\">只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。</span><br><span class=\"line\">javaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）</span><br><span class=\"line\">ECMAScript说什么JavaScript就得做什么！</span><br><span class=\"line\">JavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！</span><br><span class=\"line\">——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，</span><br><span class=\"line\">那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。</span><br></pre></td></tr></table></figure>\n<h3 id=\"ECMAScript-2015（ES6）有哪些新特性？\"><a href=\"#ECMAScript-2015（ES6）有哪些新特性？\" class=\"headerlink\" title=\"ECMAScript 2015（ES6）有哪些新特性？\"></a>ECMAScript 2015（ES6）有哪些新特性？</h3><ul>\n<li>块作用域</li>\n<li>类</li>\n<li>箭头函数</li>\n<li>模板字符串</li>\n<li>加强的对象字面</li>\n<li>对象解构</li>\n<li>Promise</li>\n<li>模块</li>\n<li>Symbol</li>\n<li>代理（proxy）Set</li>\n<li>函数默认参数</li>\n<li>rest 和展开</li>\n</ul>\n<h3 id=\"var-let和const的区别是什么？\"><a href=\"#var-let和const的区别是什么？\" class=\"headerlink\" title=\"var,let和const的区别是什么？\"></a>var,let和const的区别是什么？</h3><p>var声明的变量会挂载在window上，而let和const声明的变量不会：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\">console.log(a,window.a);    // 100 100</span><br><span class=\"line\"></span><br><span class=\"line\">let b = 10;</span><br><span class=\"line\">console.log(b,window.b);    // 10 undefined</span><br><span class=\"line\"></span><br><span class=\"line\">const c = 1;</span><br><span class=\"line\">console.log(c,window.c);    // 1 undefined</span><br></pre></td></tr></table></figure></p>\n<p>var声明变量存在变量提升，let和const不存在变量提升:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(a); // undefined  ===&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class=\"line\">var a = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b); // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class=\"line\">let b = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(c); // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br><span class=\"line\">const c = 10;</span><br></pre></td></tr></table></figure></p>\n<p>let和const声明形成块作用域<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">  var a = 100;</span><br><span class=\"line\">  let b = 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\">console.log(b)  // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class=\"line\"></span><br><span class=\"line\">-------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">  var a = 100;</span><br><span class=\"line\">  const c = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\">console.log(c)  // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br></pre></td></tr></table></figure></p>\n<p>同一作用域下let和const不能声明同名变量，而var可以<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\"></span><br><span class=\"line\">var a = 10;</span><br><span class=\"line\">console.log(a); // 10</span><br><span class=\"line\">-------------------------------------</span><br><span class=\"line\">let a = 100;</span><br><span class=\"line\">let a = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">//  控制台报错：Identifier &apos;a&apos; has already been declared  ===&gt; 标识符a已经被声明了。</span><br></pre></td></tr></table></figure></p>\n<p>暂存死区<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">    a = 10;</span><br><span class=\"line\">    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class=\"line\">    // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class=\"line\">    let a = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>const<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;1、一旦声明必须赋值,不能使用null占位。</span><br><span class=\"line\">*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;2、声明后不能再修改</span><br><span class=\"line\">*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;3、如果声明的是复合类型数据，可以修改其属性</span><br><span class=\"line\">*</span><br><span class=\"line\">* */</span><br><span class=\"line\"></span><br><span class=\"line\">const a = 100; </span><br><span class=\"line\"></span><br><span class=\"line\">const list = [];</span><br><span class=\"line\">list[0] = 10;</span><br><span class=\"line\">console.log(list);&amp;emsp;&amp;emsp;// [10]</span><br><span class=\"line\"></span><br><span class=\"line\">const obj = &#123;a:100&#125;;</span><br><span class=\"line\">obj.name = &apos;apple&apos;;</span><br><span class=\"line\">obj.a = 10000;</span><br><span class=\"line\">console.log(obj);&amp;emsp;&amp;emsp;// &#123;a:10000,name:&apos;apple&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是箭头函数？\"><a href=\"#什么是箭头函数？\" class=\"headerlink\" title=\"什么是箭头函数？\"></a>什么是箭头函数？</h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var getCurrentDate = function ()&#123;</span><br><span class=\"line\">  return new Date();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">const getCurrentDate = () =&gt; new Date();</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">const greet = (name) =&gt; `Hello $&#123;name&#125;`;</span><br><span class=\"line\">const greet2 = name =&gt; `Hello $&#123;name&#125;`;</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const getArgs = () =&gt; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">const getArgs2 = (...rest) =&gt; rest</span><br></pre></td></tr></table></figure></p>\n<p>箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const data = &#123;</span><br><span class=\"line\">  result: 0,</span><br><span class=\"line\">  nums: [1, 2, 3, 4, 5],</span><br><span class=\"line\">  computeResult() &#123;</span><br><span class=\"line\">    // 这里的“this”指的是“data”对象</span><br><span class=\"line\">    const addAll = () =&gt; &#123;</span><br><span class=\"line\">      return this.nums.reduce((total, cur) =&gt; total + cur, 0)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.result = addAll();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。</p>\n<h3 id=\"什么是类？\"><a href=\"#什么是类？\" class=\"headerlink\" title=\"什么是类？\"></a>什么是类？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是模板字符串？\"><a href=\"#什么是模板字符串？\" class=\"headerlink\" title=\"什么是模板字符串？\"></a>什么是模板字符串？</h3><p>模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var greet = &apos;Hi I\\&apos;m Mark&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">let greet = `Hi I&apos;m Mark`;</span><br></pre></td></tr></table></figure></p>\n<p>在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var lastWords = &apos;\\n&apos;</span><br><span class=\"line\">  + &apos;   I  \\n&apos;</span><br><span class=\"line\">  + &apos;   Am  \\n&apos;</span><br><span class=\"line\">  + &apos;Iron Man \\n&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">let lastWords = `</span><br><span class=\"line\">    I</span><br><span class=\"line\">    Am</span><br><span class=\"line\">  Iron Man   </span><br><span class=\"line\">`;</span><br></pre></td></tr></table></figure></p>\n<p>在ES5版本中，我们需要添加\\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return `Hello $&#123;name&#125; !`;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。</p>\n<h3 id=\"什么是对象解构？\"><a href=\"#什么是对象解构？\" class=\"headerlink\" title=\"什么是对象解构？\"></a>什么是对象解构？</h3><p>对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const employee = &#123;</span><br><span class=\"line\">  firstName: &quot;Marko&quot;,</span><br><span class=\"line\">  lastName: &quot;Polo&quot;,</span><br><span class=\"line\">  position: &quot;Software Developer&quot;,</span><br><span class=\"line\">  yearHired: 2017</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var firstName = employee.firstName;</span><br><span class=\"line\">var lastName = employee.lastName;</span><br><span class=\"line\">var position = employee.position;</span><br><span class=\"line\">var yearHired = employee.yearHired;</span><br></pre></td></tr></table></figure></p>\n<p>使用解构方式语法就变得简洁多了：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; firstName, lastName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以为属性取别名：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let &#123; firstName: fName, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<p>当然如果属性值为 undefined 时，我们还可以指定默认值，但是属性为null时指定的默认值则不生效：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let &#123; firstName = &quot;Mark&quot;, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Set对象，它是如何工作的？\"><a href=\"#什么是Set对象，它是如何工作的？\" class=\"headerlink\" title=\"什么是Set对象，它是如何工作的？\"></a>什么是Set对象，它是如何工作的？</h3><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>\n<p>我们可以使用Set构造函数创建Set实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const set1 = new Set();</span><br><span class=\"line\">const set2 = new Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;e&quot;]);</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.add(&quot;f&quot;);</span><br><span class=\"line\">set2.add(&quot;g&quot;).add(&quot;h&quot;).add(&quot;i&quot;).add(&quot;j&quot;).add(&quot;k&quot;).add(&quot;k&quot;);</span><br><span class=\"line\">// 后一个“k”不会被添加到set对象中，因为它已经存在了</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用has方法检查Set实例中是否存在特定的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.has(&quot;a&quot;) // true</span><br><span class=\"line\">set2.has(&quot;z&quot;) // true</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用size属性获得Set实例的长度。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.size // returns 10</span><br></pre></td></tr></table></figure></p>\n<p>可以使用clear方法删除 Set 中的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.clear();</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用Set对象来删除数组中重复的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];</span><br><span class=\"line\">const uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></p>\n<p>另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。</p>\n<ul>\n<li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>\n<li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>\n</ul>\n<h3 id=\"什么是Proxy？\"><a href=\"#什么是Proxy？\" class=\"headerlink\" title=\"什么是Proxy？\"></a>什么是Proxy？</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n<h3 id=\"写一个通用的事件侦听器函数？\"><a href=\"#写一个通用的事件侦听器函数？\" class=\"headerlink\" title=\"写一个通用的事件侦听器函数？\"></a>写一个通用的事件侦听器函数？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const EventUtils = &#123;</span><br><span class=\"line\">  // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class=\"line\">  // 添加事件</span><br><span class=\"line\">  addEvent: function(element, type, handler) &#123;</span><br><span class=\"line\">    if (element.addEventListener) &#123;</span><br><span class=\"line\">      element.addEventListener(type, handler, false);</span><br><span class=\"line\">    &#125; else if (element.attachEvent) &#123;</span><br><span class=\"line\">      element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      element[&quot;on&quot; + type] = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 移除事件</span><br><span class=\"line\">  removeEvent: function(element, type, handler) &#123;</span><br><span class=\"line\">    if (element.removeEventListener) &#123;</span><br><span class=\"line\">      element.removeEventListener(type, handler, false);</span><br><span class=\"line\">    &#125; else if (element.detachEvent) &#123;</span><br><span class=\"line\">      element.detachEvent(&quot;on&quot; + type, handler);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      element[&quot;on&quot; + type] = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取事件目标</span><br><span class=\"line\">  getTarget: function(event) &#123;</span><br><span class=\"line\">    return event.target || event.srcElement;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span><br><span class=\"line\">  getEvent: function(event) &#123;</span><br><span class=\"line\">    return event || window.event;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span><br><span class=\"line\">  stopPropagation: function(event) &#123;</span><br><span class=\"line\">    if (event.stopPropagation) &#123;</span><br><span class=\"line\">      event.stopPropagation();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      event.cancelBubble = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 取消事件的默认行为</span><br><span class=\"line\">  preventDefault: function(event) &#123;</span><br><span class=\"line\">    if (event.preventDefault) &#123;</span><br><span class=\"line\">      event.preventDefault();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      event.returnValue = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\"><a href=\"#什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\" class=\"headerlink\" title=\"什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\"></a>什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</span><br><span class=\"line\">函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。</span><br><span class=\"line\">函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是高阶函数？\"><a href=\"#什么是高阶函数？\" class=\"headerlink\" title=\"什么是高阶函数？\"></a>什么是高阶函数？</h3><p>高阶函数只是将函数作为参数或返回值的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function higherOrderFunction(param,callback)&#123;</span><br><span class=\"line\">    return callback(param);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为什么函数被称为一等公民？\"><a href=\"#为什么函数被称为一等公民？\" class=\"headerlink\" title=\"为什么函数被称为一等公民？\"></a>为什么函数被称为一等公民？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:</span><br><span class=\"line\"></span><br><span class=\"line\">赋值（var func = function()&#123;&#125;）、</span><br><span class=\"line\">传参(function func(x,callback)&#123;callback();&#125;)、</span><br><span class=\"line\">返回(function()&#123;return function()&#123;&#125;&#125;)，</span><br><span class=\"line\"></span><br><span class=\"line\">这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-map-方法\"><a href=\"#手动实现Array-prototype-map-方法\" class=\"headerlink\" title=\"手动实现Array.prototype.map 方法\"></a>手动实现Array.prototype.map 方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</span><br><span class=\"line\">function map(arr, mapCallback) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== &apos;function&apos;) &#123; </span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let result = [];</span><br><span class=\"line\">    // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class=\"line\">    // 因为我们不想改变原始数组。</span><br><span class=\"line\">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      result.push(mapCallback(arr[i], i, arr)); </span><br><span class=\"line\">      // 将 mapCallback 返回的结果 push 到 result 数组中</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-filter方法\"><a href=\"#手动实现Array-prototype-filter方法\" class=\"headerlink\" title=\"手动实现Array.prototype.filter方法\"></a>手动实现Array.prototype.filter方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</span><br><span class=\"line\">function filter(arr, filterCallback) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== &apos;function&apos;) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let result = [];</span><br><span class=\"line\">     // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class=\"line\">     // 因为我们不想改变原始数组。</span><br><span class=\"line\">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      // 检查 filterCallback 的返回值是否是真值</span><br><span class=\"line\">      if (filterCallback(arr[i], i, arr)) &#123; </span><br><span class=\"line\">      // 如果条件为真，则将数组元素 push 到 result 中</span><br><span class=\"line\">        result.push(arr[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result; // return the result array</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-reduce方法\"><a href=\"#手动实现Array-prototype-reduce方法\" class=\"headerlink\" title=\"手动实现Array.prototype.reduce方法\"></a>手动实现Array.prototype.reduce方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。</span><br><span class=\"line\"></span><br><span class=\"line\">function reduce(arr, reduceCallback, initialValue) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== &apos;function&apos;) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span><br><span class=\"line\">    let hasInitialValue = initialValue !== undefined;</span><br><span class=\"line\">    let value = hasInitialValue ? initialValue : arr[0];</span><br><span class=\"line\">   、</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span><br><span class=\"line\">    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      value = reduceCallback(value, arr[i], i, arr); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"js的深浅拷贝\"><a href=\"#js的深浅拷贝\" class=\"headerlink\" title=\"js的深浅拷贝\"></a>js的深浅拷贝</h3><blockquote>\n<p>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。</p>\n<ul>\n<li>浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>\n<li>深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。<br>浅拷贝的实现方式：</li>\n<li>Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>\n<li>Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li>\n<li>拓展运算符…：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">    name: &quot;Jake&quot;,</span><br><span class=\"line\">    flag: &#123;</span><br><span class=\"line\">        title: &quot;better day by day&quot;,</span><br><span class=\"line\">        time: &quot;2020-05-31&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = &#123;...a&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>深拷贝的实现方式：</p>\n<ul>\n<li>乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）</li>\n<li>基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function cloneDeep(target,map = new WeakMap()) &#123;</span><br><span class=\"line\">  if(typeOf taret ===&apos;object&apos;)&#123;</span><br><span class=\"line\">     let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class=\"line\">      </span><br><span class=\"line\">     if(map.get(target)) &#123;</span><br><span class=\"line\">        return target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     map.set(target, cloneTarget);</span><br><span class=\"line\">     for(const key in target)&#123;</span><br><span class=\"line\">        cloneTarget[key] = cloneDeep(target[key], map);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return cloneTarget</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">       return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>终极版：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const mapTag = &apos;[object Map]&apos;;</span><br><span class=\"line\">const setTag = &apos;[object Set]&apos;;</span><br><span class=\"line\">const arrayTag = &apos;[object Array]&apos;;</span><br><span class=\"line\">const objectTag = &apos;[object Object]&apos;;</span><br><span class=\"line\">const argsTag = &apos;[object Arguments]&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const boolTag = &apos;[object Boolean]&apos;;</span><br><span class=\"line\">const dateTag = &apos;[object Date]&apos;;</span><br><span class=\"line\">const numberTag = &apos;[object Number]&apos;;</span><br><span class=\"line\">const stringTag = &apos;[object String]&apos;;</span><br><span class=\"line\">const symbolTag = &apos;[object Symbol]&apos;;</span><br><span class=\"line\">const errorTag = &apos;[object Error]&apos;;</span><br><span class=\"line\">const regexpTag = &apos;[object RegExp]&apos;;</span><br><span class=\"line\">const funcTag = &apos;[object Function]&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function forEach(array, iteratee) &#123;</span><br><span class=\"line\">    let index = -1;</span><br><span class=\"line\">    const length = array.length;</span><br><span class=\"line\">    while (++index &lt; length) &#123;</span><br><span class=\"line\">        iteratee(array[index], index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function isObject(target) &#123;</span><br><span class=\"line\">    const type = typeof target;</span><br><span class=\"line\">    return target !== null &amp;&amp; (type === &apos;object&apos; || type === &apos;function&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getType(target) &#123;</span><br><span class=\"line\">    return Object.prototype.toString.call(target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getInit(target) &#123;</span><br><span class=\"line\">    const Ctor = target.constructor;</span><br><span class=\"line\">    return new Ctor();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneSymbol(targe) &#123;</span><br><span class=\"line\">    return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneReg(targe) &#123;</span><br><span class=\"line\">    const reFlags = /\\w*$/;</span><br><span class=\"line\">    const result = new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class=\"line\">    result.lastIndex = targe.lastIndex;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneFunction(func) &#123;</span><br><span class=\"line\">    const bodyReg = /(?&lt;=&#123;)(.|\\n)+(?=&#125;)/m;</span><br><span class=\"line\">    const paramReg = /(?&lt;=\\().+(?=\\)\\s+&#123;)/;</span><br><span class=\"line\">    const funcString = func.toString();</span><br><span class=\"line\">    if (func.prototype) &#123;</span><br><span class=\"line\">        const param = paramReg.exec(funcString);</span><br><span class=\"line\">        const body = bodyReg.exec(funcString);</span><br><span class=\"line\">        if (body) &#123;</span><br><span class=\"line\">            if (param) &#123;</span><br><span class=\"line\">                const paramArr = param[0].split(&apos;,&apos;);</span><br><span class=\"line\">                return new Function(...paramArr, body[0]);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                return new Function(body[0]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return eval(funcString);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneOtherType(targe, type) &#123;</span><br><span class=\"line\">    const Ctor = targe.constructor;</span><br><span class=\"line\">    switch (type) &#123;</span><br><span class=\"line\">        case boolTag:</span><br><span class=\"line\">        case numberTag:</span><br><span class=\"line\">        case stringTag:</span><br><span class=\"line\">        case errorTag:</span><br><span class=\"line\">        case dateTag:</span><br><span class=\"line\">            return new Ctor(targe);</span><br><span class=\"line\">        case regexpTag:</span><br><span class=\"line\">            return cloneReg(targe);</span><br><span class=\"line\">        case symbolTag:</span><br><span class=\"line\">            return cloneSymbol(targe);</span><br><span class=\"line\">        case funcTag:</span><br><span class=\"line\">            return cloneFunction(targe);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function clone(target, map = new WeakMap()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆原始类型</span><br><span class=\"line\">    if (!isObject(target)) &#123;</span><br><span class=\"line\">        return target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化</span><br><span class=\"line\">    const type = getType(target);</span><br><span class=\"line\">    let cloneTarget;</span><br><span class=\"line\">    if (deepTag.includes(type)) &#123;</span><br><span class=\"line\">        cloneTarget = getInit(target, type);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return cloneOtherType(target, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 防止循环引用</span><br><span class=\"line\">    if (map.get(target)) &#123;</span><br><span class=\"line\">        return map.get(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map.set(target, cloneTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆set</span><br><span class=\"line\">    if (type === setTag) &#123;</span><br><span class=\"line\">        target.forEach(value =&gt; &#123;</span><br><span class=\"line\">            cloneTarget.add(clone(value, map));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return cloneTarget;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆map</span><br><span class=\"line\">    if (type === mapTag) &#123;</span><br><span class=\"line\">        target.forEach((value, key) =&gt; &#123;</span><br><span class=\"line\">            cloneTarget.set(key, clone(value, map));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return cloneTarget;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆对象和数组</span><br><span class=\"line\">    const keys = type === arrayTag ? undefined : Object.keys(target);</span><br><span class=\"line\">    forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class=\"line\">        if (keys) &#123;</span><br><span class=\"line\">            key = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cloneTarget[key] = clone(target[key], map);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return cloneTarget;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    clone</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"手写call、apply及bind函数\"><a href=\"#手写call、apply及bind函数\" class=\"headerlink\" title=\"手写call、apply及bind函数\"></a>手写call、apply及bind函数</h3><p>call 函数的实现步骤：</p>\n<ul>\n<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>3.处理传入的参数，截取第一个参数后的所有参数。</li>\n<li>4.将函数作为上下文对象的一个属性。</li>\n<li>5.使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>6.删除刚才新增的属性。</li>\n<li>7.返回结果。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// call函数实现</span><br><span class=\"line\">Function.prototype.myCall = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    console.error(&quot;type error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取参数</span><br><span class=\"line\">  let args = [...arguments].slice(1),</span><br><span class=\"line\">    result = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 判断 context 是否传入，如果未传入则设置为 window</span><br><span class=\"line\">  context = context || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将调用函数设为对象的方法</span><br><span class=\"line\">  context.fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用函数</span><br><span class=\"line\">  result = context.fn(...args);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将属性删除</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>apply 函数的实现步骤：</p>\n<ul>\n<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>将函数作为上下文对象的一个属性。</li>\n<li>判断参数值是否传入</li>\n<li>使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>删除刚才新增的属性</li>\n<li>返回结果<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// apply 函数实现</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.myApply = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象是否为函数</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    throw new TypeError(&quot;Error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  let result = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 判断 context 是否存在，如果未传入则为 window</span><br><span class=\"line\">  context = context || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将函数设为对象的方法</span><br><span class=\"line\">  context.fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用方法</span><br><span class=\"line\">  if (arguments[1]) &#123; </span><br><span class=\"line\">    result = context.fn(...arguments[1]);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    result = context.fn();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将属性删除</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>bind 函数的实现步骤：</p>\n<ul>\n<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>2.保存当前函数的引用，获取其余传入参数值。</li>\n<li>3.创建一个函数返回</li>\n<li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bind 函数实现</span><br><span class=\"line\">Function.prototype.myBind = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象是否为函数</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    throw new TypeError(&quot;Error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取参数</span><br><span class=\"line\">  var args = [...arguments].slice(1),</span><br><span class=\"line\">    fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  return function Fn() &#123;</span><br><span class=\"line\">    // 根据调用方式，传入不同绑定值</span><br><span class=\"line\">    return fn.apply(</span><br><span class=\"line\">      this instanceof Fn ? this : context,</span><br><span class=\"line\">      args.concat(...arguments)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"函数柯里化的实现\"><a href=\"#函数柯里化的实现\" class=\"headerlink\" title=\"函数柯里化的实现\"></a>函数柯里化的实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span><br><span class=\"line\"></span><br><span class=\"line\">function curry(fn, args) &#123;</span><br><span class=\"line\">  // 获取函数需要的参数长度</span><br><span class=\"line\">  let length = fn.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  args = args || [];</span><br><span class=\"line\"></span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    let subArgs = args.slice(0);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 拼接得到现有的所有参数</span><br><span class=\"line\">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class=\"line\">      subArgs.push(arguments[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class=\"line\">    if (subArgs.length &gt;= length) &#123;</span><br><span class=\"line\">      // 如果满足，执行函数</span><br><span class=\"line\">      return fn.apply(this, subArgs);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class=\"line\">      return curry.call(this, fn, subArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// es6 实现</span><br><span class=\"line\">function curry(fn, ...args) &#123;</span><br><span class=\"line\">  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"js模拟new操作符的实现\"><a href=\"#js模拟new操作符的实现\" class=\"headerlink\" title=\"js模拟new操作符的实现\"></a>js模拟new操作符的实现</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作：</p>\n<ol>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将步骤1新创建的对象作为this的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回this。<br>接下来我们看实现：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Dog(name, color, age) &#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.color = color;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype=&#123;</span><br><span class=\"line\">  getName: function() &#123;</span><br><span class=\"line\">    return this.name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var dog = new Dog(&apos;大黄&apos;, &apos;yellow&apos;, 3)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上面的代码相信不用解释，大家都懂。我们来看最后一行带new关键字的代码，按照上述的1,2,3,4步来解析new背后的操作。</p>\n<p>第一步：创建一个简单空对象<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：链接该对象到另一个对象（原型链）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 设置原型链</span><br><span class=\"line\">obj.__proto__ = Dog.prototype</span><br></pre></td></tr></table></figure></p>\n<p>第三步：将步骤1新创建的对象作为 this 的上下文<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// this指向obj对象</span><br><span class=\"line\">Dog.apply(obj, [&apos;大黄&apos;, &apos;yellow&apos;, 3])</span><br></pre></td></tr></table></figure></p>\n<p>第四步：如果该函数没有返回对象，则返回this<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 因为 Dog() 没有返回值，所以返回obj</span><br><span class=\"line\">var dog = obj</span><br><span class=\"line\">dog.getName() // &apos;大黄&apos;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是如果 Dog() 有 return 则返回 return的值<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var rtnObj = &#123;&#125;</span><br><span class=\"line\">function Dog(name, color, age) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  //返回一个对象</span><br><span class=\"line\">  return rtnObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var dog = new Dog(&apos;大黄&apos;, &apos;yellow&apos;, 3)</span><br><span class=\"line\">console.log(dog === rtnObj) // true</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们将以上步骤封装成一个对象实例化方法，即模拟new的操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function objectFactory()&#123;</span><br><span class=\"line\">    var obj = &#123;&#125;;</span><br><span class=\"line\">    //取得该方法的第一个参数(并删除第一个参数)，该参数是构造函数</span><br><span class=\"line\">    var Constructor = [].shift.apply(arguments);</span><br><span class=\"line\">    //将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法</span><br><span class=\"line\">    obj.__proto__ = Constructor.prototype;</span><br><span class=\"line\">    //取得构造函数的返回值</span><br><span class=\"line\">    var ret = Constructor.apply(obj, arguments);</span><br><span class=\"line\">    //如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象</span><br><span class=\"line\">    return typeof ret === &quot;object&quot; ? ret : obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是回调函数？回调函数有什么缺点\"><a href=\"#什么是回调函数？回调函数有什么缺点\" class=\"headerlink\" title=\"什么是回调函数？回调函数有什么缺点\"></a>什么是回调函数？回调函数有什么缺点</h3><p>回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。<br>在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。</p>\n<h3 id=\"Promise是什么，可以手写实现一下吗？\"><a href=\"#Promise是什么，可以手写实现一下吗？\" class=\"headerlink\" title=\"Promise是什么，可以手写实现一下吗？\"></a>Promise是什么，可以手写实现一下吗？</h3><p>Promise，翻译过来是承诺，承诺它过一段时间会给你一个结果。从编程讲Promise 是异步编程的一种解决方案。下面是Promise在MDN的相关说明：<br>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。<br>一个 Promise有以下几种状态:</p>\n<ul>\n<li>pending: 初始状态，既不是成功，也不是失败状态。</li>\n<li>fulfilled: 意味着操作成功完成。</li>\n<li>rejected: 意味着操作失败。<br>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 fulfilled/rejected 后，就不能再次改变。<br>可能光看概念大家不理解Promise，我们举个简单的栗子；<br>假如我有个女朋友，下周一是她生日，我答应她生日给她一个惊喜，那么从现在开始这个承诺就进入等待状态，等待下周一的到来，然后状态改变。如果下周一我如约给了女朋友惊喜，那么这个承诺的状态就会由pending切换为fulfilled，表示承诺成功兑现，一旦是这个结果了，就不会再有其他结果，即状态不会在发生改变；反之如果当天我因为工作太忙加班，把这事给忘了，说好的惊喜没有兑现，状态就会由pending切换为rejected，时间不可倒流，所以状态也不能再发生变化。<br>上一条我们说过Promise可以解决回调地狱的问题，没错，pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，一旦状态改变，Promise 对象的 then 方法就会被调用；否则就会触发 catch。我们将上一条回调地狱的代码改写一下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Promise((resolve，reject) =&gt; &#123;</span><br><span class=\"line\">     setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            console.log(1)</span><br><span class=\"line\">            resolve()</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;).then((res) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            console.log(2)</span><br><span class=\"line\">        &#125;,2000)</span><br><span class=\"line\">&#125;).then((res) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            console.log(3)</span><br><span class=\"line\">        &#125;,3000)</span><br><span class=\"line\">&#125;).catch((err) =&gt; &#123;</span><br><span class=\"line\">console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其实Promise也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。<br>手写版本<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myPromise(constructor)&#123;</span><br><span class=\"line\">    let self=this;</span><br><span class=\"line\">    self.status=&quot;pending&quot; //定义状态改变前的初始状态</span><br><span class=\"line\">    self.value=undefined;//定义状态为resolved的时候的状态</span><br><span class=\"line\">    self.reason=undefined;//定义状态为rejected的时候的状态</span><br><span class=\"line\">    function resolve(value)&#123;</span><br><span class=\"line\">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class=\"line\">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class=\"line\">          self.value=value;</span><br><span class=\"line\">          self.status=&quot;resolved&quot;;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function reject(reason)&#123;</span><br><span class=\"line\">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class=\"line\">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class=\"line\">          self.reason=reason;</span><br><span class=\"line\">          self.status=&quot;rejected&quot;;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //捕获构造异常</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">       constructor(resolve,reject);</span><br><span class=\"line\">    &#125;catch(e)&#123;</span><br><span class=\"line\">       reject(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 定义链式调用的then方法</span><br><span class=\"line\">myPromise.prototype.then=function(onFullfilled,onRejected)&#123;</span><br><span class=\"line\">   let self=this;</span><br><span class=\"line\">   switch(self.status)&#123;</span><br><span class=\"line\">      case &quot;resolved&quot;:</span><br><span class=\"line\">        onFullfilled(self.value);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      case &quot;rejected&quot;:</span><br><span class=\"line\">        onRejected(self.reason);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      default:       </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Iterator是什么，有什么作用？\"><a href=\"#Iterator是什么，有什么作用？\" class=\"headerlink\" title=\"Iterator是什么，有什么作用？\"></a>Iterator是什么，有什么作用？</h3><p>Iterator是理解第61条的先决知识<br>Iterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">    [Symbol.iterator]:function()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>[Symbol.iterator] 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。<br>迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据<br>每一次的 next 都会返回一个对象，该对象有两个属性</p>\n<ul>\n<li>value 代表想要获取的数据</li>\n<li>done 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束<br>Iterator 的作用有三个：</li>\n</ul>\n<ol>\n<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>\n<li>使得数据结构的成员能够按某种次序排列；</li>\n<li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。<br>遍历过程：</li>\n<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>\n<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>\n<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>\n<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。<br>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let arr = [&#123;num:1&#125;,2,3]</span><br><span class=\"line\">let it = arr[Symbol.iterator]() // 获取数组中的迭代器</span><br><span class=\"line\">console.log(it.next())  // &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span><br><span class=\"line\">console.log(it.next())  // &#123; value: 2, done: false &#125;</span><br><span class=\"line\">console.log(it.next())  // &#123; value: 3, done: false &#125;</span><br><span class=\"line\">console.log(it.next())  // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Generator函数是什么，有什么作用？\"><a href=\"#Generator函数是什么，有什么作用？\" class=\"headerlink\" title=\"Generator函数是什么，有什么作用？\"></a>Generator函数是什么，有什么作用？</h3><h3 id=\"什么是-async-await及其如何工作-有什么优缺点？\"><a href=\"#什么是-async-await及其如何工作-有什么优缺点？\" class=\"headerlink\" title=\"什么是 async/await及其如何工作,有什么优缺点？\"></a>什么是 async/await及其如何工作,有什么优缺点？</h3><h3 id=\"instanceof的原理是什么，如何实现\"><a href=\"#instanceof的原理是什么，如何实现\" class=\"headerlink\" title=\"instanceof的原理是什么，如何实现\"></a>instanceof的原理是什么，如何实现</h3><h3 id=\"js的节流与防抖\"><a href=\"#js的节流与防抖\" class=\"headerlink\" title=\"js的节流与防抖\"></a>js的节流与防抖</h3><h3 id=\"什么是设计模式？\"><a href=\"#什么是设计模式？\" class=\"headerlink\" title=\"什么是设计模式？\"></a>什么是设计模式？</h3><h3 id=\"9种前端常见的设计模式\"><a href=\"#9种前端常见的设计模式\" class=\"headerlink\" title=\"9种前端常见的设计模式\"></a>9种前端常见的设计模式</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"介绍一下js的数据类型有哪些-值是如何存储的\"><a href=\"#介绍一下js的数据类型有哪些-值是如何存储的\" class=\"headerlink\" title=\"介绍一下js的数据类型有哪些,值是如何存储的\"></a>介绍一下js的数据类型有哪些,值是如何存储的</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一共有8种数据类型，7种基本数据类型</span><br><span class=\"line\">String </span><br><span class=\"line\">Number </span><br><span class=\"line\">Boolean </span><br><span class=\"line\">Null </span><br><span class=\"line\">Undefined </span><br><span class=\"line\">Symbol（es6 新增类型，表示第一无二的值） </span><br><span class=\"line\">BigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）</span><br><span class=\"line\">Object（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）</span><br><span class=\"line\"></span><br><span class=\"line\">原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class=\"line\"></span><br><span class=\"line\">引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure>\n<h3 id=\"amp-amp-、-和-运算符分别能做什么\"><a href=\"#amp-amp-、-和-运算符分别能做什么\" class=\"headerlink\" title=\"&amp;&amp; 、 ||和!! 运算符分别能做什么\"></a>&amp;&amp; 、 ||和!! 运算符分别能做什么</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;&amp; 并且符，使用时两边的值结果都必须为true才返回true</span><br><span class=\"line\">|| 或者符，两边的值结果有一个为true最终判断结果就位true</span><br><span class=\"line\">!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）</span><br></pre></td></tr></table></figure>\n<h3 id=\"JS的数据类型的转换\"><a href=\"#JS的数据类型的转换\" class=\"headerlink\" title=\"JS的数据类型的转换\"></a>JS的数据类型的转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在 JS 中类型转换只有三种情况，分别是：</span><br><span class=\"line\"></span><br><span class=\"line\">- 转换为布尔值（调用Boolean()方法）</span><br><span class=\"line\">- 转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class=\"line\">- 转换为字符串（调用.toString()或者String()方法）</span><br><span class=\"line\"></span><br><span class=\"line\">null和underfined没有.toString方法</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\"><a href=\"#JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\" class=\"headerlink\" title=\"JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()\"></a>JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()</h3><blockquote>\n<p>（1）typeof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typeof 对于原始类型来说，除了 null 都可以显示正确的类型</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof 2);               // number</span><br><span class=\"line\">console.log(typeof true);            // boolean</span><br><span class=\"line\">console.log(typeof &apos;str&apos;);           // string</span><br><span class=\"line\">console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object</span><br><span class=\"line\">console.log(typeof function()&#123;&#125;);    // function</span><br><span class=\"line\">console.log(typeof &#123;&#125;);              // object</span><br><span class=\"line\">console.log(typeof undefined);       // undefined</span><br><span class=\"line\">console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object</span><br><span class=\"line\"></span><br><span class=\"line\">typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（2）instanceof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//重点</span><br><span class=\"line\">instanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断</span><br><span class=\"line\">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class=\"line\">其意思就是判断对象是否是某一数据类型（如Array）的实例</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(2 instanceof Number);                    // false</span><br><span class=\"line\">console.log(true instanceof Boolean);                // false </span><br><span class=\"line\">console.log(&apos;str&apos; instanceof String);                // false  </span><br><span class=\"line\">console.log([] instanceof Array);                    // true</span><br><span class=\"line\">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class=\"line\">console.log(&#123;&#125; instanceof Object);                   // true    </span><br><span class=\"line\">// console.log(undefined instanceof Undefined);      //报错</span><br><span class=\"line\">// console.log(null instanceof Null);                //报错</span><br><span class=\"line\">复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。</span><br><span class=\"line\">我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，&apos;str&apos;不是实例，所以判断值为false。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（3）constructor<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log((2).constructor === Number); // true</span><br><span class=\"line\">console.log((true).constructor === Boolean); // true</span><br><span class=\"line\">console.log((&apos;str&apos;).constructor === String); // true</span><br><span class=\"line\">console.log(([]).constructor === Array); // true</span><br><span class=\"line\">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class=\"line\">console.log((&#123;&#125;).constructor === Object); // true</span><br><span class=\"line\"></span><br><span class=\"line\">这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了</span><br><span class=\"line\"></span><br><span class=\"line\">function Fn()&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">Fn.prototype=new Array();</span><br><span class=\"line\"> </span><br><span class=\"line\">var f=new Fn();</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(f.constructor===Fn);    // false</span><br><span class=\"line\">console.log(f.constructor===Array); // true</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = Object.prototype.toString;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(a.call(2));</span><br><span class=\"line\">console.log(a.call(true));</span><br><span class=\"line\">console.log(a.call(&apos;str&apos;));</span><br><span class=\"line\">console.log(a.call([]));</span><br><span class=\"line\">console.log(a.call(function()&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(undefined));</span><br><span class=\"line\">console.log(a.call(null));</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"介绍-JS-有哪些内置对象？\"><a href=\"#介绍-JS-有哪些内置对象？\" class=\"headerlink\" title=\"介绍 JS 有哪些内置对象？\"></a>介绍 JS 有哪些内置对象？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class=\"line\">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class=\"line\"></span><br><span class=\"line\">标准内置对象的分类</span><br><span class=\"line\"></span><br><span class=\"line\">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Infinity、NaN、undefined、null 字面量</span><br><span class=\"line\"></span><br><span class=\"line\">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 eval()、parseFloat()、parseInt() 等</span><br><span class=\"line\"></span><br><span class=\"line\">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class=\"line\"></span><br><span class=\"line\">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Number、Math、Date</span><br><span class=\"line\"></span><br><span class=\"line\">（5）字符串，用来表示和操作字符串的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 String、RegExp</span><br><span class=\"line\"></span><br><span class=\"line\">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class=\"line\"></span><br><span class=\"line\">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Map、Set、WeakMap、WeakSet</span><br><span class=\"line\"></span><br><span class=\"line\">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 SIMD 等</span><br><span class=\"line\"></span><br><span class=\"line\">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 JSON 等</span><br><span class=\"line\"></span><br><span class=\"line\">（10）控制抽象对象</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Promise、Generator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（11）反射</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Reflect、Proxy</span><br><span class=\"line\"></span><br><span class=\"line\">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Intl、Intl.Collator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（13）WebAssembly</span><br><span class=\"line\"></span><br><span class=\"line\">（14）其他</span><br><span class=\"line\"></span><br><span class=\"line\">例如 arguments</span><br></pre></td></tr></table></figure>\n<h3 id=\"undefined-与-undeclared-的区别？\"><a href=\"#undefined-与-undeclared-的区别？\" class=\"headerlink\" title=\"undefined 与 undeclared 的区别？\"></a>undefined 与 undeclared 的区别？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。</span><br><span class=\"line\">对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ</span><br><span class=\"line\">eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</span><br></pre></td></tr></table></figure>\n<h3 id=\"null-和-undefined-的区别？\"><a href=\"#null-和-undefined-的区别？\" class=\"headerlink\" title=\"null 和 undefined 的区别？\"></a>null 和 undefined 的区别？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class=\"line\">undefined 代表的含义是未定义，</span><br><span class=\"line\">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class=\"line\">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class=\"line\">/*</span><br><span class=\"line\">    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，</span><br><span class=\"line\">    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class=\"line\">    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</span><br><span class=\"line\">*/</span><br><span class=\"line\">undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它</span><br><span class=\"line\">会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</span><br><span class=\"line\">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等</span><br><span class=\"line\">号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>\n<h3 id=\"和-的valueOf和toString的结果是什么？\"><a href=\"#和-的valueOf和toString的结果是什么？\" class=\"headerlink\" title=\"{}和[]的valueOf和toString的结果是什么？\"></a>{}和[]的valueOf和toString的结果是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Javascript-的作用域和作用域链？\"><a href=\"#Javascript-的作用域和作用域链？\" class=\"headerlink\" title=\"Javascript 的作用域和作用域链？\"></a>Javascript 的作用域和作用域链？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class=\"line\">【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</span><br></pre></td></tr></table></figure>\n<h3 id=\"javascript-创建对象的几种方式？\"><a href=\"#javascript-创建对象的几种方式？\" class=\"headerlink\" title=\"javascript 创建对象的几种方式？\"></a>javascript 创建对象的几种方式？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript-继承的几种实现方式？\"><a href=\"#JavaScript-继承的几种实现方式？\" class=\"headerlink\" title=\"JavaScript 继承的几种实现方式？\"></a>JavaScript 继承的几种实现方式？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生式组合继承的实现？\"><a href=\"#寄生式组合继承的实现？\" class=\"headerlink\" title=\"寄生式组合继承的实现？\"></a>寄生式组合继承的实现？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person</span><br><span class=\"line\">Student</span><br><span class=\"line\"></span><br><span class=\"line\">function Person(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Student(name, grade)&#123;</span><br><span class=\"line\">    Person.call(this,name);</span><br><span class=\"line\">    this.grade = grade;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype = Object.create(Person.prototype);</span><br><span class=\"line\">Student.prototype.constructor = Student;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.sayMyGrade = function() &#123;</span><br><span class=\"line\">  console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"谈谈你对this、call、apply和bind的理解\"><a href=\"#谈谈你对this、call、apply和bind的理解\" class=\"headerlink\" title=\"谈谈你对this、call、apply和bind的理解\"></a>谈谈你对this、call、apply和bind的理解</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结:</span><br><span class=\"line\">1. 在浏览器里，在全局范围内this 指向window对象；</span><br><span class=\"line\">2. 在函数中，this永远指向最后调用他的那个对象；</span><br><span class=\"line\">3. 构造函数中，this指向new出来的那个新的对象；</span><br><span class=\"line\">4. call、apply、bind中的this被强绑定在指定的那个对象上；</span><br><span class=\"line\">5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</span><br><span class=\"line\">6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</span><br><span class=\"line\"></span><br><span class=\"line\">区别:</span><br><span class=\"line\">- call/apply改变了函数的this上下文后马上执行该函数</span><br><span class=\"line\">- bind则是返回改变了上下文后的函数,不执行该函数</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript-原型，原型链？-有什么特点？\"><a href=\"#JavaScript-原型，原型链？-有什么特点？\" class=\"headerlink\" title=\"JavaScript 原型，原型链？ 有什么特点？\"></a>JavaScript 原型，原型链？ 有什么特点？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">prototype就是JS的原型，里面可以定义属性和方法</span><br><span class=\"line\">当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。</span><br><span class=\"line\">原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br></pre></td></tr></table></figure>\n<h3 id=\"js-获取原型的方法？\"><a href=\"#js-获取原型的方法？\" class=\"headerlink\" title=\"js 获取原型的方法？\"></a>js 获取原型的方法？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p.proto</span><br><span class=\"line\">p.constructor.prototype</span><br><span class=\"line\">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是闭包，为什么要用它？\"><a href=\"#什么是闭包，为什么要用它？\" class=\"headerlink\" title=\"什么是闭包，为什么要用它？\"></a>什么是闭包，为什么要用它？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">闭包是指有权访问另一个函数作用域内变量的函数</span><br><span class=\"line\">创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。</span><br><span class=\"line\"></span><br><span class=\"line\">闭包有两个常用的用途:</span><br><span class=\"line\">- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class=\"line\">- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</span><br><span class=\"line\"></span><br><span class=\"line\">function a()&#123;</span><br><span class=\"line\">    var n = 0;</span><br><span class=\"line\">    function add()&#123;</span><br><span class=\"line\">       n++;</span><br><span class=\"line\">       console.log(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span><br><span class=\"line\">a1();    //1</span><br><span class=\"line\">a1();    //2  第二次调用n变量还在内存中</span><br><span class=\"line\"></span><br><span class=\"line\">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是-DOM-和-BOM？\"><a href=\"#什么是-DOM-和-BOM？\" class=\"headerlink\" title=\"什么是 DOM 和 BOM？\"></a>什么是 DOM 和 BOM？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class=\"line\"></span><br><span class=\"line\">BOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM</span><br><span class=\"line\">的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）</span><br><span class=\"line\">对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati</span><br><span class=\"line\">on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对</span><br><span class=\"line\">象的子对象。</span><br></pre></td></tr></table></figure>\n<h3 id=\"三种事件模型是什么？\"><a href=\"#三种事件模型是什么？\" class=\"headerlink\" title=\"三种事件模型是什么？\"></a>三种事件模型是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class=\"line\">IE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class=\"line\">DOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件委托是什么？\"><a href=\"#事件委托是什么？\" class=\"headerlink\" title=\"事件委托是什么？\"></a>事件委托是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class=\"line\">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class=\"line\">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件传播\"><a href=\"#什么是事件传播\" class=\"headerlink\" title=\"什么是事件传播?\"></a>什么是事件传播?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。</span><br><span class=\"line\">事件传播有三个阶段：</span><br><span class=\"line\">1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class=\"line\">2. 目标阶段–事件已达到目标元素。</span><br><span class=\"line\">3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件捕获？\"><a href=\"#什么是事件捕获？\" class=\"headerlink\" title=\"什么是事件捕获？\"></a>什么是事件捕获？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----&gt; document----&gt; html----&gt; body ----&gt;目标元素</span><br><span class=\"line\"></span><br><span class=\"line\">html:</span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">js:</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件冒泡？\"><a href=\"#什么是事件冒泡？\" class=\"headerlink\" title=\"什么是事件冒泡？\"></a>什么是事件冒泡？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br><span class=\"line\">假设有如下的 HTML 结构：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">对应的JS代码：</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\"><a href=\"#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\" class=\"headerlink\" title=\"DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><p>（1）创建新节点<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">createDocumentFragment()    //创建一个DOM片段</span><br><span class=\"line\">createElement()   //创建一个具体的元素</span><br><span class=\"line\">createTextNode()   //创建一个文本节点</span><br></pre></td></tr></table></figure></p>\n<p>（2）添加、移除、替换、插入<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendChild(node)</span><br><span class=\"line\">removeChild(node)</span><br><span class=\"line\">replaceChild(new,old)</span><br><span class=\"line\">insertBefore(new,old)</span><br></pre></td></tr></table></figure></p>\n<p>（3）查找<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getElementById();</span><br><span class=\"line\">getElementsByName();</span><br><span class=\"line\">getElementsByTagName();</span><br><span class=\"line\">getElementsByClassName();</span><br><span class=\"line\">querySelector();</span><br><span class=\"line\">querySelectorAll();</span><br></pre></td></tr></table></figure></p>\n<p>（4）属性操作<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getAttribute(key);</span><br><span class=\"line\">setAttribute(key, value);</span><br><span class=\"line\">hasAttribute(key);</span><br><span class=\"line\">removeAttribute(key);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"js数组和对象有哪些原生方法-列举一下\"><a href=\"#js数组和对象有哪些原生方法-列举一下\" class=\"headerlink\" title=\"js数组和对象有哪些原生方法,列举一下\"></a>js数组和对象有哪些原生方法,列举一下</h3><p><img src=\"https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h3><h3 id=\"Ajax-是什么-如何创建一个-Ajax？\"><a href=\"#Ajax-是什么-如何创建一个-Ajax？\" class=\"headerlink\" title=\"Ajax 是什么? 如何创建一个 Ajax？\"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。<br>创建步骤：<br><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/17274125a4cf4d61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//1：创建Ajax对象</span><br><span class=\"line\">var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);    //兼容IE6及以下版本</span><br><span class=\"line\">//2：配置 Ajax请求地址</span><br><span class=\"line\">xhr.open(&apos;get&apos;,&apos;index.xml&apos;,true);</span><br><span class=\"line\">//3：发送请求</span><br><span class=\"line\">xhr.send(null); //严谨写法</span><br><span class=\"line\">//4:监听请求，接受响应</span><br><span class=\"line\">xhr.onreadysatechange = function()&#123;</span><br><span class=\"line\">    if(xhr.readySates == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304)&#123;</span><br><span class=\"line\">        console.log(xhr.responsetXML);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>promise封装实现<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// promise 封装实现：</span><br><span class=\"line\"></span><br><span class=\"line\">function getJSON(url) &#123;</span><br><span class=\"line\">  // 创建一个 promise 对象</span><br><span class=\"line\">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    let xhr = new XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 新建一个 http 请求</span><br><span class=\"line\">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置状态的监听函数</span><br><span class=\"line\">    xhr.onreadystatechange = function() &#123;</span><br><span class=\"line\">      if (this.readyState !== 4) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class=\"line\">      if (this.status === 200) &#123;</span><br><span class=\"line\">        resolve(this.response);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        reject(new Error(this.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置错误监听函数</span><br><span class=\"line\">    xhr.onerror = function() &#123;</span><br><span class=\"line\">      reject(new Error(this.statusText));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置响应的数据类型</span><br><span class=\"line\">    xhr.responseType = &quot;json&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置请求头信息</span><br><span class=\"line\">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 发送 http 请求</span><br><span class=\"line\">    xhr.send(null);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return promise;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"js-延迟加载的方式有哪些？\"><a href=\"#js-延迟加载的方式有哪些？\" class=\"headerlink\" title=\"js 延迟加载的方式有哪些？\"></a>js 延迟加载的方式有哪些？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class=\"line\">我了解到的几种方式是：</span><br><span class=\"line\"></span><br><span class=\"line\">将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class=\"line\">给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class=\"line\">给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class=\"line\">动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure>\n<h3 id=\"谈谈你对模块化开发的理解？\"><a href=\"#谈谈你对模块化开发的理解？\" class=\"headerlink\" title=\"谈谈你对模块化开发的理解？\"></a>谈谈你对模块化开发的理解？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念</span><br><span class=\"line\">，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class=\"line\">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污</span><br><span class=\"line\">染，并且模块间没有联系。</span><br><span class=\"line\">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所</span><br><span class=\"line\">有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class=\"line\">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure>\n<h3 id=\"js-的几种模块规范？\"><a href=\"#js-的几种模块规范？\" class=\"headerlink\" title=\"js 的几种模块规范？\"></a>js 的几种模块规范？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">js 中现在比较成熟的有四种模块加载方案：</span><br><span class=\"line\"></span><br><span class=\"line\">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class=\"line\">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class=\"line\">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class=\"line\">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</span><br></pre></td></tr></table></figure>\n<h3 id=\"AMD和CMD-规范的区别？\"><a href=\"#AMD和CMD-规范的区别？\" class=\"headerlink\" title=\"AMD和CMD 规范的区别？\"></a>AMD和CMD 规范的区别？</h3><p>它们之间的主要区别有两个方面。</p>\n<ol>\n<li>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</li>\n<li>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br> 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br> 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br> 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">  var a = require(&quot;./a&quot;);</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 此处略去 100 行</span><br><span class=\"line\">  var b = require(&quot;./b&quot;); // 依赖可以就近书写</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) &#123;</span><br><span class=\"line\">  // 依赖必须一开始就写好</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 此处略去 100 行</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\"><a href=\"#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\" class=\"headerlink\" title=\"ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><ul>\n<li>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>\n<li>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>\n</ul>\n<h3 id=\"requireJS的核心原理是什么？\"><a href=\"#requireJS的核心原理是什么？\" class=\"headerlink\" title=\"requireJS的核心原理是什么？\"></a>requireJS的核心原理是什么？</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p>\n<h3 id=\"谈谈JS的运行机制\"><a href=\"#谈谈JS的运行机制\" class=\"headerlink\" title=\"谈谈JS的运行机制\"></a>谈谈JS的运行机制</h3><ol>\n<li><p>js单线程<br>JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。</p>\n<blockquote>\n<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>\n</blockquote>\n</li>\n<li><p>js事件循环<br>js代码执行过程中会有很多任务，这些任务总的分成两类：</p>\n</li>\n</ol>\n<ul>\n<li>同步任务</li>\n<li>异步任务<br>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：<br><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/172744a7fa2853c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></li>\n</ul>\n<p>回答：</p>\n<ol>\n<li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li>\n<li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li>\n<li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li>\n<li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li>\n<li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li>\n</ol>\n<h3 id=\"arguments-的对象是什么？\"><a href=\"#arguments-的对象是什么？\" class=\"headerlink\" title=\"arguments 的对象是什么？\"></a>arguments 的对象是什么？</h3><p>arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。<br>我们可以使用Array.prototype.slice将arguments对象转换成一个数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function one() &#123;</span><br><span class=\"line\">  return Array.prototype.slice.call(arguments);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意:箭头函数中没有arguments对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function one() &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const two = function () &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const three = function three() &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const four = () =&gt; arguments;</span><br><span class=\"line\"></span><br><span class=\"line\">four(); // Throws an error  - arguments is not defined</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为什么在调用这个函数时，代码中的b会变成一个全局变量\"><a href=\"#为什么在调用这个函数时，代码中的b会变成一个全局变量\" class=\"headerlink\" title=\"为什么在调用这个函数时，代码中的b会变成一个全局变量?\"></a>为什么在调用这个函数时，代码中的b会变成一个全局变量?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a = b = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure>\n<p>原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a = (b = 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure></p>\n<p>首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。</p>\n<p>我们可以通过在赋值之前先声明变量来解决这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a,b;</span><br><span class=\"line\">  a = b = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"简单介绍一下V8引擎的垃圾回收机制\"><a href=\"#简单介绍一下V8引擎的垃圾回收机制\" class=\"headerlink\" title=\"简单介绍一下V8引擎的垃圾回收机制\"></a>简单介绍一下V8引擎的垃圾回收机制</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class=\"line\"></span><br><span class=\"line\">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class=\"line\"></span><br><span class=\"line\">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）如果对象不存活，则释放对象的空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class=\"line\"></span><br><span class=\"line\">新生代对象晋升到老生代有两个条件：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class=\"line\"></span><br><span class=\"line\">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"哪些操作会造成内存泄漏？\"><a href=\"#哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"哪些操作会造成内存泄漏？\"></a>哪些操作会造成内存泄漏？</h3><ul>\n<li>1.意外的全局变量</li>\n<li>2.被遗忘的计时器或回调函数</li>\n<li>3.脱离 DOM 的引用</li>\n<li><p>4.闭包</p>\n</li>\n<li><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p>\n</li>\n<li>第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>\n<li>第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>\n<li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>\n</ul>\n<h3 id=\"ECMAScript-是什么？\"><a href=\"#ECMAScript-是什么？\" class=\"headerlink\" title=\"ECMAScript 是什么？\"></a>ECMAScript 是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。</span><br><span class=\"line\">ECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件</span><br><span class=\"line\">只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。</span><br><span class=\"line\">javaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）</span><br><span class=\"line\">ECMAScript说什么JavaScript就得做什么！</span><br><span class=\"line\">JavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！</span><br><span class=\"line\">——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，</span><br><span class=\"line\">那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。</span><br></pre></td></tr></table></figure>\n<h3 id=\"ECMAScript-2015（ES6）有哪些新特性？\"><a href=\"#ECMAScript-2015（ES6）有哪些新特性？\" class=\"headerlink\" title=\"ECMAScript 2015（ES6）有哪些新特性？\"></a>ECMAScript 2015（ES6）有哪些新特性？</h3><ul>\n<li>块作用域</li>\n<li>类</li>\n<li>箭头函数</li>\n<li>模板字符串</li>\n<li>加强的对象字面</li>\n<li>对象解构</li>\n<li>Promise</li>\n<li>模块</li>\n<li>Symbol</li>\n<li>代理（proxy）Set</li>\n<li>函数默认参数</li>\n<li>rest 和展开</li>\n</ul>\n<h3 id=\"var-let和const的区别是什么？\"><a href=\"#var-let和const的区别是什么？\" class=\"headerlink\" title=\"var,let和const的区别是什么？\"></a>var,let和const的区别是什么？</h3><p>var声明的变量会挂载在window上，而let和const声明的变量不会：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\">console.log(a,window.a);    // 100 100</span><br><span class=\"line\"></span><br><span class=\"line\">let b = 10;</span><br><span class=\"line\">console.log(b,window.b);    // 10 undefined</span><br><span class=\"line\"></span><br><span class=\"line\">const c = 1;</span><br><span class=\"line\">console.log(c,window.c);    // 1 undefined</span><br></pre></td></tr></table></figure></p>\n<p>var声明变量存在变量提升，let和const不存在变量提升:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(a); // undefined  ===&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class=\"line\">var a = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b); // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class=\"line\">let b = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(c); // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br><span class=\"line\">const c = 10;</span><br></pre></td></tr></table></figure></p>\n<p>let和const声明形成块作用域<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">  var a = 100;</span><br><span class=\"line\">  let b = 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\">console.log(b)  // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class=\"line\"></span><br><span class=\"line\">-------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">  var a = 100;</span><br><span class=\"line\">  const c = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\">console.log(c)  // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br></pre></td></tr></table></figure></p>\n<p>同一作用域下let和const不能声明同名变量，而var可以<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\"></span><br><span class=\"line\">var a = 10;</span><br><span class=\"line\">console.log(a); // 10</span><br><span class=\"line\">-------------------------------------</span><br><span class=\"line\">let a = 100;</span><br><span class=\"line\">let a = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">//  控制台报错：Identifier &apos;a&apos; has already been declared  ===&gt; 标识符a已经被声明了。</span><br></pre></td></tr></table></figure></p>\n<p>暂存死区<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">    a = 10;</span><br><span class=\"line\">    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class=\"line\">    // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class=\"line\">    let a = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>const<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;1、一旦声明必须赋值,不能使用null占位。</span><br><span class=\"line\">*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;2、声明后不能再修改</span><br><span class=\"line\">*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;3、如果声明的是复合类型数据，可以修改其属性</span><br><span class=\"line\">*</span><br><span class=\"line\">* */</span><br><span class=\"line\"></span><br><span class=\"line\">const a = 100; </span><br><span class=\"line\"></span><br><span class=\"line\">const list = [];</span><br><span class=\"line\">list[0] = 10;</span><br><span class=\"line\">console.log(list);&amp;emsp;&amp;emsp;// [10]</span><br><span class=\"line\"></span><br><span class=\"line\">const obj = &#123;a:100&#125;;</span><br><span class=\"line\">obj.name = &apos;apple&apos;;</span><br><span class=\"line\">obj.a = 10000;</span><br><span class=\"line\">console.log(obj);&amp;emsp;&amp;emsp;// &#123;a:10000,name:&apos;apple&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是箭头函数？\"><a href=\"#什么是箭头函数？\" class=\"headerlink\" title=\"什么是箭头函数？\"></a>什么是箭头函数？</h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var getCurrentDate = function ()&#123;</span><br><span class=\"line\">  return new Date();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">const getCurrentDate = () =&gt; new Date();</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">const greet = (name) =&gt; `Hello $&#123;name&#125;`;</span><br><span class=\"line\">const greet2 = name =&gt; `Hello $&#123;name&#125;`;</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const getArgs = () =&gt; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">const getArgs2 = (...rest) =&gt; rest</span><br></pre></td></tr></table></figure></p>\n<p>箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const data = &#123;</span><br><span class=\"line\">  result: 0,</span><br><span class=\"line\">  nums: [1, 2, 3, 4, 5],</span><br><span class=\"line\">  computeResult() &#123;</span><br><span class=\"line\">    // 这里的“this”指的是“data”对象</span><br><span class=\"line\">    const addAll = () =&gt; &#123;</span><br><span class=\"line\">      return this.nums.reduce((total, cur) =&gt; total + cur, 0)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.result = addAll();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。</p>\n<h3 id=\"什么是类？\"><a href=\"#什么是类？\" class=\"headerlink\" title=\"什么是类？\"></a>什么是类？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是模板字符串？\"><a href=\"#什么是模板字符串？\" class=\"headerlink\" title=\"什么是模板字符串？\"></a>什么是模板字符串？</h3><p>模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var greet = &apos;Hi I\\&apos;m Mark&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">let greet = `Hi I&apos;m Mark`;</span><br></pre></td></tr></table></figure></p>\n<p>在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var lastWords = &apos;\\n&apos;</span><br><span class=\"line\">  + &apos;   I  \\n&apos;</span><br><span class=\"line\">  + &apos;   Am  \\n&apos;</span><br><span class=\"line\">  + &apos;Iron Man \\n&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">let lastWords = `</span><br><span class=\"line\">    I</span><br><span class=\"line\">    Am</span><br><span class=\"line\">  Iron Man   </span><br><span class=\"line\">`;</span><br></pre></td></tr></table></figure></p>\n<p>在ES5版本中，我们需要添加\\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return `Hello $&#123;name&#125; !`;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。</p>\n<h3 id=\"什么是对象解构？\"><a href=\"#什么是对象解构？\" class=\"headerlink\" title=\"什么是对象解构？\"></a>什么是对象解构？</h3><p>对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const employee = &#123;</span><br><span class=\"line\">  firstName: &quot;Marko&quot;,</span><br><span class=\"line\">  lastName: &quot;Polo&quot;,</span><br><span class=\"line\">  position: &quot;Software Developer&quot;,</span><br><span class=\"line\">  yearHired: 2017</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var firstName = employee.firstName;</span><br><span class=\"line\">var lastName = employee.lastName;</span><br><span class=\"line\">var position = employee.position;</span><br><span class=\"line\">var yearHired = employee.yearHired;</span><br></pre></td></tr></table></figure></p>\n<p>使用解构方式语法就变得简洁多了：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; firstName, lastName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以为属性取别名：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let &#123; firstName: fName, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<p>当然如果属性值为 undefined 时，我们还可以指定默认值，但是属性为null时指定的默认值则不生效：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let &#123; firstName = &quot;Mark&quot;, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Set对象，它是如何工作的？\"><a href=\"#什么是Set对象，它是如何工作的？\" class=\"headerlink\" title=\"什么是Set对象，它是如何工作的？\"></a>什么是Set对象，它是如何工作的？</h3><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>\n<p>我们可以使用Set构造函数创建Set实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const set1 = new Set();</span><br><span class=\"line\">const set2 = new Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;e&quot;]);</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.add(&quot;f&quot;);</span><br><span class=\"line\">set2.add(&quot;g&quot;).add(&quot;h&quot;).add(&quot;i&quot;).add(&quot;j&quot;).add(&quot;k&quot;).add(&quot;k&quot;);</span><br><span class=\"line\">// 后一个“k”不会被添加到set对象中，因为它已经存在了</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用has方法检查Set实例中是否存在特定的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.has(&quot;a&quot;) // true</span><br><span class=\"line\">set2.has(&quot;z&quot;) // true</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用size属性获得Set实例的长度。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.size // returns 10</span><br></pre></td></tr></table></figure></p>\n<p>可以使用clear方法删除 Set 中的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.clear();</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用Set对象来删除数组中重复的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];</span><br><span class=\"line\">const uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></p>\n<p>另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。</p>\n<ul>\n<li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>\n<li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>\n</ul>\n<h3 id=\"什么是Proxy？\"><a href=\"#什么是Proxy？\" class=\"headerlink\" title=\"什么是Proxy？\"></a>什么是Proxy？</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n<h3 id=\"写一个通用的事件侦听器函数？\"><a href=\"#写一个通用的事件侦听器函数？\" class=\"headerlink\" title=\"写一个通用的事件侦听器函数？\"></a>写一个通用的事件侦听器函数？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const EventUtils = &#123;</span><br><span class=\"line\">  // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class=\"line\">  // 添加事件</span><br><span class=\"line\">  addEvent: function(element, type, handler) &#123;</span><br><span class=\"line\">    if (element.addEventListener) &#123;</span><br><span class=\"line\">      element.addEventListener(type, handler, false);</span><br><span class=\"line\">    &#125; else if (element.attachEvent) &#123;</span><br><span class=\"line\">      element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      element[&quot;on&quot; + type] = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 移除事件</span><br><span class=\"line\">  removeEvent: function(element, type, handler) &#123;</span><br><span class=\"line\">    if (element.removeEventListener) &#123;</span><br><span class=\"line\">      element.removeEventListener(type, handler, false);</span><br><span class=\"line\">    &#125; else if (element.detachEvent) &#123;</span><br><span class=\"line\">      element.detachEvent(&quot;on&quot; + type, handler);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      element[&quot;on&quot; + type] = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取事件目标</span><br><span class=\"line\">  getTarget: function(event) &#123;</span><br><span class=\"line\">    return event.target || event.srcElement;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span><br><span class=\"line\">  getEvent: function(event) &#123;</span><br><span class=\"line\">    return event || window.event;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span><br><span class=\"line\">  stopPropagation: function(event) &#123;</span><br><span class=\"line\">    if (event.stopPropagation) &#123;</span><br><span class=\"line\">      event.stopPropagation();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      event.cancelBubble = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 取消事件的默认行为</span><br><span class=\"line\">  preventDefault: function(event) &#123;</span><br><span class=\"line\">    if (event.preventDefault) &#123;</span><br><span class=\"line\">      event.preventDefault();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      event.returnValue = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\"><a href=\"#什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\" class=\"headerlink\" title=\"什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\"></a>什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</span><br><span class=\"line\">函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。</span><br><span class=\"line\">函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是高阶函数？\"><a href=\"#什么是高阶函数？\" class=\"headerlink\" title=\"什么是高阶函数？\"></a>什么是高阶函数？</h3><p>高阶函数只是将函数作为参数或返回值的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function higherOrderFunction(param,callback)&#123;</span><br><span class=\"line\">    return callback(param);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为什么函数被称为一等公民？\"><a href=\"#为什么函数被称为一等公民？\" class=\"headerlink\" title=\"为什么函数被称为一等公民？\"></a>为什么函数被称为一等公民？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:</span><br><span class=\"line\"></span><br><span class=\"line\">赋值（var func = function()&#123;&#125;）、</span><br><span class=\"line\">传参(function func(x,callback)&#123;callback();&#125;)、</span><br><span class=\"line\">返回(function()&#123;return function()&#123;&#125;&#125;)，</span><br><span class=\"line\"></span><br><span class=\"line\">这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-map-方法\"><a href=\"#手动实现Array-prototype-map-方法\" class=\"headerlink\" title=\"手动实现Array.prototype.map 方法\"></a>手动实现Array.prototype.map 方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</span><br><span class=\"line\">function map(arr, mapCallback) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== &apos;function&apos;) &#123; </span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let result = [];</span><br><span class=\"line\">    // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class=\"line\">    // 因为我们不想改变原始数组。</span><br><span class=\"line\">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      result.push(mapCallback(arr[i], i, arr)); </span><br><span class=\"line\">      // 将 mapCallback 返回的结果 push 到 result 数组中</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-filter方法\"><a href=\"#手动实现Array-prototype-filter方法\" class=\"headerlink\" title=\"手动实现Array.prototype.filter方法\"></a>手动实现Array.prototype.filter方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</span><br><span class=\"line\">function filter(arr, filterCallback) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== &apos;function&apos;) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let result = [];</span><br><span class=\"line\">     // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class=\"line\">     // 因为我们不想改变原始数组。</span><br><span class=\"line\">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      // 检查 filterCallback 的返回值是否是真值</span><br><span class=\"line\">      if (filterCallback(arr[i], i, arr)) &#123; </span><br><span class=\"line\">      // 如果条件为真，则将数组元素 push 到 result 中</span><br><span class=\"line\">        result.push(arr[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result; // return the result array</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-reduce方法\"><a href=\"#手动实现Array-prototype-reduce方法\" class=\"headerlink\" title=\"手动实现Array.prototype.reduce方法\"></a>手动实现Array.prototype.reduce方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。</span><br><span class=\"line\"></span><br><span class=\"line\">function reduce(arr, reduceCallback, initialValue) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== &apos;function&apos;) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span><br><span class=\"line\">    let hasInitialValue = initialValue !== undefined;</span><br><span class=\"line\">    let value = hasInitialValue ? initialValue : arr[0];</span><br><span class=\"line\">   、</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span><br><span class=\"line\">    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      value = reduceCallback(value, arr[i], i, arr); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"js的深浅拷贝\"><a href=\"#js的深浅拷贝\" class=\"headerlink\" title=\"js的深浅拷贝\"></a>js的深浅拷贝</h3><blockquote>\n<p>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。</p>\n<ul>\n<li>浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>\n<li>深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。<br>浅拷贝的实现方式：</li>\n<li>Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>\n<li>Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li>\n<li>拓展运算符…：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">    name: &quot;Jake&quot;,</span><br><span class=\"line\">    flag: &#123;</span><br><span class=\"line\">        title: &quot;better day by day&quot;,</span><br><span class=\"line\">        time: &quot;2020-05-31&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = &#123;...a&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>深拷贝的实现方式：</p>\n<ul>\n<li>乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）</li>\n<li>基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function cloneDeep(target,map = new WeakMap()) &#123;</span><br><span class=\"line\">  if(typeOf taret ===&apos;object&apos;)&#123;</span><br><span class=\"line\">     let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class=\"line\">      </span><br><span class=\"line\">     if(map.get(target)) &#123;</span><br><span class=\"line\">        return target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     map.set(target, cloneTarget);</span><br><span class=\"line\">     for(const key in target)&#123;</span><br><span class=\"line\">        cloneTarget[key] = cloneDeep(target[key], map);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return cloneTarget</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">       return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>终极版：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const mapTag = &apos;[object Map]&apos;;</span><br><span class=\"line\">const setTag = &apos;[object Set]&apos;;</span><br><span class=\"line\">const arrayTag = &apos;[object Array]&apos;;</span><br><span class=\"line\">const objectTag = &apos;[object Object]&apos;;</span><br><span class=\"line\">const argsTag = &apos;[object Arguments]&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const boolTag = &apos;[object Boolean]&apos;;</span><br><span class=\"line\">const dateTag = &apos;[object Date]&apos;;</span><br><span class=\"line\">const numberTag = &apos;[object Number]&apos;;</span><br><span class=\"line\">const stringTag = &apos;[object String]&apos;;</span><br><span class=\"line\">const symbolTag = &apos;[object Symbol]&apos;;</span><br><span class=\"line\">const errorTag = &apos;[object Error]&apos;;</span><br><span class=\"line\">const regexpTag = &apos;[object RegExp]&apos;;</span><br><span class=\"line\">const funcTag = &apos;[object Function]&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function forEach(array, iteratee) &#123;</span><br><span class=\"line\">    let index = -1;</span><br><span class=\"line\">    const length = array.length;</span><br><span class=\"line\">    while (++index &lt; length) &#123;</span><br><span class=\"line\">        iteratee(array[index], index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function isObject(target) &#123;</span><br><span class=\"line\">    const type = typeof target;</span><br><span class=\"line\">    return target !== null &amp;&amp; (type === &apos;object&apos; || type === &apos;function&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getType(target) &#123;</span><br><span class=\"line\">    return Object.prototype.toString.call(target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getInit(target) &#123;</span><br><span class=\"line\">    const Ctor = target.constructor;</span><br><span class=\"line\">    return new Ctor();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneSymbol(targe) &#123;</span><br><span class=\"line\">    return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneReg(targe) &#123;</span><br><span class=\"line\">    const reFlags = /\\w*$/;</span><br><span class=\"line\">    const result = new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class=\"line\">    result.lastIndex = targe.lastIndex;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneFunction(func) &#123;</span><br><span class=\"line\">    const bodyReg = /(?&lt;=&#123;)(.|\\n)+(?=&#125;)/m;</span><br><span class=\"line\">    const paramReg = /(?&lt;=\\().+(?=\\)\\s+&#123;)/;</span><br><span class=\"line\">    const funcString = func.toString();</span><br><span class=\"line\">    if (func.prototype) &#123;</span><br><span class=\"line\">        const param = paramReg.exec(funcString);</span><br><span class=\"line\">        const body = bodyReg.exec(funcString);</span><br><span class=\"line\">        if (body) &#123;</span><br><span class=\"line\">            if (param) &#123;</span><br><span class=\"line\">                const paramArr = param[0].split(&apos;,&apos;);</span><br><span class=\"line\">                return new Function(...paramArr, body[0]);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                return new Function(body[0]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return eval(funcString);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneOtherType(targe, type) &#123;</span><br><span class=\"line\">    const Ctor = targe.constructor;</span><br><span class=\"line\">    switch (type) &#123;</span><br><span class=\"line\">        case boolTag:</span><br><span class=\"line\">        case numberTag:</span><br><span class=\"line\">        case stringTag:</span><br><span class=\"line\">        case errorTag:</span><br><span class=\"line\">        case dateTag:</span><br><span class=\"line\">            return new Ctor(targe);</span><br><span class=\"line\">        case regexpTag:</span><br><span class=\"line\">            return cloneReg(targe);</span><br><span class=\"line\">        case symbolTag:</span><br><span class=\"line\">            return cloneSymbol(targe);</span><br><span class=\"line\">        case funcTag:</span><br><span class=\"line\">            return cloneFunction(targe);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function clone(target, map = new WeakMap()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆原始类型</span><br><span class=\"line\">    if (!isObject(target)) &#123;</span><br><span class=\"line\">        return target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化</span><br><span class=\"line\">    const type = getType(target);</span><br><span class=\"line\">    let cloneTarget;</span><br><span class=\"line\">    if (deepTag.includes(type)) &#123;</span><br><span class=\"line\">        cloneTarget = getInit(target, type);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return cloneOtherType(target, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 防止循环引用</span><br><span class=\"line\">    if (map.get(target)) &#123;</span><br><span class=\"line\">        return map.get(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map.set(target, cloneTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆set</span><br><span class=\"line\">    if (type === setTag) &#123;</span><br><span class=\"line\">        target.forEach(value =&gt; &#123;</span><br><span class=\"line\">            cloneTarget.add(clone(value, map));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return cloneTarget;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆map</span><br><span class=\"line\">    if (type === mapTag) &#123;</span><br><span class=\"line\">        target.forEach((value, key) =&gt; &#123;</span><br><span class=\"line\">            cloneTarget.set(key, clone(value, map));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return cloneTarget;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆对象和数组</span><br><span class=\"line\">    const keys = type === arrayTag ? undefined : Object.keys(target);</span><br><span class=\"line\">    forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class=\"line\">        if (keys) &#123;</span><br><span class=\"line\">            key = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cloneTarget[key] = clone(target[key], map);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return cloneTarget;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    clone</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"手写call、apply及bind函数\"><a href=\"#手写call、apply及bind函数\" class=\"headerlink\" title=\"手写call、apply及bind函数\"></a>手写call、apply及bind函数</h3><p>call 函数的实现步骤：</p>\n<ul>\n<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>3.处理传入的参数，截取第一个参数后的所有参数。</li>\n<li>4.将函数作为上下文对象的一个属性。</li>\n<li>5.使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>6.删除刚才新增的属性。</li>\n<li>7.返回结果。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// call函数实现</span><br><span class=\"line\">Function.prototype.myCall = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    console.error(&quot;type error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取参数</span><br><span class=\"line\">  let args = [...arguments].slice(1),</span><br><span class=\"line\">    result = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 判断 context 是否传入，如果未传入则设置为 window</span><br><span class=\"line\">  context = context || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将调用函数设为对象的方法</span><br><span class=\"line\">  context.fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用函数</span><br><span class=\"line\">  result = context.fn(...args);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将属性删除</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>apply 函数的实现步骤：</p>\n<ul>\n<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>将函数作为上下文对象的一个属性。</li>\n<li>判断参数值是否传入</li>\n<li>使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>删除刚才新增的属性</li>\n<li>返回结果<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// apply 函数实现</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.myApply = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象是否为函数</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    throw new TypeError(&quot;Error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  let result = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 判断 context 是否存在，如果未传入则为 window</span><br><span class=\"line\">  context = context || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将函数设为对象的方法</span><br><span class=\"line\">  context.fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用方法</span><br><span class=\"line\">  if (arguments[1]) &#123; </span><br><span class=\"line\">    result = context.fn(...arguments[1]);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    result = context.fn();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将属性删除</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>bind 函数的实现步骤：</p>\n<ul>\n<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>2.保存当前函数的引用，获取其余传入参数值。</li>\n<li>3.创建一个函数返回</li>\n<li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bind 函数实现</span><br><span class=\"line\">Function.prototype.myBind = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象是否为函数</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    throw new TypeError(&quot;Error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取参数</span><br><span class=\"line\">  var args = [...arguments].slice(1),</span><br><span class=\"line\">    fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  return function Fn() &#123;</span><br><span class=\"line\">    // 根据调用方式，传入不同绑定值</span><br><span class=\"line\">    return fn.apply(</span><br><span class=\"line\">      this instanceof Fn ? this : context,</span><br><span class=\"line\">      args.concat(...arguments)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"函数柯里化的实现\"><a href=\"#函数柯里化的实现\" class=\"headerlink\" title=\"函数柯里化的实现\"></a>函数柯里化的实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span><br><span class=\"line\"></span><br><span class=\"line\">function curry(fn, args) &#123;</span><br><span class=\"line\">  // 获取函数需要的参数长度</span><br><span class=\"line\">  let length = fn.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  args = args || [];</span><br><span class=\"line\"></span><br><span class=\"line\">  return function() &#123;</span><br><span class=\"line\">    let subArgs = args.slice(0);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 拼接得到现有的所有参数</span><br><span class=\"line\">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class=\"line\">      subArgs.push(arguments[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class=\"line\">    if (subArgs.length &gt;= length) &#123;</span><br><span class=\"line\">      // 如果满足，执行函数</span><br><span class=\"line\">      return fn.apply(this, subArgs);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class=\"line\">      return curry.call(this, fn, subArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// es6 实现</span><br><span class=\"line\">function curry(fn, ...args) &#123;</span><br><span class=\"line\">  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"js模拟new操作符的实现\"><a href=\"#js模拟new操作符的实现\" class=\"headerlink\" title=\"js模拟new操作符的实现\"></a>js模拟new操作符的实现</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作：</p>\n<ol>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将步骤1新创建的对象作为this的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回this。<br>接下来我们看实现：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Dog(name, color, age) &#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.color = color;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype=&#123;</span><br><span class=\"line\">  getName: function() &#123;</span><br><span class=\"line\">    return this.name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var dog = new Dog(&apos;大黄&apos;, &apos;yellow&apos;, 3)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上面的代码相信不用解释，大家都懂。我们来看最后一行带new关键字的代码，按照上述的1,2,3,4步来解析new背后的操作。</p>\n<p>第一步：创建一个简单空对象<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>第二步：链接该对象到另一个对象（原型链）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 设置原型链</span><br><span class=\"line\">obj.__proto__ = Dog.prototype</span><br></pre></td></tr></table></figure></p>\n<p>第三步：将步骤1新创建的对象作为 this 的上下文<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// this指向obj对象</span><br><span class=\"line\">Dog.apply(obj, [&apos;大黄&apos;, &apos;yellow&apos;, 3])</span><br></pre></td></tr></table></figure></p>\n<p>第四步：如果该函数没有返回对象，则返回this<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 因为 Dog() 没有返回值，所以返回obj</span><br><span class=\"line\">var dog = obj</span><br><span class=\"line\">dog.getName() // &apos;大黄&apos;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是如果 Dog() 有 return 则返回 return的值<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var rtnObj = &#123;&#125;</span><br><span class=\"line\">function Dog(name, color, age) &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  //返回一个对象</span><br><span class=\"line\">  return rtnObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var dog = new Dog(&apos;大黄&apos;, &apos;yellow&apos;, 3)</span><br><span class=\"line\">console.log(dog === rtnObj) // true</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们将以上步骤封装成一个对象实例化方法，即模拟new的操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function objectFactory()&#123;</span><br><span class=\"line\">    var obj = &#123;&#125;;</span><br><span class=\"line\">    //取得该方法的第一个参数(并删除第一个参数)，该参数是构造函数</span><br><span class=\"line\">    var Constructor = [].shift.apply(arguments);</span><br><span class=\"line\">    //将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法</span><br><span class=\"line\">    obj.__proto__ = Constructor.prototype;</span><br><span class=\"line\">    //取得构造函数的返回值</span><br><span class=\"line\">    var ret = Constructor.apply(obj, arguments);</span><br><span class=\"line\">    //如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象</span><br><span class=\"line\">    return typeof ret === &quot;object&quot; ? ret : obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是回调函数？回调函数有什么缺点\"><a href=\"#什么是回调函数？回调函数有什么缺点\" class=\"headerlink\" title=\"什么是回调函数？回调函数有什么缺点\"></a>什么是回调函数？回调函数有什么缺点</h3><p>回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。<br>在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。</p>\n<h3 id=\"Promise是什么，可以手写实现一下吗？\"><a href=\"#Promise是什么，可以手写实现一下吗？\" class=\"headerlink\" title=\"Promise是什么，可以手写实现一下吗？\"></a>Promise是什么，可以手写实现一下吗？</h3><p>Promise，翻译过来是承诺，承诺它过一段时间会给你一个结果。从编程讲Promise 是异步编程的一种解决方案。下面是Promise在MDN的相关说明：<br>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。<br>一个 Promise有以下几种状态:</p>\n<ul>\n<li>pending: 初始状态，既不是成功，也不是失败状态。</li>\n<li>fulfilled: 意味着操作成功完成。</li>\n<li>rejected: 意味着操作失败。<br>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 fulfilled/rejected 后，就不能再次改变。<br>可能光看概念大家不理解Promise，我们举个简单的栗子；<br>假如我有个女朋友，下周一是她生日，我答应她生日给她一个惊喜，那么从现在开始这个承诺就进入等待状态，等待下周一的到来，然后状态改变。如果下周一我如约给了女朋友惊喜，那么这个承诺的状态就会由pending切换为fulfilled，表示承诺成功兑现，一旦是这个结果了，就不会再有其他结果，即状态不会在发生改变；反之如果当天我因为工作太忙加班，把这事给忘了，说好的惊喜没有兑现，状态就会由pending切换为rejected，时间不可倒流，所以状态也不能再发生变化。<br>上一条我们说过Promise可以解决回调地狱的问题，没错，pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，一旦状态改变，Promise 对象的 then 方法就会被调用；否则就会触发 catch。我们将上一条回调地狱的代码改写一下：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Promise((resolve，reject) =&gt; &#123;</span><br><span class=\"line\">     setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            console.log(1)</span><br><span class=\"line\">            resolve()</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;).then((res) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            console.log(2)</span><br><span class=\"line\">        &#125;,2000)</span><br><span class=\"line\">&#125;).then((res) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            console.log(3)</span><br><span class=\"line\">        &#125;,3000)</span><br><span class=\"line\">&#125;).catch((err) =&gt; &#123;</span><br><span class=\"line\">console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其实Promise也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。<br>手写版本<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myPromise(constructor)&#123;</span><br><span class=\"line\">    let self=this;</span><br><span class=\"line\">    self.status=&quot;pending&quot; //定义状态改变前的初始状态</span><br><span class=\"line\">    self.value=undefined;//定义状态为resolved的时候的状态</span><br><span class=\"line\">    self.reason=undefined;//定义状态为rejected的时候的状态</span><br><span class=\"line\">    function resolve(value)&#123;</span><br><span class=\"line\">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class=\"line\">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class=\"line\">          self.value=value;</span><br><span class=\"line\">          self.status=&quot;resolved&quot;;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function reject(reason)&#123;</span><br><span class=\"line\">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class=\"line\">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class=\"line\">          self.reason=reason;</span><br><span class=\"line\">          self.status=&quot;rejected&quot;;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //捕获构造异常</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">       constructor(resolve,reject);</span><br><span class=\"line\">    &#125;catch(e)&#123;</span><br><span class=\"line\">       reject(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 定义链式调用的then方法</span><br><span class=\"line\">myPromise.prototype.then=function(onFullfilled,onRejected)&#123;</span><br><span class=\"line\">   let self=this;</span><br><span class=\"line\">   switch(self.status)&#123;</span><br><span class=\"line\">      case &quot;resolved&quot;:</span><br><span class=\"line\">        onFullfilled(self.value);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      case &quot;rejected&quot;:</span><br><span class=\"line\">        onRejected(self.reason);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      default:       </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Iterator是什么，有什么作用？\"><a href=\"#Iterator是什么，有什么作用？\" class=\"headerlink\" title=\"Iterator是什么，有什么作用？\"></a>Iterator是什么，有什么作用？</h3><p>Iterator是理解第61条的先决知识<br>Iterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">    [Symbol.iterator]:function()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>[Symbol.iterator] 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。<br>迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据<br>每一次的 next 都会返回一个对象，该对象有两个属性</p>\n<ul>\n<li>value 代表想要获取的数据</li>\n<li>done 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束<br>Iterator 的作用有三个：</li>\n</ul>\n<ol>\n<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>\n<li>使得数据结构的成员能够按某种次序排列；</li>\n<li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。<br>遍历过程：</li>\n<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>\n<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>\n<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>\n<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。<br>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let arr = [&#123;num:1&#125;,2,3]</span><br><span class=\"line\">let it = arr[Symbol.iterator]() // 获取数组中的迭代器</span><br><span class=\"line\">console.log(it.next())  // &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span><br><span class=\"line\">console.log(it.next())  // &#123; value: 2, done: false &#125;</span><br><span class=\"line\">console.log(it.next())  // &#123; value: 3, done: false &#125;</span><br><span class=\"line\">console.log(it.next())  // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Generator函数是什么，有什么作用？\"><a href=\"#Generator函数是什么，有什么作用？\" class=\"headerlink\" title=\"Generator函数是什么，有什么作用？\"></a>Generator函数是什么，有什么作用？</h3><h3 id=\"什么是-async-await及其如何工作-有什么优缺点？\"><a href=\"#什么是-async-await及其如何工作-有什么优缺点？\" class=\"headerlink\" title=\"什么是 async/await及其如何工作,有什么优缺点？\"></a>什么是 async/await及其如何工作,有什么优缺点？</h3><h3 id=\"instanceof的原理是什么，如何实现\"><a href=\"#instanceof的原理是什么，如何实现\" class=\"headerlink\" title=\"instanceof的原理是什么，如何实现\"></a>instanceof的原理是什么，如何实现</h3><h3 id=\"js的节流与防抖\"><a href=\"#js的节流与防抖\" class=\"headerlink\" title=\"js的节流与防抖\"></a>js的节流与防抖</h3><h3 id=\"什么是设计模式？\"><a href=\"#什么是设计模式？\" class=\"headerlink\" title=\"什么是设计模式？\"></a>什么是设计模式？</h3><h3 id=\"9种前端常见的设计模式\"><a href=\"#9种前端常见的设计模式\" class=\"headerlink\" title=\"9种前端常见的设计模式\"></a>9种前端常见的设计模式</h3>"},{"title":"React.memo() 使用","date":"2021-03-11T08:34:02.000Z","_content":"\n\n\n## React.memo()\n> 与PureComponent功能相似，只不过创造==纯函数==组件使用\n\n\n> React.memo()可接受2个参数，第一个参数为纯函数的组件，第二个参数用于对比props控制是否刷新，与shouldComponentUpdate()功能类似。\n\n\n```\nimport React from \"react\";\n\n\nfunction Child({seconds}){\n    console.log('I am rendering');\n    return (\n        <div>I am update every {seconds} seconds</div>\n    )\n};\n\n\nfunction areEqual(prevProps, nextProps) {\n    if(prevProps.seconds===nextProps.seconds){\n        return true\n    }else {\n        return false\n    }\n\n\n}\nexport default React.memo(Child,areEqual)\n```\n\n","source":"_posts/React.memo() 使用.md","raw":"---\ntitle: React.memo() 使用\ndate: 2021-03-11 16:34:02\ntags: [前端, react]\ncategories: 技术\n---\n\n\n\n## React.memo()\n> 与PureComponent功能相似，只不过创造==纯函数==组件使用\n\n\n> React.memo()可接受2个参数，第一个参数为纯函数的组件，第二个参数用于对比props控制是否刷新，与shouldComponentUpdate()功能类似。\n\n\n```\nimport React from \"react\";\n\n\nfunction Child({seconds}){\n    console.log('I am rendering');\n    return (\n        <div>I am update every {seconds} seconds</div>\n    )\n};\n\n\nfunction areEqual(prevProps, nextProps) {\n    if(prevProps.seconds===nextProps.seconds){\n        return true\n    }else {\n        return false\n    }\n\n\n}\nexport default React.memo(Child,areEqual)\n```\n\n","slug":"React.memo() 使用","published":1,"updated":"2021-03-11T08:36:04.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm4m9zff0000zdwhwejzddrm","content":"<h2 id=\"React-memo\"><a href=\"#React-memo\" class=\"headerlink\" title=\"React.memo()\"></a>React.memo()</h2><blockquote>\n<p>与PureComponent功能相似，只不过创造==纯函数==组件使用</p>\n</blockquote>\n<blockquote>\n<p>React.memo()可接受2个参数，第一个参数为纯函数的组件，第二个参数用于对比props控制是否刷新，与shouldComponentUpdate()功能类似。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function Child(&#123;seconds&#125;)&#123;</span><br><span class=\"line\">    console.log(&apos;I am rendering&apos;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;I am update every &#123;seconds&#125; seconds&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function areEqual(prevProps, nextProps) &#123;</span><br><span class=\"line\">    if(prevProps.seconds===nextProps.seconds)&#123;</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default React.memo(Child,areEqual)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React-memo\"><a href=\"#React-memo\" class=\"headerlink\" title=\"React.memo()\"></a>React.memo()</h2><blockquote>\n<p>与PureComponent功能相似，只不过创造==纯函数==组件使用</p>\n</blockquote>\n<blockquote>\n<p>React.memo()可接受2个参数，第一个参数为纯函数的组件，第二个参数用于对比props控制是否刷新，与shouldComponentUpdate()功能类似。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function Child(&#123;seconds&#125;)&#123;</span><br><span class=\"line\">    console.log(&apos;I am rendering&apos;);</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;I am update every &#123;seconds&#125; seconds&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function areEqual(prevProps, nextProps) &#123;</span><br><span class=\"line\">    if(prevProps.seconds===nextProps.seconds)&#123;</span><br><span class=\"line\">        return true</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default React.memo(Child,areEqual)</span><br></pre></td></tr></table></figure>\n"},{"title":"高阶组件","date":"2021-03-11T08:34:02.000Z","_content":"\n## 高阶组件\n> 高阶组件内部UI部分还是使用传入的组件一样，只不过内部属性（props）会传入到被高阶的组件内使用，好处就是逻辑代码复用\n\n\n```\n\n\nexport default function withTimer(WrappedComponent){\n    return class extends React.Component{\n        state = {\n            time: new Date()\n        }\n        componentDidMount(){\n            const self = this;\n            this.timerId = setInterval(()=>{\n                self.setState({\n                    time: new Date()\n                });\n            },1000);\n        }\n        componentWillUnmount(){\n            clearInterval(this.timerId);\n        }\n        render(){\n            return (\n                <WrappedComponent time={this.state.time} {...this.props} />\n            )\n        }\n    }\n}\n\n","source":"_posts/高阶组件.md","raw":"---\ntitle: 高阶组件\ndate: 2021-03-11 16:34:02\ntags: [前端, react]\ncategories: 技术\n---\n\n## 高阶组件\n> 高阶组件内部UI部分还是使用传入的组件一样，只不过内部属性（props）会传入到被高阶的组件内使用，好处就是逻辑代码复用\n\n\n```\n\n\nexport default function withTimer(WrappedComponent){\n    return class extends React.Component{\n        state = {\n            time: new Date()\n        }\n        componentDidMount(){\n            const self = this;\n            this.timerId = setInterval(()=>{\n                self.setState({\n                    time: new Date()\n                });\n            },1000);\n        }\n        componentWillUnmount(){\n            clearInterval(this.timerId);\n        }\n        render(){\n            return (\n                <WrappedComponent time={this.state.time} {...this.props} />\n            )\n        }\n    }\n}\n\n","slug":"高阶组件","published":1,"updated":"2021-03-11T08:41:05.979Z","_id":"ckm4mergf0000fxwhog8egn3f","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h2><blockquote>\n<p>高阶组件内部UI部分还是使用传入的组件一样，只不过内部属性（props）会传入到被高阶的组件内使用，好处就是逻辑代码复用</p>\n</blockquote>\n<p><code>`</code></p>\n<p>export default function withTimer(WrappedComponent){<br>    return class extends React.Component{<br>        state = {<br>            time: new Date()<br>        }<br>        componentDidMount(){<br>            const self = this;<br>            this.timerId = setInterval(()=&gt;{<br>                self.setState({<br>                    time: new Date()<br>                });<br>            },1000);<br>        }<br>        componentWillUnmount(){<br>            clearInterval(this.timerId);<br>        }<br>        render(){<br>            return (<br>                <wrappedcomponent time=\"{this.state.time}\" {...this.props}><br>            )<br>        }<br>    }<br>}</wrappedcomponent></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h2><blockquote>\n<p>高阶组件内部UI部分还是使用传入的组件一样，只不过内部属性（props）会传入到被高阶的组件内使用，好处就是逻辑代码复用</p>\n</blockquote>\n<p><code>`</code></p>\n<p>export default function withTimer(WrappedComponent){<br>    return class extends React.Component{<br>        state = {<br>            time: new Date()<br>        }<br>        componentDidMount(){<br>            const self = this;<br>            this.timerId = setInterval(()=&gt;{<br>                self.setState({<br>                    time: new Date()<br>                });<br>            },1000);<br>        }<br>        componentWillUnmount(){<br>            clearInterval(this.timerId);<br>        }<br>        render(){<br>            return (<br>                <wrappedcomponent time=\"{this.state.time}\" {...this.props}><br>            )<br>        }<br>    }<br>}</wrappedcomponent></p>\n"},{"title":"海量数据优化-时间分片，虚拟列表","date":"2021-03-11T11:11:00.000Z","_content":"\n\n\n## 时间分片\n\n\n> 时间分片的概念，就是一次性渲染大量数据，初始化的时候会出现卡顿等现象。我们必须要明白的一个道理，js执行永远要比dom渲染快的多。 ，所以对于大量的数据，一次性渲染，容易造成卡顿，卡死的情况。\n\n\n```\n//普通方法下渲染时间在5s左右\nclass Index extends React.Component<any,any>{\n    state={\n       list: []\n    }\n    handerClick=()=>{\n       let starTime = new Date().getTime()\n       this.setState({\n           list: new Array(40000).fill(0)\n       },()=>{\n          const end =  new Date().getTime()\n          console.log( (end - starTime ) / 1000 + '秒')\n       })\n    }\n    render(){\n        const { list } = this.state\n        console.log(list)\n        return <div>\n            <button onClick={ this.handerClick } >点击</button>\n            {\n                list.map((item,index)=><li className=\"list\"  key={index} >\n                    { item  + '' + index } Item\n                </li>)\n            }\n        </div>\n    }\n}\n\n\n```\n\n\n> 为了解决一次性加载大量数据的问题。我们引出了时间分片的概念，就是用setTimeout把任务分割，分成若干次来渲染。一共40000个数据，我们可以每次渲染100个， 分次400渲染。\n\n\n```\nclass Index extends React.Component<any,any>{\n    state={\n       list: []\n    }\n    handerClick=()=>{\n       this.sliceTime(new Array(40000).fill(0), 0)\n    }\n    sliceTime=(list,times)=>{\n        if(times === 400) return \n        setTimeout(() => {\n            const newList = list.slice( times , (times + 1) * 100 ) /* 每次截取 100 个 */\n            this.setState({\n                list: this.state.list.concat(newList)\n            })\n            this.sliceTime( list ,times + 1 )\n        }, 0)\n    }\n    render(){\n        const { list } = this.state\n        return <div>\n            <button onClick={ this.handerClick } >点击</button>\n            {\n                list.map((item,index)=><li className=\"list\"  key={index} >\n                    { item  + '' + index } Item\n                </li>)\n            }\n        </div>\n    }\n}\n\n\n```\n\n\n> setTimeout 可以用 window.requestAnimationFrame() 代替，会有更好的渲染效果。\n\n\n> [内容来自](https://juejin.cn/post/6908895801116721160#heading-51)\n\n","source":"_posts/react 海量数据优化-时间分片，虚拟列表.md","raw":"---\ntitle: 海量数据优化-时间分片，虚拟列表\ndate: 2021-03-11 19:11:00\ntags: [前端, react, 性能优化]\ncategories: 技术\n---\n\n\n\n## 时间分片\n\n\n> 时间分片的概念，就是一次性渲染大量数据，初始化的时候会出现卡顿等现象。我们必须要明白的一个道理，js执行永远要比dom渲染快的多。 ，所以对于大量的数据，一次性渲染，容易造成卡顿，卡死的情况。\n\n\n```\n//普通方法下渲染时间在5s左右\nclass Index extends React.Component<any,any>{\n    state={\n       list: []\n    }\n    handerClick=()=>{\n       let starTime = new Date().getTime()\n       this.setState({\n           list: new Array(40000).fill(0)\n       },()=>{\n          const end =  new Date().getTime()\n          console.log( (end - starTime ) / 1000 + '秒')\n       })\n    }\n    render(){\n        const { list } = this.state\n        console.log(list)\n        return <div>\n            <button onClick={ this.handerClick } >点击</button>\n            {\n                list.map((item,index)=><li className=\"list\"  key={index} >\n                    { item  + '' + index } Item\n                </li>)\n            }\n        </div>\n    }\n}\n\n\n```\n\n\n> 为了解决一次性加载大量数据的问题。我们引出了时间分片的概念，就是用setTimeout把任务分割，分成若干次来渲染。一共40000个数据，我们可以每次渲染100个， 分次400渲染。\n\n\n```\nclass Index extends React.Component<any,any>{\n    state={\n       list: []\n    }\n    handerClick=()=>{\n       this.sliceTime(new Array(40000).fill(0), 0)\n    }\n    sliceTime=(list,times)=>{\n        if(times === 400) return \n        setTimeout(() => {\n            const newList = list.slice( times , (times + 1) * 100 ) /* 每次截取 100 个 */\n            this.setState({\n                list: this.state.list.concat(newList)\n            })\n            this.sliceTime( list ,times + 1 )\n        }, 0)\n    }\n    render(){\n        const { list } = this.state\n        return <div>\n            <button onClick={ this.handerClick } >点击</button>\n            {\n                list.map((item,index)=><li className=\"list\"  key={index} >\n                    { item  + '' + index } Item\n                </li>)\n            }\n        </div>\n    }\n}\n\n\n```\n\n\n> setTimeout 可以用 window.requestAnimationFrame() 代替，会有更好的渲染效果。\n\n\n> [内容来自](https://juejin.cn/post/6908895801116721160#heading-51)\n\n","slug":"react 海量数据优化-时间分片，虚拟列表","published":1,"updated":"2021-03-12T09:10:47.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm62ya14000004whgauvw3sy","content":"<h2 id=\"时间分片\"><a href=\"#时间分片\" class=\"headerlink\" title=\"时间分片\"></a>时间分片</h2><blockquote>\n<p>时间分片的概念，就是一次性渲染大量数据，初始化的时候会出现卡顿等现象。我们必须要明白的一个道理，js执行永远要比dom渲染快的多。 ，所以对于大量的数据，一次性渲染，容易造成卡顿，卡死的情况。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//普通方法下渲染时间在5s左右</span><br><span class=\"line\">class Index extends React.Component&lt;any,any&gt;&#123;</span><br><span class=\"line\">    state=&#123;</span><br><span class=\"line\">       list: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handerClick=()=&gt;&#123;</span><br><span class=\"line\">       let starTime = new Date().getTime()</span><br><span class=\"line\">       this.setState(&#123;</span><br><span class=\"line\">           list: new Array(40000).fill(0)</span><br><span class=\"line\">       &#125;,()=&gt;&#123;</span><br><span class=\"line\">          const end =  new Date().getTime()</span><br><span class=\"line\">          console.log( (end - starTime ) / 1000 + &apos;秒&apos;)</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        const &#123; list &#125; = this.state</span><br><span class=\"line\">        console.log(list)</span><br><span class=\"line\">        return &lt;div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123; this.handerClick &#125; &gt;点击&lt;/button&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                list.map((item,index)=&gt;&lt;li className=&quot;list&quot;  key=&#123;index&#125; &gt;</span><br><span class=\"line\">                    &#123; item  + &apos;&apos; + index &#125; Item</span><br><span class=\"line\">                &lt;/li&gt;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为了解决一次性加载大量数据的问题。我们引出了时间分片的概念，就是用setTimeout把任务分割，分成若干次来渲染。一共40000个数据，我们可以每次渲染100个， 分次400渲染。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Index extends React.Component&lt;any,any&gt;&#123;</span><br><span class=\"line\">    state=&#123;</span><br><span class=\"line\">       list: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handerClick=()=&gt;&#123;</span><br><span class=\"line\">       this.sliceTime(new Array(40000).fill(0), 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sliceTime=(list,times)=&gt;&#123;</span><br><span class=\"line\">        if(times === 400) return </span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            const newList = list.slice( times , (times + 1) * 100 ) /* 每次截取 100 个 */</span><br><span class=\"line\">            this.setState(&#123;</span><br><span class=\"line\">                list: this.state.list.concat(newList)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            this.sliceTime( list ,times + 1 )</span><br><span class=\"line\">        &#125;, 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        const &#123; list &#125; = this.state</span><br><span class=\"line\">        return &lt;div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123; this.handerClick &#125; &gt;点击&lt;/button&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                list.map((item,index)=&gt;&lt;li className=&quot;list&quot;  key=&#123;index&#125; &gt;</span><br><span class=\"line\">                    &#123; item  + &apos;&apos; + index &#125; Item</span><br><span class=\"line\">                &lt;/li&gt;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>setTimeout 可以用 window.requestAnimationFrame() 代替，会有更好的渲染效果。</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://juejin.cn/post/6908895801116721160#heading-51\" target=\"_blank\" rel=\"noopener\">内容来自</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"时间分片\"><a href=\"#时间分片\" class=\"headerlink\" title=\"时间分片\"></a>时间分片</h2><blockquote>\n<p>时间分片的概念，就是一次性渲染大量数据，初始化的时候会出现卡顿等现象。我们必须要明白的一个道理，js执行永远要比dom渲染快的多。 ，所以对于大量的数据，一次性渲染，容易造成卡顿，卡死的情况。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//普通方法下渲染时间在5s左右</span><br><span class=\"line\">class Index extends React.Component&lt;any,any&gt;&#123;</span><br><span class=\"line\">    state=&#123;</span><br><span class=\"line\">       list: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handerClick=()=&gt;&#123;</span><br><span class=\"line\">       let starTime = new Date().getTime()</span><br><span class=\"line\">       this.setState(&#123;</span><br><span class=\"line\">           list: new Array(40000).fill(0)</span><br><span class=\"line\">       &#125;,()=&gt;&#123;</span><br><span class=\"line\">          const end =  new Date().getTime()</span><br><span class=\"line\">          console.log( (end - starTime ) / 1000 + &apos;秒&apos;)</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        const &#123; list &#125; = this.state</span><br><span class=\"line\">        console.log(list)</span><br><span class=\"line\">        return &lt;div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123; this.handerClick &#125; &gt;点击&lt;/button&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                list.map((item,index)=&gt;&lt;li className=&quot;list&quot;  key=&#123;index&#125; &gt;</span><br><span class=\"line\">                    &#123; item  + &apos;&apos; + index &#125; Item</span><br><span class=\"line\">                &lt;/li&gt;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为了解决一次性加载大量数据的问题。我们引出了时间分片的概念，就是用setTimeout把任务分割，分成若干次来渲染。一共40000个数据，我们可以每次渲染100个， 分次400渲染。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Index extends React.Component&lt;any,any&gt;&#123;</span><br><span class=\"line\">    state=&#123;</span><br><span class=\"line\">       list: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handerClick=()=&gt;&#123;</span><br><span class=\"line\">       this.sliceTime(new Array(40000).fill(0), 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sliceTime=(list,times)=&gt;&#123;</span><br><span class=\"line\">        if(times === 400) return </span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            const newList = list.slice( times , (times + 1) * 100 ) /* 每次截取 100 个 */</span><br><span class=\"line\">            this.setState(&#123;</span><br><span class=\"line\">                list: this.state.list.concat(newList)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            this.sliceTime( list ,times + 1 )</span><br><span class=\"line\">        &#125;, 0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        const &#123; list &#125; = this.state</span><br><span class=\"line\">        return &lt;div&gt;</span><br><span class=\"line\">            &lt;button onClick=&#123; this.handerClick &#125; &gt;点击&lt;/button&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                list.map((item,index)=&gt;&lt;li className=&quot;list&quot;  key=&#123;index&#125; &gt;</span><br><span class=\"line\">                    &#123; item  + &apos;&apos; + index &#125; Item</span><br><span class=\"line\">                &lt;/li&gt;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>setTimeout 可以用 window.requestAnimationFrame() 代替，会有更好的渲染效果。</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://juejin.cn/post/6908895801116721160#heading-51\" target=\"_blank\" rel=\"noopener\">内容来自</a></p>\n</blockquote>\n"},{"title":"promise和async/await区别","date":"2021-03-19T09:19:52.000Z","_content":"\n\n\n#### promise\n\n\n>Promise,简单来说就是一个容器，里面保存着某个未来才会结束的时间(通常是一个异步操作的结果)\n\n\n```\n//promise错误捕获\n`let p = new Promise((resolve,reject) => {\n    reject('error');\n});\n\n\np.catch(result => {\n    console.log(result);\n})`\n```\n\n\n#### async、await\n\n\n>简洁：异步编程的最高境界就是不关心它是否是异步。async、await很好的解决了这一点，将异步强行转换为同步处理。\nasync/await与promise不存在谁代替谁的说法，因为async/await是寄生于Promise，Generater的语法糖。\n\n\n```\n//async、await错误捕获\nlet p = new Promise((resolve,reject) => {\n    setTimeout(() => {\n        reject('error');\n    },1000);\n});\n\n\nasync function demo(params) {\n    try {\n        let result = await p;\n    }catch(e) {\n        console.log(e);\n    }\n}\n\n\ndemo();\n```\n\n\n\n\n\n\n#### 区别 \n\n\n```\n1 promise是ES6，async/await是ES7\n2 async/await相对于promise来讲，写法更加优雅\n3 reject状态：\n    1）promise错误可以通过catch来捕捉，建议尾部捕获错误，\n    2）async/await既可以用.then又可以用try-catch捕捉\n```","source":"_posts/promise和async，await区别.md","raw":"---\ntitle: promise和async/await区别\ndate: 2021-03-19 17:19:52\ntags: [前端, es6 ]\ncategories: 技术\n---\n\n\n\n#### promise\n\n\n>Promise,简单来说就是一个容器，里面保存着某个未来才会结束的时间(通常是一个异步操作的结果)\n\n\n```\n//promise错误捕获\n`let p = new Promise((resolve,reject) => {\n    reject('error');\n});\n\n\np.catch(result => {\n    console.log(result);\n})`\n```\n\n\n#### async、await\n\n\n>简洁：异步编程的最高境界就是不关心它是否是异步。async、await很好的解决了这一点，将异步强行转换为同步处理。\nasync/await与promise不存在谁代替谁的说法，因为async/await是寄生于Promise，Generater的语法糖。\n\n\n```\n//async、await错误捕获\nlet p = new Promise((resolve,reject) => {\n    setTimeout(() => {\n        reject('error');\n    },1000);\n});\n\n\nasync function demo(params) {\n    try {\n        let result = await p;\n    }catch(e) {\n        console.log(e);\n    }\n}\n\n\ndemo();\n```\n\n\n\n\n\n\n#### 区别 \n\n\n```\n1 promise是ES6，async/await是ES7\n2 async/await相对于promise来讲，写法更加优雅\n3 reject状态：\n    1）promise错误可以通过catch来捕捉，建议尾部捕获错误，\n    2）async/await既可以用.then又可以用try-catch捕捉\n```","slug":"promise和async，await区别","published":1,"updated":"2021-03-19T09:39:06.127Z","_id":"ckmg3v1ge0000zhwhg3fprj71","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><blockquote>\n<p>Promise,简单来说就是一个容器，里面保存着某个未来才会结束的时间(通常是一个异步操作的结果)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//promise错误捕获</span><br><span class=\"line\">`let p = new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">    reject(&apos;error&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.catch(result =&gt; &#123;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">&#125;)`</span><br></pre></td></tr></table></figure>\n<h4 id=\"async、await\"><a href=\"#async、await\" class=\"headerlink\" title=\"async、await\"></a>async、await</h4><blockquote>\n<p>简洁：异步编程的最高境界就是不关心它是否是异步。async、await很好的解决了这一点，将异步强行转换为同步处理。<br>async/await与promise不存在谁代替谁的说法，因为async/await是寄生于Promise，Generater的语法糖。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//async、await错误捕获</span><br><span class=\"line\">let p = new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        reject(&apos;error&apos;);</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">async function demo(params) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        let result = await p;</span><br><span class=\"line\">    &#125;catch(e) &#123;</span><br><span class=\"line\">        console.log(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">demo();</span><br></pre></td></tr></table></figure>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 promise是ES6，async/await是ES7</span><br><span class=\"line\">2 async/await相对于promise来讲，写法更加优雅</span><br><span class=\"line\">3 reject状态：</span><br><span class=\"line\">    1）promise错误可以通过catch来捕捉，建议尾部捕获错误，</span><br><span class=\"line\">    2）async/await既可以用.then又可以用try-catch捕捉</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><blockquote>\n<p>Promise,简单来说就是一个容器，里面保存着某个未来才会结束的时间(通常是一个异步操作的结果)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//promise错误捕获</span><br><span class=\"line\">`let p = new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">    reject(&apos;error&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.catch(result =&gt; &#123;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">&#125;)`</span><br></pre></td></tr></table></figure>\n<h4 id=\"async、await\"><a href=\"#async、await\" class=\"headerlink\" title=\"async、await\"></a>async、await</h4><blockquote>\n<p>简洁：异步编程的最高境界就是不关心它是否是异步。async、await很好的解决了这一点，将异步强行转换为同步处理。<br>async/await与promise不存在谁代替谁的说法，因为async/await是寄生于Promise，Generater的语法糖。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//async、await错误捕获</span><br><span class=\"line\">let p = new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        reject(&apos;error&apos;);</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">async function demo(params) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        let result = await p;</span><br><span class=\"line\">    &#125;catch(e) &#123;</span><br><span class=\"line\">        console.log(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">demo();</span><br></pre></td></tr></table></figure>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 promise是ES6，async/await是ES7</span><br><span class=\"line\">2 async/await相对于promise来讲，写法更加优雅</span><br><span class=\"line\">3 reject状态：</span><br><span class=\"line\">    1）promise错误可以通过catch来捕捉，建议尾部捕获错误，</span><br><span class=\"line\">    2）async/await既可以用.then又可以用try-catch捕捉</span><br></pre></td></tr></table></figure>"},{"title":"一个正则表达式解析","date":"2021-03-19T11:30:58.000Z","_content":"\n\n\n#### 看一个例子来解析一个正则表达式的用法\n\n\n```\n//一段字符串\nlet str = \"中建工程有限公司<-(17.8%)中国xxx有限公司<-(100%)中国建筑股份有限公司(100%)->中国建筑xxx有限公司(100%)->中建八局第一建设有限公司<-(100%)Air Lease Corporation(25%)->91340104MA2W727N6L<-(法人,股东)中筑股份有限公司\";\n\n\n\n//需要处理成的最终结果\n [\"中建工程有限公司\", \"中国xxx有限公司\", \"中国建筑股份有限公司\", \"中国建筑xxx有限公司\", \"中建八局第一建设有限公司\", \"Air Lease Corporation\", \"91340104MA2W727N6L\", \"中筑股份有限公司\"]\n\n\n//正则表达式\nstr .replacereplace(/(<+-+\\([^)]*\\)|\\([^)]*\\)+-+>)/g,\",\").split(',');\n\n```\n\n\n> 来解析这段正则 /(<+-+\\([^)]*\\)|\\([^)]*\\)+-+>)/g\n\n\n```\n/*\n1. 首先需要匹配 <-( 为开头 ）为结尾的内容：<+-+\\([^)]*\\)\n2. 然后匹配 ( 开头 )-> 为结尾的内容 \\([^)]*\\)+-+>\n3. 两个条件需要同时匹配使用 ( | ) 的方式\n4. 最终就是：(<+-+\\([^)]*\\)|\\([^)]*\\)+-+>)\n5. 再加上固定的格式 /(<+-+\\([^)]*\\)|\\([^)]*\\)+-+>)/g 完成了\n*/ \n\n// [^)]* 的意思：不是括号的任意字符 ，*重复0到多次，匹配没有括号的任意字符\n```\n\n","source":"_posts/一个正则表达式解析.md","raw":"---\ntitle: 一个正则表达式解析\ndate: 2021-03-19 19:30:58\ntags: [前端,正则]\ncategories: 技术\n---\n\n\n\n#### 看一个例子来解析一个正则表达式的用法\n\n\n```\n//一段字符串\nlet str = \"中建工程有限公司<-(17.8%)中国xxx有限公司<-(100%)中国建筑股份有限公司(100%)->中国建筑xxx有限公司(100%)->中建八局第一建设有限公司<-(100%)Air Lease Corporation(25%)->91340104MA2W727N6L<-(法人,股东)中筑股份有限公司\";\n\n\n\n//需要处理成的最终结果\n [\"中建工程有限公司\", \"中国xxx有限公司\", \"中国建筑股份有限公司\", \"中国建筑xxx有限公司\", \"中建八局第一建设有限公司\", \"Air Lease Corporation\", \"91340104MA2W727N6L\", \"中筑股份有限公司\"]\n\n\n//正则表达式\nstr .replacereplace(/(<+-+\\([^)]*\\)|\\([^)]*\\)+-+>)/g,\",\").split(',');\n\n```\n\n\n> 来解析这段正则 /(<+-+\\([^)]*\\)|\\([^)]*\\)+-+>)/g\n\n\n```\n/*\n1. 首先需要匹配 <-( 为开头 ）为结尾的内容：<+-+\\([^)]*\\)\n2. 然后匹配 ( 开头 )-> 为结尾的内容 \\([^)]*\\)+-+>\n3. 两个条件需要同时匹配使用 ( | ) 的方式\n4. 最终就是：(<+-+\\([^)]*\\)|\\([^)]*\\)+-+>)\n5. 再加上固定的格式 /(<+-+\\([^)]*\\)|\\([^)]*\\)+-+>)/g 完成了\n*/ \n\n// [^)]* 的意思：不是括号的任意字符 ，*重复0到多次，匹配没有括号的任意字符\n```\n\n","slug":"一个正则表达式解析","published":1,"updated":"2021-03-21T14:13:24.038Z","_id":"ckmg8d0cn00001swh6x4xk9h5","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"看一个例子来解析一个正则表达式的用法\"><a href=\"#看一个例子来解析一个正则表达式的用法\" class=\"headerlink\" title=\"看一个例子来解析一个正则表达式的用法\"></a>看一个例子来解析一个正则表达式的用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//一段字符串</span><br><span class=\"line\">let str = &quot;中建工程有限公司&lt;-(17.8%)中国xxx有限公司&lt;-(100%)中国建筑股份有限公司(100%)-&gt;中国建筑xxx有限公司(100%)-&gt;中建八局第一建设有限公司&lt;-(100%)Air Lease Corporation(25%)-&gt;91340104MA2W727N6L&lt;-(法人,股东)中筑股份有限公司&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//需要处理成的最终结果</span><br><span class=\"line\"> [&quot;中建工程有限公司&quot;, &quot;中国xxx有限公司&quot;, &quot;中国建筑股份有限公司&quot;, &quot;中国建筑xxx有限公司&quot;, &quot;中建八局第一建设有限公司&quot;, &quot;Air Lease Corporation&quot;, &quot;91340104MA2W727N6L&quot;, &quot;中筑股份有限公司&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//正则表达式</span><br><span class=\"line\">str .replacereplace(/(&lt;+-+\\([^)]*\\)|\\([^)]*\\)+-+&gt;)/g,&quot;,&quot;).split(&apos;,&apos;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>来解析这段正则 /(&lt;+-+([^)]<em>)|([^)]</em>)+-+&gt;)/g</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">1. 首先需要匹配 &lt;-( 为开头 ）为结尾的内容：&lt;+-+\\([^)]*\\)</span><br><span class=\"line\">2. 然后匹配 ( 开头 )-&gt; 为结尾的内容 \\([^)]*\\)+-+&gt;</span><br><span class=\"line\">3. 两个条件需要同时匹配使用 ( | ) 的方式</span><br><span class=\"line\">4. 最终就是：(&lt;+-+\\([^)]*\\)|\\([^)]*\\)+-+&gt;)</span><br><span class=\"line\">5. 再加上固定的格式 /(&lt;+-+\\([^)]*\\)|\\([^)]*\\)+-+&gt;)/g 完成了</span><br><span class=\"line\">*/ </span><br><span class=\"line\"></span><br><span class=\"line\">// [^)]* 的意思：不是括号的任意字符 ，*重复0到多次，匹配没有括号的任意字符</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"看一个例子来解析一个正则表达式的用法\"><a href=\"#看一个例子来解析一个正则表达式的用法\" class=\"headerlink\" title=\"看一个例子来解析一个正则表达式的用法\"></a>看一个例子来解析一个正则表达式的用法</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//一段字符串</span><br><span class=\"line\">let str = &quot;中建工程有限公司&lt;-(17.8%)中国xxx有限公司&lt;-(100%)中国建筑股份有限公司(100%)-&gt;中国建筑xxx有限公司(100%)-&gt;中建八局第一建设有限公司&lt;-(100%)Air Lease Corporation(25%)-&gt;91340104MA2W727N6L&lt;-(法人,股东)中筑股份有限公司&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//需要处理成的最终结果</span><br><span class=\"line\"> [&quot;中建工程有限公司&quot;, &quot;中国xxx有限公司&quot;, &quot;中国建筑股份有限公司&quot;, &quot;中国建筑xxx有限公司&quot;, &quot;中建八局第一建设有限公司&quot;, &quot;Air Lease Corporation&quot;, &quot;91340104MA2W727N6L&quot;, &quot;中筑股份有限公司&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//正则表达式</span><br><span class=\"line\">str .replacereplace(/(&lt;+-+\\([^)]*\\)|\\([^)]*\\)+-+&gt;)/g,&quot;,&quot;).split(&apos;,&apos;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>来解析这段正则 /(&lt;+-+([^)]<em>)|([^)]</em>)+-+&gt;)/g</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">1. 首先需要匹配 &lt;-( 为开头 ）为结尾的内容：&lt;+-+\\([^)]*\\)</span><br><span class=\"line\">2. 然后匹配 ( 开头 )-&gt; 为结尾的内容 \\([^)]*\\)+-+&gt;</span><br><span class=\"line\">3. 两个条件需要同时匹配使用 ( | ) 的方式</span><br><span class=\"line\">4. 最终就是：(&lt;+-+\\([^)]*\\)|\\([^)]*\\)+-+&gt;)</span><br><span class=\"line\">5. 再加上固定的格式 /(&lt;+-+\\([^)]*\\)|\\([^)]*\\)+-+&gt;)/g 完成了</span><br><span class=\"line\">*/ </span><br><span class=\"line\"></span><br><span class=\"line\">// [^)]* 的意思：不是括号的任意字符 ，*重复0到多次，匹配没有括号的任意字符</span><br></pre></td></tr></table></figure>\n"},{"title":"Decorator（修饰器）","date":"2021-03-22T08:47:56.000Z","_content":"\n\n\n### 修饰器用法及参数\n\n\n> 基础用法\n\n```\n/*\ntarget: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\nname: 属性名\ndescriptor: 成员的属性描述符，可以设置是否可读，可写等\n  {\n     value: specifiedFunction,   控制对应的值，方法只是一个 value 是函数的属性。\n     enumerable: false,  控制是不是能枚举出属性。\n     configurable: true,  控制是不是能删、能修改 descriptor 本身。\n     writable: true  控制是不是能修改值。\n  };\n*/\nfunction logWrapper (target, name, descriptor){\n    console.log(target, name, descripto);\n}\n\n//使用方式\n@logWrapper\nclass App{\n   \n}\n\n\n```\n\n> 带参数用法\n\n```\nfunction logWrapper (target, name, descriptor){\n    return function(text){\n        target.render = () =>{console.log(text)}\n    }\n}\n\n//使用方式\n@logWrapper(\"Hello World\")\nclass App{\n    //注意，这里没有render方法，通过注入一个render方法\n}\n\nnew App().render();//输出\"Hello World\"\n```\n\n> 在属性上的用法\n\n```\nfunction logWrapper (target, name, descriptor){\n    console.log(name);  //aa，可以通过descriptor控制属性的是否可读，可写，可删等\n    descriptor.writable = false; //设置属性不能修改\n}\n\n//使用方式\nclass App{\n    @logWrapper\n    aa = '123';\n}\n\nApp.aa = '456';  //会出现报错，因为设置了属性不能修改\n\n```\n\n\n\n","source":"_posts/Decorator（修饰器）的用法及参数.md","raw":"---\ntitle: Decorator（修饰器）\ndate: 2021-03-22 16:47:56\ntags: [前端, es6]\ncategories: 技术\n---\n\n\n\n### 修饰器用法及参数\n\n\n> 基础用法\n\n```\n/*\ntarget: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象\nname: 属性名\ndescriptor: 成员的属性描述符，可以设置是否可读，可写等\n  {\n     value: specifiedFunction,   控制对应的值，方法只是一个 value 是函数的属性。\n     enumerable: false,  控制是不是能枚举出属性。\n     configurable: true,  控制是不是能删、能修改 descriptor 本身。\n     writable: true  控制是不是能修改值。\n  };\n*/\nfunction logWrapper (target, name, descriptor){\n    console.log(target, name, descripto);\n}\n\n//使用方式\n@logWrapper\nclass App{\n   \n}\n\n\n```\n\n> 带参数用法\n\n```\nfunction logWrapper (target, name, descriptor){\n    return function(text){\n        target.render = () =>{console.log(text)}\n    }\n}\n\n//使用方式\n@logWrapper(\"Hello World\")\nclass App{\n    //注意，这里没有render方法，通过注入一个render方法\n}\n\nnew App().render();//输出\"Hello World\"\n```\n\n> 在属性上的用法\n\n```\nfunction logWrapper (target, name, descriptor){\n    console.log(name);  //aa，可以通过descriptor控制属性的是否可读，可写，可删等\n    descriptor.writable = false; //设置属性不能修改\n}\n\n//使用方式\nclass App{\n    @logWrapper\n    aa = '123';\n}\n\nApp.aa = '456';  //会出现报错，因为设置了属性不能修改\n\n```\n\n\n\n","slug":"Decorator（修饰器）的用法及参数","published":1,"updated":"2021-03-22T10:20:34.000Z","_id":"ckmkft63j0000c7wh3e6w2blw","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"修饰器用法及参数\"><a href=\"#修饰器用法及参数\" class=\"headerlink\" title=\"修饰器用法及参数\"></a>修饰器用法及参数</h3><blockquote>\n<p>基础用法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</span><br><span class=\"line\">name: 属性名</span><br><span class=\"line\">descriptor: 成员的属性描述符，可以设置是否可读，可写等</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     value: specifiedFunction,   控制对应的值，方法只是一个 value 是函数的属性。</span><br><span class=\"line\">     enumerable: false,  控制是不是能枚举出属性。</span><br><span class=\"line\">     configurable: true,  控制是不是能删、能修改 descriptor 本身。</span><br><span class=\"line\">     writable: true  控制是不是能修改值。</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">*/</span><br><span class=\"line\">function logWrapper (target, name, descriptor)&#123;</span><br><span class=\"line\">    console.log(target, name, descripto);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用方式</span><br><span class=\"line\">@logWrapper</span><br><span class=\"line\">class App&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>带参数用法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function logWrapper (target, name, descriptor)&#123;</span><br><span class=\"line\">    return function(text)&#123;</span><br><span class=\"line\">        target.render = () =&gt;&#123;console.log(text)&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用方式</span><br><span class=\"line\">@logWrapper(&quot;Hello World&quot;)</span><br><span class=\"line\">class App&#123;</span><br><span class=\"line\">    //注意，这里没有render方法，通过注入一个render方法</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new App().render();//输出&quot;Hello World&quot;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在属性上的用法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function logWrapper (target, name, descriptor)&#123;</span><br><span class=\"line\">    console.log(name);  //aa，可以通过descriptor控制属性的是否可读，可写，可删等</span><br><span class=\"line\">    descriptor.writable = false; //设置属性不能修改</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用方式</span><br><span class=\"line\">class App&#123;</span><br><span class=\"line\">    @logWrapper</span><br><span class=\"line\">    aa = &apos;123&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">App.aa = &apos;456&apos;;  //会出现报错，因为设置了属性不能修改</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"修饰器用法及参数\"><a href=\"#修饰器用法及参数\" class=\"headerlink\" title=\"修饰器用法及参数\"></a>修饰器用法及参数</h3><blockquote>\n<p>基础用法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</span><br><span class=\"line\">name: 属性名</span><br><span class=\"line\">descriptor: 成员的属性描述符，可以设置是否可读，可写等</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">     value: specifiedFunction,   控制对应的值，方法只是一个 value 是函数的属性。</span><br><span class=\"line\">     enumerable: false,  控制是不是能枚举出属性。</span><br><span class=\"line\">     configurable: true,  控制是不是能删、能修改 descriptor 本身。</span><br><span class=\"line\">     writable: true  控制是不是能修改值。</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">*/</span><br><span class=\"line\">function logWrapper (target, name, descriptor)&#123;</span><br><span class=\"line\">    console.log(target, name, descripto);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用方式</span><br><span class=\"line\">@logWrapper</span><br><span class=\"line\">class App&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>带参数用法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function logWrapper (target, name, descriptor)&#123;</span><br><span class=\"line\">    return function(text)&#123;</span><br><span class=\"line\">        target.render = () =&gt;&#123;console.log(text)&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用方式</span><br><span class=\"line\">@logWrapper(&quot;Hello World&quot;)</span><br><span class=\"line\">class App&#123;</span><br><span class=\"line\">    //注意，这里没有render方法，通过注入一个render方法</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new App().render();//输出&quot;Hello World&quot;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在属性上的用法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function logWrapper (target, name, descriptor)&#123;</span><br><span class=\"line\">    console.log(name);  //aa，可以通过descriptor控制属性的是否可读，可写，可删等</span><br><span class=\"line\">    descriptor.writable = false; //设置属性不能修改</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用方式</span><br><span class=\"line\">class App&#123;</span><br><span class=\"line\">    @logWrapper</span><br><span class=\"line\">    aa = &apos;123&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">App.aa = &apos;456&apos;;  //会出现报错，因为设置了属性不能修改</span><br></pre></td></tr></table></figure>\n"},{"title":"js事件循环队列","date":"2021-03-22T15:28:12.000Z","_content":" \n\n> 宏任务有：setTimeout，setInterval，requestAnimationFrame，I/O\n\n\n> 微任务有：promise，process.nextTick，Object.observe，MutationObserver（promise里then的微任务就是用这个api实现的）\n\n\n> 先同步，再取出第一个宏任务执行所有的相关微任务总会在下一个宏任务之前全部执行完毕，如果遇见就先微后宏\n\n\n```\n//例子\nconsole.log(1);\nsetTimeout(function(){\n    console.log(2);\n});\nnew Promise(function(resolve){\n    console.log(3);\n    resolve();\n}).then(function(){\n    console.log(4);\n});\n\n\n//结合上面的知识点这里可以得出的输出结果为：1342\n/*\n1. 首先执行同步代码 输出：1\n\n2. 遇到setTimeout，这个属于宏任务，先不执行放入任务队列\n3. Promise是立刻执行 输出：3\n4. then是微任务，也放入队列\n5. 开始执行任务队列中的代码，此时队列中有两个任务一个宏任务，一个微任务，结合上面的先微后宏，\n 所以先执行then内的代码输出：4，然后在执行setTimeout代码输出：2\n*/\n```\n\n> Promise 的异步不仅仅只是 setTimeout，这里会根据不同环境来采用不同的实现方式，浏览器中主要用了 MutationObserver（高版本浏览器使用，这时候then就是微任务形式） 和 setTimeout（低版本浏览器使用，这时候then就是宏任务任务形式），所以在不同版本浏览器看到的执行结果是不一致的\n\n```\n// ie11\nsetTimeout(function () {console.log(1)});\nPromise.resolve().then(function () {\n  console.log(2);\n});\n// 输出结果为 2 1\n\n// ie10\nsetTimeout(function () {console.log(1)});\nPromise.resolve().then(function () {\n  console.log(2);\n});\n// 输出结果为 1 2\n```\n","source":"_posts/js事件循环队列.md","raw":"---\ntitle: js事件循环队列\ndate: 2021-03-22 23:28:12\ntags: [前端]\ncategories: 技术\n---\n \n\n> 宏任务有：setTimeout，setInterval，requestAnimationFrame，I/O\n\n\n> 微任务有：promise，process.nextTick，Object.observe，MutationObserver（promise里then的微任务就是用这个api实现的）\n\n\n> 先同步，再取出第一个宏任务执行所有的相关微任务总会在下一个宏任务之前全部执行完毕，如果遇见就先微后宏\n\n\n```\n//例子\nconsole.log(1);\nsetTimeout(function(){\n    console.log(2);\n});\nnew Promise(function(resolve){\n    console.log(3);\n    resolve();\n}).then(function(){\n    console.log(4);\n});\n\n\n//结合上面的知识点这里可以得出的输出结果为：1342\n/*\n1. 首先执行同步代码 输出：1\n\n2. 遇到setTimeout，这个属于宏任务，先不执行放入任务队列\n3. Promise是立刻执行 输出：3\n4. then是微任务，也放入队列\n5. 开始执行任务队列中的代码，此时队列中有两个任务一个宏任务，一个微任务，结合上面的先微后宏，\n 所以先执行then内的代码输出：4，然后在执行setTimeout代码输出：2\n*/\n```\n\n> Promise 的异步不仅仅只是 setTimeout，这里会根据不同环境来采用不同的实现方式，浏览器中主要用了 MutationObserver（高版本浏览器使用，这时候then就是微任务形式） 和 setTimeout（低版本浏览器使用，这时候then就是宏任务任务形式），所以在不同版本浏览器看到的执行结果是不一致的\n\n```\n// ie11\nsetTimeout(function () {console.log(1)});\nPromise.resolve().then(function () {\n  console.log(2);\n});\n// 输出结果为 2 1\n\n// ie10\nsetTimeout(function () {console.log(1)});\nPromise.resolve().then(function () {\n  console.log(2);\n});\n// 输出结果为 1 2\n```\n","slug":"js事件循环队列","published":1,"updated":"2021-03-25T16:08:01.655Z","_id":"ckmksczbg0000anwhfd3nt8lu","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>宏任务有：setTimeout，setInterval，requestAnimationFrame，I/O</p>\n</blockquote>\n<blockquote>\n<p>微任务有：promise，process.nextTick，Object.observe，MutationObserver（promise里then的微任务就是用这个api实现的）</p>\n</blockquote>\n<blockquote>\n<p>先同步，再取出第一个宏任务执行所有的相关微任务总会在下一个宏任务之前全部执行完毕，如果遇见就先微后宏</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//例子</span><br><span class=\"line\">console.log(1);</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Promise(function(resolve)&#123;</span><br><span class=\"line\">    console.log(3);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">    console.log(4);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//结合上面的知识点这里可以得出的输出结果为：1342</span><br><span class=\"line\">/*</span><br><span class=\"line\">1. 首先执行同步代码 输出：1</span><br><span class=\"line\"></span><br><span class=\"line\">2. 遇到setTimeout，这个属于宏任务，先不执行放入任务队列</span><br><span class=\"line\">3. Promise是立刻执行 输出：3</span><br><span class=\"line\">4. then是微任务，也放入队列</span><br><span class=\"line\">5. 开始执行任务队列中的代码，此时队列中有两个任务一个宏任务，一个微任务，结合上面的先微后宏，</span><br><span class=\"line\"> 所以先执行then内的代码输出：4，然后在执行setTimeout代码输出：2</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Promise 的异步不仅仅只是 setTimeout，这里会根据不同环境来采用不同的实现方式，浏览器中主要用了 MutationObserver（高版本浏览器使用，这时候then就是微任务形式） 和 setTimeout（低版本浏览器使用，这时候then就是宏任务任务形式），所以在不同版本浏览器看到的执行结果是不一致的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ie11</span><br><span class=\"line\">setTimeout(function () &#123;console.log(1)&#125;);</span><br><span class=\"line\">Promise.resolve().then(function () &#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 输出结果为 2 1</span><br><span class=\"line\"></span><br><span class=\"line\">// ie10</span><br><span class=\"line\">setTimeout(function () &#123;console.log(1)&#125;);</span><br><span class=\"line\">Promise.resolve().then(function () &#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 输出结果为 1 2</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>宏任务有：setTimeout，setInterval，requestAnimationFrame，I/O</p>\n</blockquote>\n<blockquote>\n<p>微任务有：promise，process.nextTick，Object.observe，MutationObserver（promise里then的微任务就是用这个api实现的）</p>\n</blockquote>\n<blockquote>\n<p>先同步，再取出第一个宏任务执行所有的相关微任务总会在下一个宏任务之前全部执行完毕，如果遇见就先微后宏</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//例子</span><br><span class=\"line\">console.log(1);</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">new Promise(function(resolve)&#123;</span><br><span class=\"line\">    console.log(3);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function()&#123;</span><br><span class=\"line\">    console.log(4);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//结合上面的知识点这里可以得出的输出结果为：1342</span><br><span class=\"line\">/*</span><br><span class=\"line\">1. 首先执行同步代码 输出：1</span><br><span class=\"line\"></span><br><span class=\"line\">2. 遇到setTimeout，这个属于宏任务，先不执行放入任务队列</span><br><span class=\"line\">3. Promise是立刻执行 输出：3</span><br><span class=\"line\">4. then是微任务，也放入队列</span><br><span class=\"line\">5. 开始执行任务队列中的代码，此时队列中有两个任务一个宏任务，一个微任务，结合上面的先微后宏，</span><br><span class=\"line\"> 所以先执行then内的代码输出：4，然后在执行setTimeout代码输出：2</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Promise 的异步不仅仅只是 setTimeout，这里会根据不同环境来采用不同的实现方式，浏览器中主要用了 MutationObserver（高版本浏览器使用，这时候then就是微任务形式） 和 setTimeout（低版本浏览器使用，这时候then就是宏任务任务形式），所以在不同版本浏览器看到的执行结果是不一致的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// ie11</span><br><span class=\"line\">setTimeout(function () &#123;console.log(1)&#125;);</span><br><span class=\"line\">Promise.resolve().then(function () &#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 输出结果为 2 1</span><br><span class=\"line\"></span><br><span class=\"line\">// ie10</span><br><span class=\"line\">setTimeout(function () &#123;console.log(1)&#125;);</span><br><span class=\"line\">Promise.resolve().then(function () &#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 输出结果为 1 2</span><br></pre></td></tr></table></figure>\n"},{"title":"input禁止自动回填方法","date":"2021-03-24T01:59:45.000Z","_content":"\n\n\n> 传统方式是给input加上autocomplete=\"off\"属性，但是在chrome里没有用\n\n\n```\n//在chrome内无效\n<input autocomplete=\"off\" />\n```\n\n\n> 在input的password框内加上autocomplete=\"new-password\"有效，顺便连帐号输入框也不再回填\n\n\n```\n<input type=\"password\" autocomplete=\"new-password\" />\n```","source":"_posts/input禁止自动回填方法.md","raw":"---\ntitle: input禁止自动回填方法\ndate: 2021-03-24 09:59:45\ntags: [前端]\ncategories: 技术\n---\n\n\n\n> 传统方式是给input加上autocomplete=\"off\"属性，但是在chrome里没有用\n\n\n```\n//在chrome内无效\n<input autocomplete=\"off\" />\n```\n\n\n> 在input的password框内加上autocomplete=\"new-password\"有效，顺便连帐号输入框也不再回填\n\n\n```\n<input type=\"password\" autocomplete=\"new-password\" />\n```","slug":"input禁止自动回填方法","published":1,"updated":"2021-03-24T02:08:55.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmmt5zte0000zdwhwmpq1fbz","content":"<blockquote>\n<p>传统方式是给input加上autocomplete=”off”属性，但是在chrome里没有用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//在chrome内无效</span><br><span class=\"line\">&lt;input autocomplete=&quot;off&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在input的password框内加上autocomplete=”new-password”有效，顺便连帐号输入框也不再回填</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;password&quot; autocomplete=&quot;new-password&quot; /&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>传统方式是给input加上autocomplete=”off”属性，但是在chrome里没有用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//在chrome内无效</span><br><span class=\"line\">&lt;input autocomplete=&quot;off&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在input的password框内加上autocomplete=”new-password”有效，顺便连帐号输入框也不再回填</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;password&quot; autocomplete=&quot;new-password&quot; /&gt;</span><br></pre></td></tr></table></figure>"},{"title":"h5离线存储 manifest","date":"2021-03-28T11:14:34.000Z","_content":"\n\n\n\n\n### h5离线存储 manifest\n\n\n####  问题分析\n\n\nHTML5提出的一个新的特性：离线存储。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常看见网页。\n\n\n#### 核心问题讲解\n\n\n**查看 在 application  ----  application cache里面可以看见**\n\n\n**使用**\n\n\n1  在需要离线缓存存储的页面 加上  manifest = \"cache.manifest\"\n\n\n```\n<!DOCTYPE HTML>\n<html manifest = \"cache.manifest\">\n...\n</html>\n```\n\n\n2 在根目录 新建文件 cache.manifest 并写上对应代码\n\n\n```\nCACHE MANIFEST\n#v0.11\n\n\nCACHE:\n\n\njs/app.js\ncss/style.css\n\n\nNETWORK:\nresourse/logo.png\n\n\nFALLBACK:\n/ /offline.html\n```\n\n\n离线存储的manifest一般由三个部分组成:\n\n\n1. CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 **会在当前浏览器存上**\n2. NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们**不会被离线存储**，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。\n3. FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果**访问根目录下任何一个资源失败了，那么就去访问offline.html**。\n\n\n#### 问题扩展\n\n\n**查看 在 application  ----  application cache里面可以看见**","source":"_posts/h5离线存储 manifest.md","raw":"---\ntitle: h5离线存储 manifest\ndate: 2021-03-28 19:14:34\ntags: [前端]\ncategories: 技术\n---\n\n\n\n\n\n### h5离线存储 manifest\n\n\n####  问题分析\n\n\nHTML5提出的一个新的特性：离线存储。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常看见网页。\n\n\n#### 核心问题讲解\n\n\n**查看 在 application  ----  application cache里面可以看见**\n\n\n**使用**\n\n\n1  在需要离线缓存存储的页面 加上  manifest = \"cache.manifest\"\n\n\n```\n<!DOCTYPE HTML>\n<html manifest = \"cache.manifest\">\n...\n</html>\n```\n\n\n2 在根目录 新建文件 cache.manifest 并写上对应代码\n\n\n```\nCACHE MANIFEST\n#v0.11\n\n\nCACHE:\n\n\njs/app.js\ncss/style.css\n\n\nNETWORK:\nresourse/logo.png\n\n\nFALLBACK:\n/ /offline.html\n```\n\n\n离线存储的manifest一般由三个部分组成:\n\n\n1. CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 **会在当前浏览器存上**\n2. NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们**不会被离线存储**，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。\n3. FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果**访问根目录下任何一个资源失败了，那么就去访问offline.html**。\n\n\n#### 问题扩展\n\n\n**查看 在 application  ----  application cache里面可以看见**","slug":"h5离线存储 manifest","published":1,"updated":"2021-03-28T16:38:49.310Z","_id":"ckmt2gcie000066whwjlbqog0","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"h5离线存储-manifest\"><a href=\"#h5离线存储-manifest\" class=\"headerlink\" title=\"h5离线存储 manifest\"></a>h5离线存储 manifest</h3><h4 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>HTML5提出的一个新的特性：离线存储。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常看见网页。</p>\n<h4 id=\"核心问题讲解\"><a href=\"#核心问题讲解\" class=\"headerlink\" title=\"核心问题讲解\"></a>核心问题讲解</h4><p><strong>查看 在 application  —-  application cache里面可以看见</strong></p>\n<p><strong>使用</strong></p>\n<p>1  在需要离线缓存存储的页面 加上  manifest = “cache.manifest”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html manifest = &quot;cache.manifest&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>2 在根目录 新建文件 cache.manifest 并写上对应代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\">#v0.11</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">js/app.js</span><br><span class=\"line\">css/style.css</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">resourse/logo.png</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\">/ /offline.html</span><br></pre></td></tr></table></figure>\n<p>离线存储的manifest一般由三个部分组成:</p>\n<ol>\n<li>CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 <strong>会在当前浏览器存上</strong></li>\n<li>NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们<strong>不会被离线存储</strong>，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</li>\n<li>FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果<strong>访问根目录下任何一个资源失败了，那么就去访问offline.html</strong>。</li>\n</ol>\n<h4 id=\"问题扩展\"><a href=\"#问题扩展\" class=\"headerlink\" title=\"问题扩展\"></a>问题扩展</h4><p><strong>查看 在 application  —-  application cache里面可以看见</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"h5离线存储-manifest\"><a href=\"#h5离线存储-manifest\" class=\"headerlink\" title=\"h5离线存储 manifest\"></a>h5离线存储 manifest</h3><h4 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>HTML5提出的一个新的特性：离线存储。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常看见网页。</p>\n<h4 id=\"核心问题讲解\"><a href=\"#核心问题讲解\" class=\"headerlink\" title=\"核心问题讲解\"></a>核心问题讲解</h4><p><strong>查看 在 application  —-  application cache里面可以看见</strong></p>\n<p><strong>使用</strong></p>\n<p>1  在需要离线缓存存储的页面 加上  manifest = “cache.manifest”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html manifest = &quot;cache.manifest&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>2 在根目录 新建文件 cache.manifest 并写上对应代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\">#v0.11</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">js/app.js</span><br><span class=\"line\">css/style.css</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">resourse/logo.png</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\">/ /offline.html</span><br></pre></td></tr></table></figure>\n<p>离线存储的manifest一般由三个部分组成:</p>\n<ol>\n<li>CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 <strong>会在当前浏览器存上</strong></li>\n<li>NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们<strong>不会被离线存储</strong>，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</li>\n<li>FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果<strong>访问根目录下任何一个资源失败了，那么就去访问offline.html</strong>。</li>\n</ol>\n<h4 id=\"问题扩展\"><a href=\"#问题扩展\" class=\"headerlink\" title=\"问题扩展\"></a>问题扩展</h4><p><strong>查看 在 application  —-  application cache里面可以看见</strong></p>\n"},{"title":"HTTP缓存","date":"2021-04-04T06:47:10.000Z","_content":"\n\n\n### 浏览器缓存分类\n> 浏览器先根据这个资源的http头信息来判断是否命中强缓存，如果命中则直接加载缓存中的资源，并不会将请求发送到服务器。（强缓存）\n\n\n> 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效，若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）\n\n\n> 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）\n\n\n\n\n #### 强缓存\n> 强缓存简单理解就是不用发送请求到服务器，就拿到缓存\n\n\n```\n//命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发工具中看到http的返回码是200，但是在size列会显示为（from cache），这就表示命中强缓存。\n//强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。\n\n\n/*\nExpires\n\n\n缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。\n\n\n该字段会返回一个时间，比如Expires:Thu,31 Dec 2037 23:59:59 GMT。这个时间代表着这个资源的失效时间，也就是说在2037年12月31日23点59分59秒之前都是有效的，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个`绝对时间`，所以当客户端本地时间被修改以后，服务器与客户端时间偏差变大以后，就会导致缓存混乱。于是发展出了Cache-Control。\n\n\nCache-Control\n\n\nCache-Control是一个`相对时间`，例如Cache-Control:3600，代表着资源的有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。\nCache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。\n\n\nCache-Control 可以由多个字段组合而成，主要有以下几个取值：\n\n\n1. **max-age** 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 * 60）天，第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。\n\n\n\n\n\n\n在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。\n\n\n在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。\n\n\n2. **s-maxage** 同 max-age，覆盖 max-age、Expires，但仅适用于共享缓存，在私有缓存中被忽略。\n\n\n3. **public** 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。\n\n\n4. **private** 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。\n\n\n5. **no-cache** 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。\n\n\n6. **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。\n\n\n 7.**must-revalidate**指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。\n*/\n```\n\n\n #### 协商缓存\n> 服务器判断浏览器本地缓存是否失效，若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源\n\n\n```\n/*\n\n\n若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。\n\n\n**Last-Modify/If-Modify-Since**\n\n\n浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。\n\n\n\n\n当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。\n\n\n如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。\n\n\n**ETag/If-None-Match**\n\n\n与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。\n\n\n*/\n```\n\n\n### 总结\nhttp 缓存控制\n1. http缓存能够帮助服务器提高并发性能，很多资源不需要重复请求直接从浏览器中拿缓存\n2. http 缓存分类 ：强缓存 协商缓存\n3. 强缓存通过  expires 和 cache-control控制  协商缓存  通过  last-Modify  和E-tag控制\n\n\n补充：\n    1. 为什么有expires 有需要cache-control \n        因为expires 有个服务器和浏览器时间不同步的问题\n        expires是绝对事件   cache-control是相对时间\n\n\n    2. last-modify和Etag\n       last-modify 它是有个精度问题  到秒\n       e-tag 没有精度问题  只要文件改变  e-tag值就改变\n","source":"_posts/HTTP缓存.md","raw":"---\ntitle: HTTP缓存\ndate: 2021-04-04 14:47:10\ntags: [前端]\ncategories: 技术\n---\n\n\n\n### 浏览器缓存分类\n> 浏览器先根据这个资源的http头信息来判断是否命中强缓存，如果命中则直接加载缓存中的资源，并不会将请求发送到服务器。（强缓存）\n\n\n> 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效，若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）\n\n\n> 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）\n\n\n\n\n #### 强缓存\n> 强缓存简单理解就是不用发送请求到服务器，就拿到缓存\n\n\n```\n//命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发工具中看到http的返回码是200，但是在size列会显示为（from cache），这就表示命中强缓存。\n//强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。\n\n\n/*\nExpires\n\n\n缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。\n\n\n该字段会返回一个时间，比如Expires:Thu,31 Dec 2037 23:59:59 GMT。这个时间代表着这个资源的失效时间，也就是说在2037年12月31日23点59分59秒之前都是有效的，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个`绝对时间`，所以当客户端本地时间被修改以后，服务器与客户端时间偏差变大以后，就会导致缓存混乱。于是发展出了Cache-Control。\n\n\nCache-Control\n\n\nCache-Control是一个`相对时间`，例如Cache-Control:3600，代表着资源的有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。\nCache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。\n\n\nCache-Control 可以由多个字段组合而成，主要有以下几个取值：\n\n\n1. **max-age** 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 * 60）天，第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。\n\n\n\n\n\n\n在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。\n\n\n在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。\n\n\n2. **s-maxage** 同 max-age，覆盖 max-age、Expires，但仅适用于共享缓存，在私有缓存中被忽略。\n\n\n3. **public** 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。\n\n\n4. **private** 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。\n\n\n5. **no-cache** 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。\n\n\n6. **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。\n\n\n 7.**must-revalidate**指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。\n*/\n```\n\n\n #### 协商缓存\n> 服务器判断浏览器本地缓存是否失效，若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源\n\n\n```\n/*\n\n\n若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。\n\n\n**Last-Modify/If-Modify-Since**\n\n\n浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。\n\n\n\n\n当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。\n\n\n如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。\n\n\n**ETag/If-None-Match**\n\n\n与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。\n\n\n*/\n```\n\n\n### 总结\nhttp 缓存控制\n1. http缓存能够帮助服务器提高并发性能，很多资源不需要重复请求直接从浏览器中拿缓存\n2. http 缓存分类 ：强缓存 协商缓存\n3. 强缓存通过  expires 和 cache-control控制  协商缓存  通过  last-Modify  和E-tag控制\n\n\n补充：\n    1. 为什么有expires 有需要cache-control \n        因为expires 有个服务器和浏览器时间不同步的问题\n        expires是绝对事件   cache-control是相对时间\n\n\n    2. last-modify和Etag\n       last-modify 它是有个精度问题  到秒\n       e-tag 没有精度问题  只要文件改变  e-tag值就改变\n","slug":"HTTP缓存","published":1,"updated":"2021-04-04T15:15:56.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn3b4oa80000muwh7ozk1lzv","content":"<h3 id=\"浏览器缓存分类\"><a href=\"#浏览器缓存分类\" class=\"headerlink\" title=\"浏览器缓存分类\"></a>浏览器缓存分类</h3><blockquote>\n<p>浏览器先根据这个资源的http头信息来判断是否命中强缓存，如果命中则直接加载缓存中的资源，并不会将请求发送到服务器。（强缓存）</p>\n</blockquote>\n<blockquote>\n<p>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效，若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</p>\n</blockquote>\n<blockquote>\n<p>如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</p>\n</blockquote>\n<h4 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h4><blockquote>\n<p>强缓存简单理解就是不用发送请求到服务器，就拿到缓存</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发工具中看到http的返回码是200，但是在size列会显示为（from cache），这就表示命中强缓存。</span><br><span class=\"line\">//强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">Expires</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">该字段会返回一个时间，比如Expires:Thu,31 Dec 2037 23:59:59 GMT。这个时间代表着这个资源的失效时间，也就是说在2037年12月31日23点59分59秒之前都是有效的，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个`绝对时间`，所以当客户端本地时间被修改以后，服务器与客户端时间偏差变大以后，就会导致缓存混乱。于是发展出了Cache-Control。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control是一个`相对时间`，例如Cache-Control:3600，代表着资源的有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。</span><br><span class=\"line\">Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control 可以由多个字段组合而成，主要有以下几个取值：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">1. **max-age** 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 * 60）天，第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2. **s-maxage** 同 max-age，覆盖 max-age、Expires，但仅适用于共享缓存，在私有缓存中被忽略。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">3. **public** 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4. **private** 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">5. **no-cache** 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">6. **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> 7.**must-revalidate**指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<h4 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h4><blockquote>\n<p>服务器判断浏览器本地缓存是否失效，若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**Last-Modify/If-Modify-Since**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**ETag/If-None-Match**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>http 缓存控制</p>\n<ol>\n<li>http缓存能够帮助服务器提高并发性能，很多资源不需要重复请求直接从浏览器中拿缓存</li>\n<li>http 缓存分类 ：强缓存 协商缓存</li>\n<li>强缓存通过  expires 和 cache-control控制  协商缓存  通过  last-Modify  和E-tag控制</li>\n</ol>\n<p>补充：</p>\n<pre><code>1. 为什么有expires 有需要cache-control \n    因为expires 有个服务器和浏览器时间不同步的问题\n    expires是绝对事件   cache-control是相对时间\n\n\n2. last-modify和Etag\n   last-modify 它是有个精度问题  到秒\n   e-tag 没有精度问题  只要文件改变  e-tag值就改变\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"浏览器缓存分类\"><a href=\"#浏览器缓存分类\" class=\"headerlink\" title=\"浏览器缓存分类\"></a>浏览器缓存分类</h3><blockquote>\n<p>浏览器先根据这个资源的http头信息来判断是否命中强缓存，如果命中则直接加载缓存中的资源，并不会将请求发送到服务器。（强缓存）</p>\n</blockquote>\n<blockquote>\n<p>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效，若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</p>\n</blockquote>\n<blockquote>\n<p>如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</p>\n</blockquote>\n<h4 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h4><blockquote>\n<p>强缓存简单理解就是不用发送请求到服务器，就拿到缓存</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发工具中看到http的返回码是200，但是在size列会显示为（from cache），这就表示命中强缓存。</span><br><span class=\"line\">//强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">Expires</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">该字段会返回一个时间，比如Expires:Thu,31 Dec 2037 23:59:59 GMT。这个时间代表着这个资源的失效时间，也就是说在2037年12月31日23点59分59秒之前都是有效的，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个`绝对时间`，所以当客户端本地时间被修改以后，服务器与客户端时间偏差变大以后，就会导致缓存混乱。于是发展出了Cache-Control。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control是一个`相对时间`，例如Cache-Control:3600，代表着资源的有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。</span><br><span class=\"line\">Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Cache-Control 可以由多个字段组合而成，主要有以下几个取值：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">1. **max-age** 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 * 60）天，第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2. **s-maxage** 同 max-age，覆盖 max-age、Expires，但仅适用于共享缓存，在私有缓存中被忽略。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">3. **public** 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4. **private** 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">5. **no-cache** 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">6. **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> 7.**must-revalidate**指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<h4 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h4><blockquote>\n<p>服务器判断浏览器本地缓存是否失效，若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**Last-Modify/If-Modify-Since**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">**ETag/If-None-Match**</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>http 缓存控制</p>\n<ol>\n<li>http缓存能够帮助服务器提高并发性能，很多资源不需要重复请求直接从浏览器中拿缓存</li>\n<li>http 缓存分类 ：强缓存 协商缓存</li>\n<li>强缓存通过  expires 和 cache-control控制  协商缓存  通过  last-Modify  和E-tag控制</li>\n</ol>\n<p>补充：</p>\n<pre><code>1. 为什么有expires 有需要cache-control \n    因为expires 有个服务器和浏览器时间不同步的问题\n    expires是绝对事件   cache-control是相对时间\n\n\n2. last-modify和Etag\n   last-modify 它是有个精度问题  到秒\n   e-tag 没有精度问题  只要文件改变  e-tag值就改变\n</code></pre>"},{"title":"xss和csrf介绍","date":"2021-04-12T16:14:11.000Z","_content":"\n\n\n## xss 跨站脚步攻击\n> 浏览器向服务请求的时候注入脚步攻击，分为三种类型\n\n1. 反射型 （Reflected XSS ） 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。\n\n\n2. 存储型存  Stored XSS和 Reflected XSS的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，从而获得了在网络上传播的能力。\n\n\n3. DOM型 （DOM-based or local XSS） 即基于DOM或本地的 XSS 攻击：其实是一种特殊类型的反射型 XSS，它是基于 DOM文档对象模型的一种漏洞。可以通过 DOM来动态修改页面内容，从客户端获取 DOM中的数据并在本地执行。基于这个特性，就可以利用 JS脚本来实现 XSS漏洞的利用。\n \n> 防范手段：\n\n1. 输入过滤，避免 XSS 的方法之一主要是将用户输入的内容进行过滤。对所有用户提交内容进行可靠的输入验证，包括对 URL、查询关键字、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。(客户端和服务器都要)\n\n\n2. 输出转义 例如： 往 HTML 标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行 HTML Entity 编码 [HTML 字符实体](http://www.w3school.com.cn/html/html_entities.asp)\n```js\nfunction htmlEncodeByRegExp  (str){  \n         var s = \"\";\n         if(str.length == 0) return \"\";\n         s = str.replace(/&/g,\"&amp;\");\n         s = s.replace(/</g,\"&lt;\");\n         s = s.replace(/>/g,\"&gt;\");\n         s = s.replace(/ /g,\"&nbsp;\");\n         s = s.replace(/\\'/g,\"&#39;\");\n         s = s.replace(/\\\"/g,\"&quot;\");\n         return s;  \n }\nvar tmpStr=\"<p>123</p>\";   \nvar html=htmlEncodeByRegExp (tmpStr)\nconsole.log(html) //&lt;p&gt;123&lt;/p&gt;\ndocument.querySelector(\".content\").innerHTML=html; //<p>123</p>\n```\n3. 使用 HttpOnly Cookie\n\n\n将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。\n\n\n现代web开发框架如vue.js、react.js等，在设计的时候就考虑了XSS攻击对html插值进行了更进一步的抽象、过滤和转义，我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。\n\n\n## csrf 跨站请求伪造\n> `CSRF` , 即Cross-site request forgery）中译是跨站请求伪造；CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。\n\n\n> 你可以这样来理解：\n    攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。\n\n\n**CSRF攻击攻击原理及过程如下：**\n\n\n1.  用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n2.  在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n3.  用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\n4.  网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n5.  浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 \n\n\n> 举例：\n\n\n 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求\n\n\n `http://bank.example/withdraw?account=bob&amount=1000000&for=bob2` \n\n\n可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。\n\n\n​    黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：\n\n\n`http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory`。\n\n\n但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。\n\n\n​    这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码：\n\n\n `src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”`，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。\n\n> 防范手段：\n\n\n01.  验证 HTTP Referer 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer记录了该 HTTP 请求的来源地址。\n\n\n\n- 优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。\n\n\n- 缺点：Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。用户自己可以设置浏览器使其在发送请求时不再提供 Referer 时，网站将拒绝合法用户的访问。\n\n\n\n\n​02.  在请求地址中添加 token 并验证，CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。\n\n\n\n\n- 优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。\n\n\n-  缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。\n\n\n\n\n03.  在 HTTP 头中自定义属性并验证\n 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。\n\n\n\n\n- 优点：统一管理 token 输入输出，可以保证 token 的安全性。\n\n\n- 缺点：有局限性，无法在非异步的请求上实施。\n\n","source":"_posts/xss和csrf介绍.md","raw":"---\ntitle: xss和csrf介绍\ndate: 2021-04-13 00:14:11\ntags: [前端]\ncategories: 技术\n---\n\n\n\n## xss 跨站脚步攻击\n> 浏览器向服务请求的时候注入脚步攻击，分为三种类型\n\n1. 反射型 （Reflected XSS ） 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。\n\n\n2. 存储型存  Stored XSS和 Reflected XSS的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，从而获得了在网络上传播的能力。\n\n\n3. DOM型 （DOM-based or local XSS） 即基于DOM或本地的 XSS 攻击：其实是一种特殊类型的反射型 XSS，它是基于 DOM文档对象模型的一种漏洞。可以通过 DOM来动态修改页面内容，从客户端获取 DOM中的数据并在本地执行。基于这个特性，就可以利用 JS脚本来实现 XSS漏洞的利用。\n \n> 防范手段：\n\n1. 输入过滤，避免 XSS 的方法之一主要是将用户输入的内容进行过滤。对所有用户提交内容进行可靠的输入验证，包括对 URL、查询关键字、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。(客户端和服务器都要)\n\n\n2. 输出转义 例如： 往 HTML 标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行 HTML Entity 编码 [HTML 字符实体](http://www.w3school.com.cn/html/html_entities.asp)\n```js\nfunction htmlEncodeByRegExp  (str){  \n         var s = \"\";\n         if(str.length == 0) return \"\";\n         s = str.replace(/&/g,\"&amp;\");\n         s = s.replace(/</g,\"&lt;\");\n         s = s.replace(/>/g,\"&gt;\");\n         s = s.replace(/ /g,\"&nbsp;\");\n         s = s.replace(/\\'/g,\"&#39;\");\n         s = s.replace(/\\\"/g,\"&quot;\");\n         return s;  \n }\nvar tmpStr=\"<p>123</p>\";   \nvar html=htmlEncodeByRegExp (tmpStr)\nconsole.log(html) //&lt;p&gt;123&lt;/p&gt;\ndocument.querySelector(\".content\").innerHTML=html; //<p>123</p>\n```\n3. 使用 HttpOnly Cookie\n\n\n将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。\n\n\n现代web开发框架如vue.js、react.js等，在设计的时候就考虑了XSS攻击对html插值进行了更进一步的抽象、过滤和转义，我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。\n\n\n## csrf 跨站请求伪造\n> `CSRF` , 即Cross-site request forgery）中译是跨站请求伪造；CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。\n\n\n> 你可以这样来理解：\n    攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。\n\n\n**CSRF攻击攻击原理及过程如下：**\n\n\n1.  用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n2.  在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n3.  用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\n4.  网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n5.  浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 \n\n\n> 举例：\n\n\n 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求\n\n\n `http://bank.example/withdraw?account=bob&amount=1000000&for=bob2` \n\n\n可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。\n\n\n​    黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：\n\n\n`http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory`。\n\n\n但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。\n\n\n​    这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码：\n\n\n `src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”`，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。\n\n> 防范手段：\n\n\n01.  验证 HTTP Referer 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer记录了该 HTTP 请求的来源地址。\n\n\n\n- 优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。\n\n\n- 缺点：Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。用户自己可以设置浏览器使其在发送请求时不再提供 Referer 时，网站将拒绝合法用户的访问。\n\n\n\n\n​02.  在请求地址中添加 token 并验证，CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。\n\n\n\n\n- 优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。\n\n\n-  缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。\n\n\n\n\n03.  在 HTTP 头中自定义属性并验证\n 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。\n\n\n\n\n- 优点：统一管理 token 输入输出，可以保证 token 的安全性。\n\n\n- 缺点：有局限性，无法在非异步的请求上实施。\n\n","slug":"xss和csrf介绍","published":1,"updated":"2021-04-12T16:55:17.174Z","_id":"cknetjuwf0000hkwh7c4o0jgf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"xss-跨站脚步攻击\"><a href=\"#xss-跨站脚步攻击\" class=\"headerlink\" title=\"xss 跨站脚步攻击\"></a>xss 跨站脚步攻击</h2><blockquote>\n<p>浏览器向服务请求的时候注入脚步攻击，分为三种类型</p>\n</blockquote>\n<ol>\n<li>反射型 （Reflected XSS ） 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。</li>\n</ol>\n<ol start=\"2\">\n<li>存储型存  Stored XSS和 Reflected XSS的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，从而获得了在网络上传播的能力。</li>\n</ol>\n<ol start=\"3\">\n<li>DOM型 （DOM-based or local XSS） 即基于DOM或本地的 XSS 攻击：其实是一种特殊类型的反射型 XSS，它是基于 DOM文档对象模型的一种漏洞。可以通过 DOM来动态修改页面内容，从客户端获取 DOM中的数据并在本地执行。基于这个特性，就可以利用 JS脚本来实现 XSS漏洞的利用。</li>\n</ol>\n<blockquote>\n<p>防范手段：</p>\n</blockquote>\n<ol>\n<li>输入过滤，避免 XSS 的方法之一主要是将用户输入的内容进行过滤。对所有用户提交内容进行可靠的输入验证，包括对 URL、查询关键字、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。(客户端和服务器都要)</li>\n</ol>\n<ol start=\"2\">\n<li><p>输出转义 例如： 往 HTML 标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行 HTML Entity 编码 <a href=\"http://www.w3school.com.cn/html/html_entities.asp\" target=\"_blank\" rel=\"noopener\">HTML 字符实体</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">htmlEncodeByRegExp</span>  (<span class=\"params\">str</span>)</span>&#123;  </span><br><span class=\"line\">         <span class=\"keyword\">var</span> s = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(str.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         s = str.replace(<span class=\"regexp\">/&amp;/g</span>,<span class=\"string\">\"&amp;amp;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/&lt;/g</span>,<span class=\"string\">\"&amp;lt;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/&gt;/g</span>,<span class=\"string\">\"&amp;gt;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/ /g</span>,<span class=\"string\">\"&amp;nbsp;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/\\'/g</span>,<span class=\"string\">\"&amp;#39;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/\\\"/g</span>,<span class=\"string\">\"&amp;quot;\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s;  </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> tmpStr=<span class=\"string\">\"&lt;p&gt;123&lt;/p&gt;\"</span>;   </span><br><span class=\"line\"><span class=\"keyword\">var</span> html=htmlEncodeByRegExp (tmpStr)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(html) <span class=\"comment\">//&amp;lt;p&amp;gt;123&amp;lt;/p&amp;gt;</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".content\"</span>).innerHTML=html; <span class=\"comment\">//&lt;p&gt;123&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 HttpOnly Cookie</p>\n</li>\n</ol>\n<p>将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。</p>\n<p>现代web开发框架如vue.js、react.js等，在设计的时候就考虑了XSS攻击对html插值进行了更进一步的抽象、过滤和转义，我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。</p>\n<h2 id=\"csrf-跨站请求伪造\"><a href=\"#csrf-跨站请求伪造\" class=\"headerlink\" title=\"csrf 跨站请求伪造\"></a>csrf 跨站请求伪造</h2><blockquote>\n<p><code>CSRF</code> , 即Cross-site request forgery）中译是跨站请求伪造；CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。</p>\n</blockquote>\n<blockquote>\n<p>你可以这样来理解：<br>    攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p>\n</blockquote>\n<p><strong>CSRF攻击攻击原理及过程如下：</strong></p>\n<ol>\n<li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li>\n<li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li>\n<li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li>\n<li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li>\n<li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </li>\n</ol>\n<blockquote>\n<p>举例：</p>\n</blockquote>\n<p> 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求</p>\n<p> <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</code> </p>\n<p>可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p>\n<p>​    黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：</p>\n<p><code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>。</p>\n<p>但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p>\n<p>​    这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码：</p>\n<p> <code>src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”</code>，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p>\n<blockquote>\n<p>防范手段：</p>\n</blockquote>\n<ol>\n<li>验证 HTTP Referer 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer记录了该 HTTP 请求的来源地址。</li>\n</ol>\n<ul>\n<li>优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</li>\n</ul>\n<ul>\n<li>缺点：Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。用户自己可以设置浏览器使其在发送请求时不再提供 Referer 时，网站将拒绝合法用户的访问。</li>\n</ul>\n<p>​02.  在请求地址中添加 token 并验证，CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>\n<ul>\n<li>优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。</li>\n</ul>\n<ul>\n<li>缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。</li>\n</ul>\n<ol start=\"3\">\n<li>在 HTTP 头中自定义属性并验证<br>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</li>\n</ol>\n<ul>\n<li>优点：统一管理 token 输入输出，可以保证 token 的安全性。</li>\n</ul>\n<ul>\n<li>缺点：有局限性，无法在非异步的请求上实施。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"xss-跨站脚步攻击\"><a href=\"#xss-跨站脚步攻击\" class=\"headerlink\" title=\"xss 跨站脚步攻击\"></a>xss 跨站脚步攻击</h2><blockquote>\n<p>浏览器向服务请求的时候注入脚步攻击，分为三种类型</p>\n</blockquote>\n<ol>\n<li>反射型 （Reflected XSS ） 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。</li>\n</ol>\n<ol start=\"2\">\n<li>存储型存  Stored XSS和 Reflected XSS的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，从而获得了在网络上传播的能力。</li>\n</ol>\n<ol start=\"3\">\n<li>DOM型 （DOM-based or local XSS） 即基于DOM或本地的 XSS 攻击：其实是一种特殊类型的反射型 XSS，它是基于 DOM文档对象模型的一种漏洞。可以通过 DOM来动态修改页面内容，从客户端获取 DOM中的数据并在本地执行。基于这个特性，就可以利用 JS脚本来实现 XSS漏洞的利用。</li>\n</ol>\n<blockquote>\n<p>防范手段：</p>\n</blockquote>\n<ol>\n<li>输入过滤，避免 XSS 的方法之一主要是将用户输入的内容进行过滤。对所有用户提交内容进行可靠的输入验证，包括对 URL、查询关键字、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。(客户端和服务器都要)</li>\n</ol>\n<ol start=\"2\">\n<li><p>输出转义 例如： 往 HTML 标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行 HTML Entity 编码 <a href=\"http://www.w3school.com.cn/html/html_entities.asp\" target=\"_blank\" rel=\"noopener\">HTML 字符实体</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">htmlEncodeByRegExp</span>  (<span class=\"params\">str</span>)</span>&#123;  </span><br><span class=\"line\">         <span class=\"keyword\">var</span> s = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(str.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">         s = str.replace(<span class=\"regexp\">/&amp;/g</span>,<span class=\"string\">\"&amp;amp;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/&lt;/g</span>,<span class=\"string\">\"&amp;lt;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/&gt;/g</span>,<span class=\"string\">\"&amp;gt;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/ /g</span>,<span class=\"string\">\"&amp;nbsp;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/\\'/g</span>,<span class=\"string\">\"&amp;#39;\"</span>);</span><br><span class=\"line\">         s = s.replace(<span class=\"regexp\">/\\\"/g</span>,<span class=\"string\">\"&amp;quot;\"</span>);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s;  </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> tmpStr=<span class=\"string\">\"&lt;p&gt;123&lt;/p&gt;\"</span>;   </span><br><span class=\"line\"><span class=\"keyword\">var</span> html=htmlEncodeByRegExp (tmpStr)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(html) <span class=\"comment\">//&amp;lt;p&amp;gt;123&amp;lt;/p&amp;gt;</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".content\"</span>).innerHTML=html; <span class=\"comment\">//&lt;p&gt;123&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 HttpOnly Cookie</p>\n</li>\n</ol>\n<p>将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。</p>\n<p>现代web开发框架如vue.js、react.js等，在设计的时候就考虑了XSS攻击对html插值进行了更进一步的抽象、过滤和转义，我们只要熟练正确地使用他们，就可以在大部分情况下避免XSS攻击。</p>\n<h2 id=\"csrf-跨站请求伪造\"><a href=\"#csrf-跨站请求伪造\" class=\"headerlink\" title=\"csrf 跨站请求伪造\"></a>csrf 跨站请求伪造</h2><blockquote>\n<p><code>CSRF</code> , 即Cross-site request forgery）中译是跨站请求伪造；CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。</p>\n</blockquote>\n<blockquote>\n<p>你可以这样来理解：<br>    攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p>\n</blockquote>\n<p><strong>CSRF攻击攻击原理及过程如下：</strong></p>\n<ol>\n<li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li>\n<li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li>\n<li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li>\n<li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li>\n<li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </li>\n</ol>\n<blockquote>\n<p>举例：</p>\n</blockquote>\n<p> 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求</p>\n<p> <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</code> </p>\n<p>可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p>\n<p>​    黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：</p>\n<p><code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>。</p>\n<p>但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p>\n<p>​    这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码：</p>\n<p> <code>src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”</code>，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p>\n<blockquote>\n<p>防范手段：</p>\n</blockquote>\n<ol>\n<li>验证 HTTP Referer 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer记录了该 HTTP 请求的来源地址。</li>\n</ol>\n<ul>\n<li>优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</li>\n</ul>\n<ul>\n<li>缺点：Referer 的值是由浏览器提供的，不可全信，低版本浏览器下 Referer 存在伪造风险。用户自己可以设置浏览器使其在发送请求时不再提供 Referer 时，网站将拒绝合法用户的访问。</li>\n</ul>\n<p>​02.  在请求地址中添加 token 并验证，CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>\n<ul>\n<li>优点：这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。</li>\n</ul>\n<ul>\n<li>缺点：对所有请求都添加 token 比较困难。难以保证 token 本身的安全，依然会被利用获取到 token。</li>\n</ul>\n<ol start=\"3\">\n<li>在 HTTP 头中自定义属性并验证<br>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</li>\n</ol>\n<ul>\n<li>优点：统一管理 token 输入输出，可以保证 token 的安全性。</li>\n</ul>\n<ul>\n<li>缺点：有局限性，无法在非异步的请求上实施。</li>\n</ul>\n"},{"title":"事件冒泡","date":"2021-04-13T05:32:20.000Z","_content":" \n\n![image](/assets/事件冒泡图.png)\n\n\n\n> 事件冒泡分为三个阶段\n\n\n- 捕获阶段，这是最开始的阶段，是事件从最不精确的对象(document 对象)开始触发，然后到最精确\n- 目标阶段，捕获一直到找到事件的触发目标元素\n- 冒泡阶段，找到目标元素后开始往上冒泡，并且执行事件函数\n\n\n> 阻止事件冒泡方法：\n\n\n1. e.stopPropagation(); 只阻止冒泡\n\n\n2. return false; 不过这种方法即会阻止冒泡，也会阻止代码的执行","source":"_posts/事件冒泡.md","raw":"---\ntitle: 事件冒泡\ndate: 2021-04-13 13:32:20\ntags: [前端]\ncategories: 技术\n---\n \n\n![image](/assets/事件冒泡图.png)\n\n\n\n> 事件冒泡分为三个阶段\n\n\n- 捕获阶段，这是最开始的阶段，是事件从最不精确的对象(document 对象)开始触发，然后到最精确\n- 目标阶段，捕获一直到找到事件的触发目标元素\n- 冒泡阶段，找到目标元素后开始往上冒泡，并且执行事件函数\n\n\n> 阻止事件冒泡方法：\n\n\n1. e.stopPropagation(); 只阻止冒泡\n\n\n2. return false; 不过这种方法即会阻止冒泡，也会阻止代码的执行","slug":"事件冒泡","published":1,"updated":"2021-04-13T06:00:51.805Z","_id":"cknfl9s5i0000k3whsobicx7c","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/assets/事件冒泡图.png\" alt=\"image\"></p>\n<blockquote>\n<p>事件冒泡分为三个阶段</p>\n</blockquote>\n<ul>\n<li>捕获阶段，这是最开始的阶段，是事件从最不精确的对象(document 对象)开始触发，然后到最精确</li>\n<li>目标阶段，捕获一直到找到事件的触发目标元素</li>\n<li>冒泡阶段，找到目标元素后开始往上冒泡，并且执行事件函数</li>\n</ul>\n<blockquote>\n<p>阻止事件冒泡方法：</p>\n</blockquote>\n<ol>\n<li>e.stopPropagation(); 只阻止冒泡</li>\n</ol>\n<ol start=\"2\">\n<li>return false; 不过这种方法即会阻止冒泡，也会阻止代码的执行</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/assets/事件冒泡图.png\" alt=\"image\"></p>\n<blockquote>\n<p>事件冒泡分为三个阶段</p>\n</blockquote>\n<ul>\n<li>捕获阶段，这是最开始的阶段，是事件从最不精确的对象(document 对象)开始触发，然后到最精确</li>\n<li>目标阶段，捕获一直到找到事件的触发目标元素</li>\n<li>冒泡阶段，找到目标元素后开始往上冒泡，并且执行事件函数</li>\n</ul>\n<blockquote>\n<p>阻止事件冒泡方法：</p>\n</blockquote>\n<ol>\n<li>e.stopPropagation(); 只阻止冒泡</li>\n</ol>\n<ol start=\"2\">\n<li>return false; 不过这种方法即会阻止冒泡，也会阻止代码的执行</li>\n</ol>\n"},{"title":"React16 中生命周期废旧立新的思考（为什么要废弃三个API）","date":"2021-04-13T16:40:05.000Z","_content":"\n\n\n> React 16废弃了三个生命周期函数，分别是：componentWillMount、componentWillUpdate以及componentWillReceiveProps。为何要废弃掉它们呢？\n在Fiber机制下，render阶段是允许暂停、终止和重启的。这就导致render阶段的生命周期都是有可能被重复执行的。而这几个被废弃的生命周API常年被滥用，它们在重复执行的过程中都存在着不容小觑的风险。比如在这些生命周期中使用setState、fetch发起异步请求、操作真实Dom等等。而这些操作完全可以转移到其他生命周期中去做。而在Fiber带来的异步渲染机制下，这些生命周期都有可能被重复执行，所以可能会导致非常严重的bug。即使没有开启异步渲染，React15中也可能导致一些严重的问题，比如在componentWillReceiveProps 和 componentWillUpdate里滥用setState导致重复渲染死循环。\n\n\n>总的来说，React16 改造生命周期的主要动机还是为了配合Fiber架构带来的异步渲染机制。在这个改造过程中，React团队针对生命周期中长期被滥用的部分推行了强制性的最佳实践。这样做首先确保了Fiber机制下数据和视图的安全性，同时也确保了生命周期方法的行为更加纯粹、可控、可预测。\n\n\n## 相关文章\n- [React15 和 React16 生命周期区别对比](hhttp://42.192.139.254:7777/2021/04/14/React15%20%E5%92%8C%20React16%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/)\n- [React Fiber架构设计原理](http://42.192.139.254:7777/2021/04/14/React%20Fiber%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/)\n\n\n[摘要文章](https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)\n","source":"_posts/React16 中生命周期废旧立新的思考（为什么要废弃三个API）.md","raw":"---\ntitle: React16 中生命周期废旧立新的思考（为什么要废弃三个API）\ndate: 2021-04-14 00:40:05\ntags: [前端, react]\ncategories: 技术\n---\n\n\n\n> React 16废弃了三个生命周期函数，分别是：componentWillMount、componentWillUpdate以及componentWillReceiveProps。为何要废弃掉它们呢？\n在Fiber机制下，render阶段是允许暂停、终止和重启的。这就导致render阶段的生命周期都是有可能被重复执行的。而这几个被废弃的生命周API常年被滥用，它们在重复执行的过程中都存在着不容小觑的风险。比如在这些生命周期中使用setState、fetch发起异步请求、操作真实Dom等等。而这些操作完全可以转移到其他生命周期中去做。而在Fiber带来的异步渲染机制下，这些生命周期都有可能被重复执行，所以可能会导致非常严重的bug。即使没有开启异步渲染，React15中也可能导致一些严重的问题，比如在componentWillReceiveProps 和 componentWillUpdate里滥用setState导致重复渲染死循环。\n\n\n>总的来说，React16 改造生命周期的主要动机还是为了配合Fiber架构带来的异步渲染机制。在这个改造过程中，React团队针对生命周期中长期被滥用的部分推行了强制性的最佳实践。这样做首先确保了Fiber机制下数据和视图的安全性，同时也确保了生命周期方法的行为更加纯粹、可控、可预测。\n\n\n## 相关文章\n- [React15 和 React16 生命周期区别对比](hhttp://42.192.139.254:7777/2021/04/14/React15%20%E5%92%8C%20React16%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/)\n- [React Fiber架构设计原理](http://42.192.139.254:7777/2021/04/14/React%20Fiber%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/)\n\n\n[摘要文章](https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)\n","slug":"React16 中生命周期废旧立新的思考（为什么要废弃三个API）","published":1,"updated":"2021-04-13T16:58:37.283Z","_id":"ckng98pvq0000f0whpu6aodjv","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>React 16废弃了三个生命周期函数，分别是：componentWillMount、componentWillUpdate以及componentWillReceiveProps。为何要废弃掉它们呢？<br>在Fiber机制下，render阶段是允许暂停、终止和重启的。这就导致render阶段的生命周期都是有可能被重复执行的。而这几个被废弃的生命周API常年被滥用，它们在重复执行的过程中都存在着不容小觑的风险。比如在这些生命周期中使用setState、fetch发起异步请求、操作真实Dom等等。而这些操作完全可以转移到其他生命周期中去做。而在Fiber带来的异步渲染机制下，这些生命周期都有可能被重复执行，所以可能会导致非常严重的bug。即使没有开启异步渲染，React15中也可能导致一些严重的问题，比如在componentWillReceiveProps 和 componentWillUpdate里滥用setState导致重复渲染死循环。</p>\n</blockquote>\n<blockquote>\n<p>总的来说，React16 改造生命周期的主要动机还是为了配合Fiber架构带来的异步渲染机制。在这个改造过程中，React团队针对生命周期中长期被滥用的部分推行了强制性的最佳实践。这样做首先确保了Fiber机制下数据和视图的安全性，同时也确保了生命周期方法的行为更加纯粹、可控、可预测。</p>\n</blockquote>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ul>\n<li><a href=\"hhttp://42.192.139.254:7777/2021/04/14/React15%20%E5%92%8C%20React16%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/\" target=\"_blank\" rel=\"noopener\">React15 和 React16 生命周期区别对比</a></li>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React%20Fiber%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/\" target=\"_blank\" rel=\"noopener\">React Fiber架构设计原理</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control\" target=\"_blank\" rel=\"noopener\">摘要文章</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>React 16废弃了三个生命周期函数，分别是：componentWillMount、componentWillUpdate以及componentWillReceiveProps。为何要废弃掉它们呢？<br>在Fiber机制下，render阶段是允许暂停、终止和重启的。这就导致render阶段的生命周期都是有可能被重复执行的。而这几个被废弃的生命周API常年被滥用，它们在重复执行的过程中都存在着不容小觑的风险。比如在这些生命周期中使用setState、fetch发起异步请求、操作真实Dom等等。而这些操作完全可以转移到其他生命周期中去做。而在Fiber带来的异步渲染机制下，这些生命周期都有可能被重复执行，所以可能会导致非常严重的bug。即使没有开启异步渲染，React15中也可能导致一些严重的问题，比如在componentWillReceiveProps 和 componentWillUpdate里滥用setState导致重复渲染死循环。</p>\n</blockquote>\n<blockquote>\n<p>总的来说，React16 改造生命周期的主要动机还是为了配合Fiber架构带来的异步渲染机制。在这个改造过程中，React团队针对生命周期中长期被滥用的部分推行了强制性的最佳实践。这样做首先确保了Fiber机制下数据和视图的安全性，同时也确保了生命周期方法的行为更加纯粹、可控、可预测。</p>\n</blockquote>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ul>\n<li><a href=\"hhttp://42.192.139.254:7777/2021/04/14/React15%20%E5%92%8C%20React16%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/\" target=\"_blank\" rel=\"noopener\">React15 和 React16 生命周期区别对比</a></li>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React%20Fiber%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/\" target=\"_blank\" rel=\"noopener\">React Fiber架构设计原理</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control\" target=\"_blank\" rel=\"noopener\">摘要文章</a></p>\n"},{"title":"React15 和 React16 生命周期区别对比","date":"2021-04-13T16:45:13.000Z","_content":"\n\n\n## getDerivedStateFromProps 和 componentWillMount\n> 为何React 16要替换掉 componentWillMount 呢？\n其实 componentWillMount 的存在不仅鸡肋，而且风险极高。很多开发者（也包括我）在React15的 componentWillMount 中或多或少都栽过跟头，喜欢在其中去写一些异步代码和初始化操作，从而造成组件数据或真实Dom渲染上的一系列问题。总的来说，getDerivedStateFromProps并不是想要替代 componentWillMount，因为 componentWillMount 就应该被废弃。\n\n\n## getDerivedStateFromProps 和 componentWillReceiveProps\n> 为何React 16要替换掉 componentWillReceiveProps 呢？\n首先，getDerivedStateFromProps 是作为一个试图替代 componentWillReceiveProps 的API出现的，但是，它又不完全等于 componentWillReceiveProps。我们前面说过，getDerivedStateFromProps有且仅有一个用途：使用props 来 派生/更新 state。所以，getDerivedStateFromProps 非常专注，它的用途非常简单。而 componentWillReceiveProps 中可以做更多的事，这样说来，componentWillReceiveProps比getDerivedStateFromProps功能更强大啊，为何要被替换掉呢？其实，一个API并非越庞大越复杂才越优秀。getDerivedStateFromProps正是在componentWillReceiveProps上做了合理的减法。从getDerivedStateFromProps 被定义成静态方法就可以看出React团队是为了通过对生命周期方法的限制来帮助开发者们避免掉一些不必要的坑。React 16正是在强制推行“只用getDerivedStateFromProps来完成props到state的映射”，从根源上帮开发者避免不合理的编程方式以及对生命周期的滥用。\n\n\n## getSnapshotBeforeUpdate 和 componentWillUpdate\n> 我们前面说过，getSnapshotBeforeUpdate的设计初衷就是为了和componentDidUpdate 一起涵盖过时的 componentWillUpdate方法的所有用例。所以，他们的区别其实与前面 getDerivedStateFromProps 和 componentWillReceiveProps 的区别类似。至于 componentWillUpdate 为何非死不可呢，关键还是因为它挡了新的 Fiber 架构的路。\n\n\n## 相关文章\n- [React Fiber架构设计原理](http://42.192.139.254:7777/2021/04/14/React%20Fiber%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/)\n- [React16 中生命周期废旧立新的思考（为什么要废弃三个API）](http://42.192.139.254:7777/2021/04/14/React16%20%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BA%9F%E6%97%A7%E7%AB%8B%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E4%B8%89%E4%B8%AAAPI%EF%BC%89/)\n\n\n[摘要文章](https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)","source":"_posts/React15 和 React16 生命周期区别对比.md","raw":"---\ntitle: React15 和 React16 生命周期区别对比\ndate: 2021-04-14 00:45:13\ntags: [前端, react]\ncategories: 技术\n---\n\n\n\n## getDerivedStateFromProps 和 componentWillMount\n> 为何React 16要替换掉 componentWillMount 呢？\n其实 componentWillMount 的存在不仅鸡肋，而且风险极高。很多开发者（也包括我）在React15的 componentWillMount 中或多或少都栽过跟头，喜欢在其中去写一些异步代码和初始化操作，从而造成组件数据或真实Dom渲染上的一系列问题。总的来说，getDerivedStateFromProps并不是想要替代 componentWillMount，因为 componentWillMount 就应该被废弃。\n\n\n## getDerivedStateFromProps 和 componentWillReceiveProps\n> 为何React 16要替换掉 componentWillReceiveProps 呢？\n首先，getDerivedStateFromProps 是作为一个试图替代 componentWillReceiveProps 的API出现的，但是，它又不完全等于 componentWillReceiveProps。我们前面说过，getDerivedStateFromProps有且仅有一个用途：使用props 来 派生/更新 state。所以，getDerivedStateFromProps 非常专注，它的用途非常简单。而 componentWillReceiveProps 中可以做更多的事，这样说来，componentWillReceiveProps比getDerivedStateFromProps功能更强大啊，为何要被替换掉呢？其实，一个API并非越庞大越复杂才越优秀。getDerivedStateFromProps正是在componentWillReceiveProps上做了合理的减法。从getDerivedStateFromProps 被定义成静态方法就可以看出React团队是为了通过对生命周期方法的限制来帮助开发者们避免掉一些不必要的坑。React 16正是在强制推行“只用getDerivedStateFromProps来完成props到state的映射”，从根源上帮开发者避免不合理的编程方式以及对生命周期的滥用。\n\n\n## getSnapshotBeforeUpdate 和 componentWillUpdate\n> 我们前面说过，getSnapshotBeforeUpdate的设计初衷就是为了和componentDidUpdate 一起涵盖过时的 componentWillUpdate方法的所有用例。所以，他们的区别其实与前面 getDerivedStateFromProps 和 componentWillReceiveProps 的区别类似。至于 componentWillUpdate 为何非死不可呢，关键还是因为它挡了新的 Fiber 架构的路。\n\n\n## 相关文章\n- [React Fiber架构设计原理](http://42.192.139.254:7777/2021/04/14/React%20Fiber%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/)\n- [React16 中生命周期废旧立新的思考（为什么要废弃三个API）](http://42.192.139.254:7777/2021/04/14/React16%20%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BA%9F%E6%97%A7%E7%AB%8B%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E4%B8%89%E4%B8%AAAPI%EF%BC%89/)\n\n\n[摘要文章](https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)","slug":"React15 和 React16 生命周期区别对比","published":1,"updated":"2021-04-13T16:57:09.440Z","_id":"ckng9exc200001cwh8xqwb3ic","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"getDerivedStateFromProps-和-componentWillMount\"><a href=\"#getDerivedStateFromProps-和-componentWillMount\" class=\"headerlink\" title=\"getDerivedStateFromProps 和 componentWillMount\"></a>getDerivedStateFromProps 和 componentWillMount</h2><blockquote>\n<p>为何React 16要替换掉 componentWillMount 呢？<br>其实 componentWillMount 的存在不仅鸡肋，而且风险极高。很多开发者（也包括我）在React15的 componentWillMount 中或多或少都栽过跟头，喜欢在其中去写一些异步代码和初始化操作，从而造成组件数据或真实Dom渲染上的一系列问题。总的来说，getDerivedStateFromProps并不是想要替代 componentWillMount，因为 componentWillMount 就应该被废弃。</p>\n</blockquote>\n<h2 id=\"getDerivedStateFromProps-和-componentWillReceiveProps\"><a href=\"#getDerivedStateFromProps-和-componentWillReceiveProps\" class=\"headerlink\" title=\"getDerivedStateFromProps 和 componentWillReceiveProps\"></a>getDerivedStateFromProps 和 componentWillReceiveProps</h2><blockquote>\n<p>为何React 16要替换掉 componentWillReceiveProps 呢？<br>首先，getDerivedStateFromProps 是作为一个试图替代 componentWillReceiveProps 的API出现的，但是，它又不完全等于 componentWillReceiveProps。我们前面说过，getDerivedStateFromProps有且仅有一个用途：使用props 来 派生/更新 state。所以，getDerivedStateFromProps 非常专注，它的用途非常简单。而 componentWillReceiveProps 中可以做更多的事，这样说来，componentWillReceiveProps比getDerivedStateFromProps功能更强大啊，为何要被替换掉呢？其实，一个API并非越庞大越复杂才越优秀。getDerivedStateFromProps正是在componentWillReceiveProps上做了合理的减法。从getDerivedStateFromProps 被定义成静态方法就可以看出React团队是为了通过对生命周期方法的限制来帮助开发者们避免掉一些不必要的坑。React 16正是在强制推行“只用getDerivedStateFromProps来完成props到state的映射”，从根源上帮开发者避免不合理的编程方式以及对生命周期的滥用。</p>\n</blockquote>\n<h2 id=\"getSnapshotBeforeUpdate-和-componentWillUpdate\"><a href=\"#getSnapshotBeforeUpdate-和-componentWillUpdate\" class=\"headerlink\" title=\"getSnapshotBeforeUpdate 和 componentWillUpdate\"></a>getSnapshotBeforeUpdate 和 componentWillUpdate</h2><blockquote>\n<p>我们前面说过，getSnapshotBeforeUpdate的设计初衷就是为了和componentDidUpdate 一起涵盖过时的 componentWillUpdate方法的所有用例。所以，他们的区别其实与前面 getDerivedStateFromProps 和 componentWillReceiveProps 的区别类似。至于 componentWillUpdate 为何非死不可呢，关键还是因为它挡了新的 Fiber 架构的路。</p>\n</blockquote>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ul>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React%20Fiber%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/\" target=\"_blank\" rel=\"noopener\">React Fiber架构设计原理</a></li>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React16%20%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BA%9F%E6%97%A7%E7%AB%8B%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E4%B8%89%E4%B8%AAAPI%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">React16 中生命周期废旧立新的思考（为什么要废弃三个API）</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control\" target=\"_blank\" rel=\"noopener\">摘要文章</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"getDerivedStateFromProps-和-componentWillMount\"><a href=\"#getDerivedStateFromProps-和-componentWillMount\" class=\"headerlink\" title=\"getDerivedStateFromProps 和 componentWillMount\"></a>getDerivedStateFromProps 和 componentWillMount</h2><blockquote>\n<p>为何React 16要替换掉 componentWillMount 呢？<br>其实 componentWillMount 的存在不仅鸡肋，而且风险极高。很多开发者（也包括我）在React15的 componentWillMount 中或多或少都栽过跟头，喜欢在其中去写一些异步代码和初始化操作，从而造成组件数据或真实Dom渲染上的一系列问题。总的来说，getDerivedStateFromProps并不是想要替代 componentWillMount，因为 componentWillMount 就应该被废弃。</p>\n</blockquote>\n<h2 id=\"getDerivedStateFromProps-和-componentWillReceiveProps\"><a href=\"#getDerivedStateFromProps-和-componentWillReceiveProps\" class=\"headerlink\" title=\"getDerivedStateFromProps 和 componentWillReceiveProps\"></a>getDerivedStateFromProps 和 componentWillReceiveProps</h2><blockquote>\n<p>为何React 16要替换掉 componentWillReceiveProps 呢？<br>首先，getDerivedStateFromProps 是作为一个试图替代 componentWillReceiveProps 的API出现的，但是，它又不完全等于 componentWillReceiveProps。我们前面说过，getDerivedStateFromProps有且仅有一个用途：使用props 来 派生/更新 state。所以，getDerivedStateFromProps 非常专注，它的用途非常简单。而 componentWillReceiveProps 中可以做更多的事，这样说来，componentWillReceiveProps比getDerivedStateFromProps功能更强大啊，为何要被替换掉呢？其实，一个API并非越庞大越复杂才越优秀。getDerivedStateFromProps正是在componentWillReceiveProps上做了合理的减法。从getDerivedStateFromProps 被定义成静态方法就可以看出React团队是为了通过对生命周期方法的限制来帮助开发者们避免掉一些不必要的坑。React 16正是在强制推行“只用getDerivedStateFromProps来完成props到state的映射”，从根源上帮开发者避免不合理的编程方式以及对生命周期的滥用。</p>\n</blockquote>\n<h2 id=\"getSnapshotBeforeUpdate-和-componentWillUpdate\"><a href=\"#getSnapshotBeforeUpdate-和-componentWillUpdate\" class=\"headerlink\" title=\"getSnapshotBeforeUpdate 和 componentWillUpdate\"></a>getSnapshotBeforeUpdate 和 componentWillUpdate</h2><blockquote>\n<p>我们前面说过，getSnapshotBeforeUpdate的设计初衷就是为了和componentDidUpdate 一起涵盖过时的 componentWillUpdate方法的所有用例。所以，他们的区别其实与前面 getDerivedStateFromProps 和 componentWillReceiveProps 的区别类似。至于 componentWillUpdate 为何非死不可呢，关键还是因为它挡了新的 Fiber 架构的路。</p>\n</blockquote>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ul>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React%20Fiber%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/\" target=\"_blank\" rel=\"noopener\">React Fiber架构设计原理</a></li>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React16%20%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BA%9F%E6%97%A7%E7%AB%8B%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E4%B8%89%E4%B8%AAAPI%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">React16 中生命周期废旧立新的思考（为什么要废弃三个API）</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control\" target=\"_blank\" rel=\"noopener\">摘要文章</a></p>\n"},{"title":"React Fiber架构设计原理","date":"2021-04-13T16:49:39.000Z","_content":"\n\n\n## React Fiber架构设计原理\n\n\n> Fiber是React16对React核心算法的一次重写，Fiber会使原本同步的渲染过程变成异步的。\n在React16之前，每当我们触发一次组件的更新，React都会构建一颗新的虚拟Dom树，通过与上一次的虚拟Dom树进行diff，实现对Dom的定向更新。这个过程，是一个递归的过程。\n同步渲染的递归调用栈是非常深的。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，变回牢牢抓住主线程不放，直至递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。\n而Fiber正好能够解决掉这个风险：Fiber会将一个大的更新任务拆解成许多小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。\nFiber架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的。根据能否被打断这一标准，React16 的生命周期被划分为了render和commit两个阶段，而commit又被细分为了pre-commit和commit。\n![react渲染流程图](https://img-blog.csdnimg.cn/20210130165157234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NzE5MzQ5,size_16,color_FFFFFF,t_70)\n**render 阶段：纯净且没有副作用，可能会被React暂停、终止或重新启动。**\n**pre-commit 阶段：可以读取Dom。**\n**commit 阶段：可以使用Dom，运行副作用，安排更新。**\n总的来说，render阶段在执行过程中允许被打断，而commit阶段则总是同步执行的。\n\n\n## 相关文章\n- [React15 和 React16 生命周期区别对比](http://42.192.139.254:7777/2021/04/14/React15%20%E5%92%8C%20React16%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/)\n- [React16 中生命周期废旧立新的思考（为什么要废弃三个API）](http://42.192.139.254:7777/2021/04/14/React16%20%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BA%9F%E6%97%A7%E7%AB%8B%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E4%B8%89%E4%B8%AAAPI%EF%BC%89/)\n\n\n[摘要文章](https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)\n\n","source":"_posts/React Fiber架构设计原理.md","raw":"---\ntitle: React Fiber架构设计原理\ndate: 2021-04-14 00:49:39\ntags: [前端, react]\ncategories: 技术\n---\n\n\n\n## React Fiber架构设计原理\n\n\n> Fiber是React16对React核心算法的一次重写，Fiber会使原本同步的渲染过程变成异步的。\n在React16之前，每当我们触发一次组件的更新，React都会构建一颗新的虚拟Dom树，通过与上一次的虚拟Dom树进行diff，实现对Dom的定向更新。这个过程，是一个递归的过程。\n同步渲染的递归调用栈是非常深的。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，变回牢牢抓住主线程不放，直至递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。\n而Fiber正好能够解决掉这个风险：Fiber会将一个大的更新任务拆解成许多小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。\nFiber架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的。根据能否被打断这一标准，React16 的生命周期被划分为了render和commit两个阶段，而commit又被细分为了pre-commit和commit。\n![react渲染流程图](https://img-blog.csdnimg.cn/20210130165157234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NzE5MzQ5,size_16,color_FFFFFF,t_70)\n**render 阶段：纯净且没有副作用，可能会被React暂停、终止或重新启动。**\n**pre-commit 阶段：可以读取Dom。**\n**commit 阶段：可以使用Dom，运行副作用，安排更新。**\n总的来说，render阶段在执行过程中允许被打断，而commit阶段则总是同步执行的。\n\n\n## 相关文章\n- [React15 和 React16 生命周期区别对比](http://42.192.139.254:7777/2021/04/14/React15%20%E5%92%8C%20React16%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/)\n- [React16 中生命周期废旧立新的思考（为什么要废弃三个API）](http://42.192.139.254:7777/2021/04/14/React16%20%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BA%9F%E6%97%A7%E7%AB%8B%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E4%B8%89%E4%B8%AAAPI%EF%BC%89/)\n\n\n[摘要文章](https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)\n\n","slug":"React Fiber架构设计原理","published":1,"updated":"2021-04-13T16:56:14.195Z","_id":"ckng9kneo0000mjwh3fvu3h52","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"React-Fiber架构设计原理\"><a href=\"#React-Fiber架构设计原理\" class=\"headerlink\" title=\"React Fiber架构设计原理\"></a>React Fiber架构设计原理</h2><blockquote>\n<p>Fiber是React16对React核心算法的一次重写，Fiber会使原本同步的渲染过程变成异步的。<br>在React16之前，每当我们触发一次组件的更新，React都会构建一颗新的虚拟Dom树，通过与上一次的虚拟Dom树进行diff，实现对Dom的定向更新。这个过程，是一个递归的过程。<br>同步渲染的递归调用栈是非常深的。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，变回牢牢抓住主线程不放，直至递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。<br>而Fiber正好能够解决掉这个风险：Fiber会将一个大的更新任务拆解成许多小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。<br>Fiber架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的。根据能否被打断这一标准，React16 的生命周期被划分为了render和commit两个阶段，而commit又被细分为了pre-commit和commit。<br><img src=\"https://img-blog.csdnimg.cn/20210130165157234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NzE5MzQ5,size_16,color_FFFFFF,t_70\" alt=\"react渲染流程图\"><br><strong>render 阶段：纯净且没有副作用，可能会被React暂停、终止或重新启动。</strong><br><strong>pre-commit 阶段：可以读取Dom。</strong><br><strong>commit 阶段：可以使用Dom，运行副作用，安排更新。</strong><br>总的来说，render阶段在执行过程中允许被打断，而commit阶段则总是同步执行的。</p>\n</blockquote>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ul>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React15%20%E5%92%8C%20React16%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/\" target=\"_blank\" rel=\"noopener\">React15 和 React16 生命周期区别对比</a></li>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React16%20%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BA%9F%E6%97%A7%E7%AB%8B%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E4%B8%89%E4%B8%AAAPI%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">React16 中生命周期废旧立新的思考（为什么要废弃三个API）</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control\" target=\"_blank\" rel=\"noopener\">摘要文章</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React-Fiber架构设计原理\"><a href=\"#React-Fiber架构设计原理\" class=\"headerlink\" title=\"React Fiber架构设计原理\"></a>React Fiber架构设计原理</h2><blockquote>\n<p>Fiber是React16对React核心算法的一次重写，Fiber会使原本同步的渲染过程变成异步的。<br>在React16之前，每当我们触发一次组件的更新，React都会构建一颗新的虚拟Dom树，通过与上一次的虚拟Dom树进行diff，实现对Dom的定向更新。这个过程，是一个递归的过程。<br>同步渲染的递归调用栈是非常深的。这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，变回牢牢抓住主线程不放，直至递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。因此若渲染时间稍微长一点，页面就会面临卡顿甚至卡死的风险。<br>而Fiber正好能够解决掉这个风险：Fiber会将一个大的更新任务拆解成许多小任务。每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。<br>Fiber架构的重要特征就是可以被打断的异步渲染模式。但这个“打断”是有原则的。根据能否被打断这一标准，React16 的生命周期被划分为了render和commit两个阶段，而commit又被细分为了pre-commit和commit。<br><img src=\"https://img-blog.csdnimg.cn/20210130165157234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NzE5MzQ5,size_16,color_FFFFFF,t_70\" alt=\"react渲染流程图\"><br><strong>render 阶段：纯净且没有副作用，可能会被React暂停、终止或重新启动。</strong><br><strong>pre-commit 阶段：可以读取Dom。</strong><br><strong>commit 阶段：可以使用Dom，运行副作用，安排更新。</strong><br>总的来说，render阶段在执行过程中允许被打断，而commit阶段则总是同步执行的。</p>\n</blockquote>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ul>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React15%20%E5%92%8C%20React16%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94/\" target=\"_blank\" rel=\"noopener\">React15 和 React16 生命周期区别对比</a></li>\n<li><a href=\"http://42.192.139.254:7777/2021/04/14/React16%20%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BA%9F%E6%97%A7%E7%AB%8B%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E4%B8%89%E4%B8%AAAPI%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">React16 中生命周期废旧立新的思考（为什么要废弃三个API）</a></li>\n</ul>\n<p><a href=\"https://blog.csdn.net/qq_24719349/article/details/113397110?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control\" target=\"_blank\" rel=\"noopener\">摘要文章</a></p>\n"},{"title":"Object对象下的方法","date":"2021-04-14T03:46:13.000Z","_content":"\n## Object.create\n> 用法1\n\nObject.create()方法创建的对象时，属性是在原型下面的，也可以直接访问 b.rep // {rep: \"apple\"} ,此时这个值不是吧b自身的，是它通过原型链proto来访问到b的值。\n```\n// new Object() 方式创建\nvar a = {  rep : 'apple' }\nvar b = new Object(a)\nconsole.log(b) // {rep: \"apple\"}\nconsole.log(b.__proto__) // {}\nconsole.log(b.rep) // {rep: \"apple\"}\n\n\n// Object.create() 方式创建\nvar a = { rep: 'apple' }\nvar b = Object.create(a)\nconsole.log(b)  // {}\nconsole.log(b.__proto__) // {rep: \"apple\"}\nconsole.log(b.rep) // {rep: \"apple\"}\n```\n\n\n> 用法2\nObject.create() 用第二个参数来创建非空对象的属性描述符默认是为false的，而构造函数或字面量方法创建的对象属性的描述符默认为true。\n\n```\n// 创建一个以另一个空对象为原型,且拥有一个属性p的对象\no = Object.create({}, { p: { value: 42 } })\n\n\n// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:\no.p = 24\no.p\n//42\n\n\no.q = 12\nfor (var prop in o) {\n   console.log(prop)\n}\n//\"q\"\n\n\ndelete o.p\n//false\n```\n\n\n## Object.assign\n```\nvar triangle = {a: 1, b: 2, c: 3};\n\n\nfunction ColoredTriangle() {\n  this.color = 'red';\n}\n\n\n//ColoredTriangle.prototype = triangle;  //ColoredTriangle.prototype.constructor === ColoredTriangle// false\nObject.assign(ColoredTriangle.prototype, triangle) //ColoredTriangle.prototype.constructor === ColoredTriangle// true\n\n\nvar c = new ColoredTriangle();\n```\n\n\n>因为 Object.assing 是不能拷贝到继承或原型上的方法的。所以 实例c2 没有 a 这个属性。\n\n\n```\n\n\n//对象拷贝\nvar c2 = Object.assign({},c)\nconsole.log(c2.color); //red\nconsole.log(c2.a); //undefined\n```\n> 解决办法1：就是创建一个空对象，里面有原型属性\n\n\n```\n//创建一个有原型属性的空对象\nvar obj = Object.create({a:1, b: 2})\n\n\n\n//对象拷贝\nvar c2 = Object.assign(obj, c);\nconsole.log(c2.color); //red\nconsole.log(c2.a); //undefined\n```\n> 解决办法2：\nObject.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象c2 的原型上。\nObject.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。（推荐）\n\n\n```\nvar c = new ColoredTriangle();\nvar c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));\n\n\nconsole.log(c2.color); // red\nconsole.log(c2.a); // 1\n```\n\n\n> 为什么使用Object.getOwnPropertyDescriptors，因为这个方法可以拿到get描述符\n```\nvar c = new ColoredTriangle();\nObject.defineProperty(c,'colorGet', {\n    enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性\n    get(){\n        return \"Could it return \" + this.color\n    }\n});\n\n\nvar c3 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));\n/*\n{\n    color: 'red',\n    colorGet: 'Could it return red',\n    get colorGet: fn,\n    __proto__: {\n       a: 1\n       b: 2\n       c: 3\n   }\n}\n\n\n*/\n```\n\n\n\n\n## Object.getPrototypeOf \n\n\n## Object.setPrototypeOf \n\n\n\n## Ojbect.getOwnPropertyDescriptors\n\n\n## Object.defineProperty\n\n> 方法会直接在一个对象上定义一个新属性，可以在其描述符中控制属性的各种操作\n\n\n```\nconst object1 = {};\n\n\nObject.defineProperty(object1, 'property1', {\n  value: 42,\n  writable: false\n});\n```\n## Object. freeze，Object.seal\n> 将对象中的描述符中控制属性全部改为false，这样一来就不能修改，不能删除\n\n\n```\nvar obj = {aa:1,bb:2};\n// 两个方法类似\nObject.freeze(obj);\n\nObject.seal(obj);\n\n// 判断是否被这些方法操作过\nObject.isSealed(obj);\nObject.isFrozen(obj);\n\n```\n\n\n## obj.hasOwnProperty\n> 这个方法判断对象自身的属性值是否存在，原型里面的属性不会去判断\n\n\n```\nvar obj = {\n   aa: 123\n}\nobj.hasOwnProperty('aa');   // true\n\nobj.hasOwnProperty('toString'); //false\n\n```\n## obj.propertyIsEnumerable;\n> 是否可被枚举，在控制台输出能否直接看的，\n\n\n```\nvar obj = {\n   aa: 123\n}\nobj.hasOwnProperty('aa');   // true\n\nobj.hasOwnProperty('toString'); //false\n```\n\n\n\n\n\n\n[参考原文](https://www.jianshu.com/p/28d85bebe599)\n\n","source":"_posts/Object对象下的方法.md","raw":"---\ntitle: Object对象下的方法\ndate: 2021-04-14 11:46:13\ntags: [前端]\ncategories: 技术\n---\n\n## Object.create\n> 用法1\n\nObject.create()方法创建的对象时，属性是在原型下面的，也可以直接访问 b.rep // {rep: \"apple\"} ,此时这个值不是吧b自身的，是它通过原型链proto来访问到b的值。\n```\n// new Object() 方式创建\nvar a = {  rep : 'apple' }\nvar b = new Object(a)\nconsole.log(b) // {rep: \"apple\"}\nconsole.log(b.__proto__) // {}\nconsole.log(b.rep) // {rep: \"apple\"}\n\n\n// Object.create() 方式创建\nvar a = { rep: 'apple' }\nvar b = Object.create(a)\nconsole.log(b)  // {}\nconsole.log(b.__proto__) // {rep: \"apple\"}\nconsole.log(b.rep) // {rep: \"apple\"}\n```\n\n\n> 用法2\nObject.create() 用第二个参数来创建非空对象的属性描述符默认是为false的，而构造函数或字面量方法创建的对象属性的描述符默认为true。\n\n```\n// 创建一个以另一个空对象为原型,且拥有一个属性p的对象\no = Object.create({}, { p: { value: 42 } })\n\n\n// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:\no.p = 24\no.p\n//42\n\n\no.q = 12\nfor (var prop in o) {\n   console.log(prop)\n}\n//\"q\"\n\n\ndelete o.p\n//false\n```\n\n\n## Object.assign\n```\nvar triangle = {a: 1, b: 2, c: 3};\n\n\nfunction ColoredTriangle() {\n  this.color = 'red';\n}\n\n\n//ColoredTriangle.prototype = triangle;  //ColoredTriangle.prototype.constructor === ColoredTriangle// false\nObject.assign(ColoredTriangle.prototype, triangle) //ColoredTriangle.prototype.constructor === ColoredTriangle// true\n\n\nvar c = new ColoredTriangle();\n```\n\n\n>因为 Object.assing 是不能拷贝到继承或原型上的方法的。所以 实例c2 没有 a 这个属性。\n\n\n```\n\n\n//对象拷贝\nvar c2 = Object.assign({},c)\nconsole.log(c2.color); //red\nconsole.log(c2.a); //undefined\n```\n> 解决办法1：就是创建一个空对象，里面有原型属性\n\n\n```\n//创建一个有原型属性的空对象\nvar obj = Object.create({a:1, b: 2})\n\n\n\n//对象拷贝\nvar c2 = Object.assign(obj, c);\nconsole.log(c2.color); //red\nconsole.log(c2.a); //undefined\n```\n> 解决办法2：\nObject.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象c2 的原型上。\nObject.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。（推荐）\n\n\n```\nvar c = new ColoredTriangle();\nvar c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));\n\n\nconsole.log(c2.color); // red\nconsole.log(c2.a); // 1\n```\n\n\n> 为什么使用Object.getOwnPropertyDescriptors，因为这个方法可以拿到get描述符\n```\nvar c = new ColoredTriangle();\nObject.defineProperty(c,'colorGet', {\n    enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性\n    get(){\n        return \"Could it return \" + this.color\n    }\n});\n\n\nvar c3 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));\n/*\n{\n    color: 'red',\n    colorGet: 'Could it return red',\n    get colorGet: fn,\n    __proto__: {\n       a: 1\n       b: 2\n       c: 3\n   }\n}\n\n\n*/\n```\n\n\n\n\n## Object.getPrototypeOf \n\n\n## Object.setPrototypeOf \n\n\n\n## Ojbect.getOwnPropertyDescriptors\n\n\n## Object.defineProperty\n\n> 方法会直接在一个对象上定义一个新属性，可以在其描述符中控制属性的各种操作\n\n\n```\nconst object1 = {};\n\n\nObject.defineProperty(object1, 'property1', {\n  value: 42,\n  writable: false\n});\n```\n## Object. freeze，Object.seal\n> 将对象中的描述符中控制属性全部改为false，这样一来就不能修改，不能删除\n\n\n```\nvar obj = {aa:1,bb:2};\n// 两个方法类似\nObject.freeze(obj);\n\nObject.seal(obj);\n\n// 判断是否被这些方法操作过\nObject.isSealed(obj);\nObject.isFrozen(obj);\n\n```\n\n\n## obj.hasOwnProperty\n> 这个方法判断对象自身的属性值是否存在，原型里面的属性不会去判断\n\n\n```\nvar obj = {\n   aa: 123\n}\nobj.hasOwnProperty('aa');   // true\n\nobj.hasOwnProperty('toString'); //false\n\n```\n## obj.propertyIsEnumerable;\n> 是否可被枚举，在控制台输出能否直接看的，\n\n\n```\nvar obj = {\n   aa: 123\n}\nobj.hasOwnProperty('aa');   // true\n\nobj.hasOwnProperty('toString'); //false\n```\n\n\n\n\n\n\n[参考原文](https://www.jianshu.com/p/28d85bebe599)\n\n","slug":"Object对象下的方法","published":1,"updated":"2021-04-14T14:16:04.804Z","_id":"ckngx630f0000mnwhkyuaff8d","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create\"></a>Object.create</h2><blockquote>\n<p>用法1</p>\n</blockquote>\n<p>Object.create()方法创建的对象时，属性是在原型下面的，也可以直接访问 b.rep // {rep: “apple”} ,此时这个值不是吧b自身的，是它通过原型链proto来访问到b的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// new Object() 方式创建</span><br><span class=\"line\">var a = &#123;  rep : &apos;apple&apos; &#125;</span><br><span class=\"line\">var b = new Object(a)</span><br><span class=\"line\">console.log(b) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class=\"line\">console.log(b.__proto__) // &#123;&#125;</span><br><span class=\"line\">console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// Object.create() 方式创建</span><br><span class=\"line\">var a = &#123; rep: &apos;apple&apos; &#125;</span><br><span class=\"line\">var b = Object.create(a)</span><br><span class=\"line\">console.log(b)  // &#123;&#125;</span><br><span class=\"line\">console.log(b.__proto__) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class=\"line\">console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>用法2<br>Object.create() 用第二个参数来创建非空对象的属性描述符默认是为false的，而构造函数或字面量方法创建的对象属性的描述符默认为true。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</span><br><span class=\"line\">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</span><br><span class=\"line\">o.p = 24</span><br><span class=\"line\">o.p</span><br><span class=\"line\">//42</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">o.q = 12</span><br><span class=\"line\">for (var prop in o) &#123;</span><br><span class=\"line\">   console.log(prop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//&quot;q&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">delete o.p</span><br><span class=\"line\">//false</span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign\"></a>Object.assign</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var triangle = &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function ColoredTriangle() &#123;</span><br><span class=\"line\">  this.color = &apos;red&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ColoredTriangle.prototype = triangle;  //ColoredTriangle.prototype.constructor === ColoredTriangle// false</span><br><span class=\"line\">Object.assign(ColoredTriangle.prototype, triangle) //ColoredTriangle.prototype.constructor === ColoredTriangle// true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var c = new ColoredTriangle();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为 Object.assing 是不能拷贝到继承或原型上的方法的。所以 实例c2 没有 a 这个属性。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//对象拷贝</span><br><span class=\"line\">var c2 = Object.assign(&#123;&#125;,c)</span><br><span class=\"line\">console.log(c2.color); //red</span><br><span class=\"line\">console.log(c2.a); //undefined</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>解决办法1：就是创建一个空对象，里面有原型属性</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建一个有原型属性的空对象</span><br><span class=\"line\">var obj = Object.create(&#123;a:1, b: 2&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//对象拷贝</span><br><span class=\"line\">var c2 = Object.assign(obj, c);</span><br><span class=\"line\">console.log(c2.color); //red</span><br><span class=\"line\">console.log(c2.a); //undefined</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>解决办法2：<br>Object.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象c2 的原型上。<br>Object.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。（推荐）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var c = new ColoredTriangle();</span><br><span class=\"line\">var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(c2.color); // red</span><br><span class=\"line\">console.log(c2.a); // 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么使用Object.getOwnPropertyDescriptors，因为这个方法可以拿到get描述符<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var c = new ColoredTriangle();</span><br><span class=\"line\">Object.defineProperty(c,&apos;colorGet&apos;, &#123;</span><br><span class=\"line\">    enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性</span><br><span class=\"line\">    get()&#123;</span><br><span class=\"line\">        return &quot;Could it return &quot; + this.color</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var c3 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));</span><br><span class=\"line\">/*</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    color: &apos;red&apos;,</span><br><span class=\"line\">    colorGet: &apos;Could it return red&apos;,</span><br><span class=\"line\">    get colorGet: fn,</span><br><span class=\"line\">    __proto__: &#123;</span><br><span class=\"line\">       a: 1</span><br><span class=\"line\">       b: 2</span><br><span class=\"line\">       c: 3</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf\"></a>Object.getPrototypeOf</h2><h2 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf\"></a>Object.setPrototypeOf</h2><h2 id=\"Ojbect-getOwnPropertyDescriptors\"><a href=\"#Ojbect-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Ojbect.getOwnPropertyDescriptors\"></a>Ojbect.getOwnPropertyDescriptors</h2><h2 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h2><blockquote>\n<p>方法会直接在一个对象上定义一个新属性，可以在其描述符中控制属性的各种操作</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const object1 = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(object1, &apos;property1&apos;, &#123;</span><br><span class=\"line\">  value: 42,</span><br><span class=\"line\">  writable: false</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-freeze，Object-seal\"><a href=\"#Object-freeze，Object-seal\" class=\"headerlink\" title=\"Object. freeze，Object.seal\"></a>Object. freeze，Object.seal</h2><blockquote>\n<p>将对象中的描述符中控制属性全部改为false，这样一来就不能修改，不能删除</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;aa:1,bb:2&#125;;</span><br><span class=\"line\">// 两个方法类似</span><br><span class=\"line\">Object.freeze(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">Object.seal(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否被这些方法操作过</span><br><span class=\"line\">Object.isSealed(obj);</span><br><span class=\"line\">Object.isFrozen(obj);</span><br></pre></td></tr></table></figure>\n<h2 id=\"obj-hasOwnProperty\"><a href=\"#obj-hasOwnProperty\" class=\"headerlink\" title=\"obj.hasOwnProperty\"></a>obj.hasOwnProperty</h2><blockquote>\n<p>这个方法判断对象自身的属性值是否存在，原型里面的属性不会去判断</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">   aa: 123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.hasOwnProperty(&apos;aa&apos;);   // true</span><br><span class=\"line\"></span><br><span class=\"line\">obj.hasOwnProperty(&apos;toString&apos;); //false</span><br></pre></td></tr></table></figure>\n<h2 id=\"obj-propertyIsEnumerable\"><a href=\"#obj-propertyIsEnumerable\" class=\"headerlink\" title=\"obj.propertyIsEnumerable;\"></a>obj.propertyIsEnumerable;</h2><blockquote>\n<p>是否可被枚举，在控制台输出能否直接看的，</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">   aa: 123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.hasOwnProperty(&apos;aa&apos;);   // true</span><br><span class=\"line\"></span><br><span class=\"line\">obj.hasOwnProperty(&apos;toString&apos;); //false</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.jianshu.com/p/28d85bebe599\" target=\"_blank\" rel=\"noopener\">参考原文</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create\"></a>Object.create</h2><blockquote>\n<p>用法1</p>\n</blockquote>\n<p>Object.create()方法创建的对象时，属性是在原型下面的，也可以直接访问 b.rep // {rep: “apple”} ,此时这个值不是吧b自身的，是它通过原型链proto来访问到b的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// new Object() 方式创建</span><br><span class=\"line\">var a = &#123;  rep : &apos;apple&apos; &#125;</span><br><span class=\"line\">var b = new Object(a)</span><br><span class=\"line\">console.log(b) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class=\"line\">console.log(b.__proto__) // &#123;&#125;</span><br><span class=\"line\">console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// Object.create() 方式创建</span><br><span class=\"line\">var a = &#123; rep: &apos;apple&apos; &#125;</span><br><span class=\"line\">var b = Object.create(a)</span><br><span class=\"line\">console.log(b)  // &#123;&#125;</span><br><span class=\"line\">console.log(b.__proto__) // &#123;rep: &quot;apple&quot;&#125;</span><br><span class=\"line\">console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>用法2<br>Object.create() 用第二个参数来创建非空对象的属性描述符默认是为false的，而构造函数或字面量方法创建的对象属性的描述符默认为true。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</span><br><span class=\"line\">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</span><br><span class=\"line\">o.p = 24</span><br><span class=\"line\">o.p</span><br><span class=\"line\">//42</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">o.q = 12</span><br><span class=\"line\">for (var prop in o) &#123;</span><br><span class=\"line\">   console.log(prop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//&quot;q&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">delete o.p</span><br><span class=\"line\">//false</span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign\"></a>Object.assign</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var triangle = &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function ColoredTriangle() &#123;</span><br><span class=\"line\">  this.color = &apos;red&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ColoredTriangle.prototype = triangle;  //ColoredTriangle.prototype.constructor === ColoredTriangle// false</span><br><span class=\"line\">Object.assign(ColoredTriangle.prototype, triangle) //ColoredTriangle.prototype.constructor === ColoredTriangle// true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var c = new ColoredTriangle();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为 Object.assing 是不能拷贝到继承或原型上的方法的。所以 实例c2 没有 a 这个属性。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//对象拷贝</span><br><span class=\"line\">var c2 = Object.assign(&#123;&#125;,c)</span><br><span class=\"line\">console.log(c2.color); //red</span><br><span class=\"line\">console.log(c2.a); //undefined</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>解决办法1：就是创建一个空对象，里面有原型属性</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建一个有原型属性的空对象</span><br><span class=\"line\">var obj = Object.create(&#123;a:1, b: 2&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//对象拷贝</span><br><span class=\"line\">var c2 = Object.assign(obj, c);</span><br><span class=\"line\">console.log(c2.color); //red</span><br><span class=\"line\">console.log(c2.a); //undefined</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>解决办法2：<br>Object.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象c2 的原型上。<br>Object.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。（推荐）</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var c = new ColoredTriangle();</span><br><span class=\"line\">var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(c2.color); // red</span><br><span class=\"line\">console.log(c2.a); // 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么使用Object.getOwnPropertyDescriptors，因为这个方法可以拿到get描述符<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var c = new ColoredTriangle();</span><br><span class=\"line\">Object.defineProperty(c,&apos;colorGet&apos;, &#123;</span><br><span class=\"line\">    enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性</span><br><span class=\"line\">    get()&#123;</span><br><span class=\"line\">        return &quot;Could it return &quot; + this.color</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var c3 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));</span><br><span class=\"line\">/*</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    color: &apos;red&apos;,</span><br><span class=\"line\">    colorGet: &apos;Could it return red&apos;,</span><br><span class=\"line\">    get colorGet: fn,</span><br><span class=\"line\">    __proto__: &#123;</span><br><span class=\"line\">       a: 1</span><br><span class=\"line\">       b: 2</span><br><span class=\"line\">       c: 3</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf\"></a>Object.getPrototypeOf</h2><h2 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf\"></a>Object.setPrototypeOf</h2><h2 id=\"Ojbect-getOwnPropertyDescriptors\"><a href=\"#Ojbect-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Ojbect.getOwnPropertyDescriptors\"></a>Ojbect.getOwnPropertyDescriptors</h2><h2 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h2><blockquote>\n<p>方法会直接在一个对象上定义一个新属性，可以在其描述符中控制属性的各种操作</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const object1 = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty(object1, &apos;property1&apos;, &#123;</span><br><span class=\"line\">  value: 42,</span><br><span class=\"line\">  writable: false</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-freeze，Object-seal\"><a href=\"#Object-freeze，Object-seal\" class=\"headerlink\" title=\"Object. freeze，Object.seal\"></a>Object. freeze，Object.seal</h2><blockquote>\n<p>将对象中的描述符中控制属性全部改为false，这样一来就不能修改，不能删除</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;aa:1,bb:2&#125;;</span><br><span class=\"line\">// 两个方法类似</span><br><span class=\"line\">Object.freeze(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">Object.seal(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否被这些方法操作过</span><br><span class=\"line\">Object.isSealed(obj);</span><br><span class=\"line\">Object.isFrozen(obj);</span><br></pre></td></tr></table></figure>\n<h2 id=\"obj-hasOwnProperty\"><a href=\"#obj-hasOwnProperty\" class=\"headerlink\" title=\"obj.hasOwnProperty\"></a>obj.hasOwnProperty</h2><blockquote>\n<p>这个方法判断对象自身的属性值是否存在，原型里面的属性不会去判断</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">   aa: 123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.hasOwnProperty(&apos;aa&apos;);   // true</span><br><span class=\"line\"></span><br><span class=\"line\">obj.hasOwnProperty(&apos;toString&apos;); //false</span><br></pre></td></tr></table></figure>\n<h2 id=\"obj-propertyIsEnumerable\"><a href=\"#obj-propertyIsEnumerable\" class=\"headerlink\" title=\"obj.propertyIsEnumerable;\"></a>obj.propertyIsEnumerable;</h2><blockquote>\n<p>是否可被枚举，在控制台输出能否直接看的，</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">   aa: 123</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.hasOwnProperty(&apos;aa&apos;);   // true</span><br><span class=\"line\"></span><br><span class=\"line\">obj.hasOwnProperty(&apos;toString&apos;); //false</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.jianshu.com/p/28d85bebe599\" target=\"_blank\" rel=\"noopener\">参考原文</a></p>\n"},{"title":"手动实现一个new方法","date":"2021-04-14T16:18:17.000Z","_content":"\n\n\n\n在调用 new 的过程中会发生以下四件事（摘自JavaScript高级程序设计，2019-07-22）：\n\n新生成一个对象\n将构造函数的作用域赋值给新对象（即绑定新对象的 this）\n执行构造函数中的代码（即为这个新对象添加属性）\n返回新对象\n\n构造一个最简单版 new：\n\n```\nfunction _new() {\n\t// 创建一个新对象\n    let newObj = {};  \n    // 获取构造函数\n    let Constructor = Array.prototype.shift.call(arguments);\n    // 连接新对象原型，新对象可以访问原型中的属性\n    newObj.__proto__ = Constructor.prototype;\n    // 执行构造函数，即绑定 this，并且为这个新对象添加属性\n    Constructor.apply(newObj, arguments);\n    // 返回该对象\n    return newObj;\n}\n```","source":"_posts/手动实现一个new方法.md","raw":"---\ntitle: 手动实现一个new方法\ndate: 2021-04-15 00:18:17\ntags: [前端]\ncategories: 技术\n---\n\n\n\n\n在调用 new 的过程中会发生以下四件事（摘自JavaScript高级程序设计，2019-07-22）：\n\n新生成一个对象\n将构造函数的作用域赋值给新对象（即绑定新对象的 this）\n执行构造函数中的代码（即为这个新对象添加属性）\n返回新对象\n\n构造一个最简单版 new：\n\n```\nfunction _new() {\n\t// 创建一个新对象\n    let newObj = {};  \n    // 获取构造函数\n    let Constructor = Array.prototype.shift.call(arguments);\n    // 连接新对象原型，新对象可以访问原型中的属性\n    newObj.__proto__ = Constructor.prototype;\n    // 执行构造函数，即绑定 this，并且为这个新对象添加属性\n    Constructor.apply(newObj, arguments);\n    // 返回该对象\n    return newObj;\n}\n```","slug":"手动实现一个new方法","published":1,"updated":"2021-04-14T16:19:20.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknhnsj970000ozwh6i6xfcu9","content":"<p>在调用 new 的过程中会发生以下四件事（摘自JavaScript高级程序设计，2019-07-22）：</p>\n<p>新生成一个对象<br>将构造函数的作用域赋值给新对象（即绑定新对象的 this）<br>执行构造函数中的代码（即为这个新对象添加属性）<br>返回新对象</p>\n<p>构造一个最简单版 new：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function _new() &#123;</span><br><span class=\"line\">\t// 创建一个新对象</span><br><span class=\"line\">    let newObj = &#123;&#125;;  </span><br><span class=\"line\">    // 获取构造函数</span><br><span class=\"line\">    let Constructor = Array.prototype.shift.call(arguments);</span><br><span class=\"line\">    // 连接新对象原型，新对象可以访问原型中的属性</span><br><span class=\"line\">    newObj.__proto__ = Constructor.prototype;</span><br><span class=\"line\">    // 执行构造函数，即绑定 this，并且为这个新对象添加属性</span><br><span class=\"line\">    Constructor.apply(newObj, arguments);</span><br><span class=\"line\">    // 返回该对象</span><br><span class=\"line\">    return newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>在调用 new 的过程中会发生以下四件事（摘自JavaScript高级程序设计，2019-07-22）：</p>\n<p>新生成一个对象<br>将构造函数的作用域赋值给新对象（即绑定新对象的 this）<br>执行构造函数中的代码（即为这个新对象添加属性）<br>返回新对象</p>\n<p>构造一个最简单版 new：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function _new() &#123;</span><br><span class=\"line\">\t// 创建一个新对象</span><br><span class=\"line\">    let newObj = &#123;&#125;;  </span><br><span class=\"line\">    // 获取构造函数</span><br><span class=\"line\">    let Constructor = Array.prototype.shift.call(arguments);</span><br><span class=\"line\">    // 连接新对象原型，新对象可以访问原型中的属性</span><br><span class=\"line\">    newObj.__proto__ = Constructor.prototype;</span><br><span class=\"line\">    // 执行构造函数，即绑定 this，并且为这个新对象添加属性</span><br><span class=\"line\">    Constructor.apply(newObj, arguments);</span><br><span class=\"line\">    // 返回该对象</span><br><span class=\"line\">    return newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"移动端适配","date":"2021-04-29T02:51:50.000Z","_content":"\n\n\n## Viewport 方案的核心思想：\n\n\n使用vw作为元素的布局单位\nvw作为布局单位，从底层根本上解决了不同尺寸屏幕的适配问题，因为每个屏幕的百分比是固定的、可预测、可控制的。\n\n\n从我们的实际开发工作出发，我们现在都是统一使用的iPhone6的视觉设计稿（即宽度为750px），那么100vw=750px，即1vw = 7.5px。那么如果设计稿上某一元素的宽度为value像素，那么其对应的vw值则可以通过vw = value / 7.5来计算得到。\n\n\n需要注意的是，虽然vw无痛解决了我们之前遇到的很多问题，但是它并不是万能的，通过查找资料、博客和测试实践，以下场景我们可以放心使用vw来适配我们的页面：\n\n\n• 容器适配，可以使用vw\n• 文本适配，可以使用vw\n• 大于1px的边框、圆角、阴影都可以使用vw\n• 内边距和外边距都可以使用vw\n\n\n[移动端适配方案参考资料](https://segmentfault.com/a/1190000038159934)","source":"_posts/移动端适配.md","raw":"---\ntitle: 移动端适配\ndate: 2021-04-29 10:51:50\ntags: [前端]\ncategories: 技术\n---\n\n\n\n## Viewport 方案的核心思想：\n\n\n使用vw作为元素的布局单位\nvw作为布局单位，从底层根本上解决了不同尺寸屏幕的适配问题，因为每个屏幕的百分比是固定的、可预测、可控制的。\n\n\n从我们的实际开发工作出发，我们现在都是统一使用的iPhone6的视觉设计稿（即宽度为750px），那么100vw=750px，即1vw = 7.5px。那么如果设计稿上某一元素的宽度为value像素，那么其对应的vw值则可以通过vw = value / 7.5来计算得到。\n\n\n需要注意的是，虽然vw无痛解决了我们之前遇到的很多问题，但是它并不是万能的，通过查找资料、博客和测试实践，以下场景我们可以放心使用vw来适配我们的页面：\n\n\n• 容器适配，可以使用vw\n• 文本适配，可以使用vw\n• 大于1px的边框、圆角、阴影都可以使用vw\n• 内边距和外边距都可以使用vw\n\n\n[移动端适配方案参考资料](https://segmentfault.com/a/1190000038159934)","slug":"移动端适配","published":1,"updated":"2021-04-29T02:58:07.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko2as4m300003owhtkhym6sm","content":"<h2 id=\"Viewport-方案的核心思想：\"><a href=\"#Viewport-方案的核心思想：\" class=\"headerlink\" title=\"Viewport 方案的核心思想：\"></a>Viewport 方案的核心思想：</h2><p>使用vw作为元素的布局单位<br>vw作为布局单位，从底层根本上解决了不同尺寸屏幕的适配问题，因为每个屏幕的百分比是固定的、可预测、可控制的。</p>\n<p>从我们的实际开发工作出发，我们现在都是统一使用的iPhone6的视觉设计稿（即宽度为750px），那么100vw=750px，即1vw = 7.5px。那么如果设计稿上某一元素的宽度为value像素，那么其对应的vw值则可以通过vw = value / 7.5来计算得到。</p>\n<p>需要注意的是，虽然vw无痛解决了我们之前遇到的很多问题，但是它并不是万能的，通过查找资料、博客和测试实践，以下场景我们可以放心使用vw来适配我们的页面：</p>\n<p>• 容器适配，可以使用vw<br>• 文本适配，可以使用vw<br>• 大于1px的边框、圆角、阴影都可以使用vw<br>• 内边距和外边距都可以使用vw</p>\n<p><a href=\"https://segmentfault.com/a/1190000038159934\" target=\"_blank\" rel=\"noopener\">移动端适配方案参考资料</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Viewport-方案的核心思想：\"><a href=\"#Viewport-方案的核心思想：\" class=\"headerlink\" title=\"Viewport 方案的核心思想：\"></a>Viewport 方案的核心思想：</h2><p>使用vw作为元素的布局单位<br>vw作为布局单位，从底层根本上解决了不同尺寸屏幕的适配问题，因为每个屏幕的百分比是固定的、可预测、可控制的。</p>\n<p>从我们的实际开发工作出发，我们现在都是统一使用的iPhone6的视觉设计稿（即宽度为750px），那么100vw=750px，即1vw = 7.5px。那么如果设计稿上某一元素的宽度为value像素，那么其对应的vw值则可以通过vw = value / 7.5来计算得到。</p>\n<p>需要注意的是，虽然vw无痛解决了我们之前遇到的很多问题，但是它并不是万能的，通过查找资料、博客和测试实践，以下场景我们可以放心使用vw来适配我们的页面：</p>\n<p>• 容器适配，可以使用vw<br>• 文本适配，可以使用vw<br>• 大于1px的边框、圆角、阴影都可以使用vw<br>• 内边距和外边距都可以使用vw</p>\n<p><a href=\"https://segmentfault.com/a/1190000038159934\" target=\"_blank\" rel=\"noopener\">移动端适配方案参考资料</a></p>\n"},{"title":"Mac git 代码提交太慢问题解决","date":"2021-06-07T14:26:56.000Z","_content":"\n```\n\n// 终端获取权限\n$ Sudo -s\n\n// 记录下ip\n$ ping github.com\n\n// 记录下ip\n$ ping github.global.ssl.fastly.net\n\n// 终端编辑host文件\n$ vim /etc/hosts\n\n\n// 输入 i 进入输入模式\n// 加入这两行代码（ip替换成刚才记录的ip）\n192.30.253.112 github.com\n151.101.113.194 github.global.ssl.fastly.net\n\n// 编辑完成esc退出输入模式，然后:wq 保存退出\n\n //更新DNS缓存\n$ sudo dscacheutil -flushcache\n\n```","source":"_posts/Mac git 代码提交太慢问题解决.md","raw":"---\ntitle: Mac git 代码提交太慢问题解决\ndate: 2021-06-07 22:26:56\ntags: [git]\ncategories: 技术\n---\n\n```\n\n// 终端获取权限\n$ Sudo -s\n\n// 记录下ip\n$ ping github.com\n\n// 记录下ip\n$ ping github.global.ssl.fastly.net\n\n// 终端编辑host文件\n$ vim /etc/hosts\n\n\n// 输入 i 进入输入模式\n// 加入这两行代码（ip替换成刚才记录的ip）\n192.30.253.112 github.com\n151.101.113.194 github.global.ssl.fastly.net\n\n// 编辑完成esc退出输入模式，然后:wq 保存退出\n\n //更新DNS缓存\n$ sudo dscacheutil -flushcache\n\n```","slug":"Mac git 代码提交太慢问题解决","published":1,"updated":"2021-06-07T14:34:30.405Z","_id":"ckpmps6lg0000bwwhi1ly571l","comments":1,"layout":"post","photos":[],"link":"","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 终端获取权限</span><br><span class=\"line\">$ Sudo -s</span><br><span class=\"line\"></span><br><span class=\"line\">// 记录下ip</span><br><span class=\"line\">$ ping github.com</span><br><span class=\"line\"></span><br><span class=\"line\">// 记录下ip</span><br><span class=\"line\">$ ping github.global.ssl.fastly.net</span><br><span class=\"line\"></span><br><span class=\"line\">// 终端编辑host文件</span><br><span class=\"line\">$ vim /etc/hosts</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 输入 i 进入输入模式</span><br><span class=\"line\">// 加入这两行代码（ip替换成刚才记录的ip）</span><br><span class=\"line\">192.30.253.112 github.com</span><br><span class=\"line\">151.101.113.194 github.global.ssl.fastly.net</span><br><span class=\"line\"></span><br><span class=\"line\">// 编辑完成esc退出输入模式，然后:wq 保存退出</span><br><span class=\"line\"></span><br><span class=\"line\"> //更新DNS缓存</span><br><span class=\"line\">$ sudo dscacheutil -flushcache</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 终端获取权限</span><br><span class=\"line\">$ Sudo -s</span><br><span class=\"line\"></span><br><span class=\"line\">// 记录下ip</span><br><span class=\"line\">$ ping github.com</span><br><span class=\"line\"></span><br><span class=\"line\">// 记录下ip</span><br><span class=\"line\">$ ping github.global.ssl.fastly.net</span><br><span class=\"line\"></span><br><span class=\"line\">// 终端编辑host文件</span><br><span class=\"line\">$ vim /etc/hosts</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 输入 i 进入输入模式</span><br><span class=\"line\">// 加入这两行代码（ip替换成刚才记录的ip）</span><br><span class=\"line\">192.30.253.112 github.com</span><br><span class=\"line\">151.101.113.194 github.global.ssl.fastly.net</span><br><span class=\"line\"></span><br><span class=\"line\">// 编辑完成esc退出输入模式，然后:wq 保存退出</span><br><span class=\"line\"></span><br><span class=\"line\"> //更新DNS缓存</span><br><span class=\"line\">$ sudo dscacheutil -flushcache</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cklgpoica0007jxwhvgrjb97k","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"cklgpoicm000ejxwhea33kyhc"},{"post_id":"cklgpoiby0000jxwhljy5ie06","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"cklgpoico000ijxwhwb5igweo"},{"post_id":"cklgpoic40002jxwhb4rn38gm","category_id":"cklgpoicd0009jxwhnjwt7hs6","_id":"cklgpoicq000mjxwhiwgg5hwh"},{"post_id":"cklgpoicl000djxwhq0x5db66","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"cklgpoicr000ojxwhtu9n8299"},{"post_id":"cklgpoic90006jxwhjesvmxr3","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"cklgpoics000qjxwhtywcrx6f"},{"post_id":"cklgpoicc0008jxwh1xyvtnxq","category_id":"cklgpoicq000ljxwhbi6vu8ua","_id":"cklgpoict000ujxwht0l0ywwd"},{"post_id":"cklgpoico000hjxwhzqyuvhds","category_id":"cklgpoicq000ljxwhbi6vu8ua","_id":"cklgpoicv0011jxwhb9hrbigy"},{"post_id":"cklgpoicp000kjxwh37f8kw15","category_id":"cklgpoicq000ljxwhbi6vu8ua","_id":"cklgpoicw0015jxwhews00wmd"},{"post_id":"cklgpoidj001hjxwhb744vflm","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"cklgpoidk001jjxwhopf9guyq"},{"post_id":"ckm4m9zff0000zdwhwejzddrm","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckm4m9zfz0002zdwhtds7ce3i"},{"post_id":"ckm4mergf0000fxwhog8egn3f","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckm4mergl0003fxwhf3gjcagr"},{"post_id":"ckm62ya14000004whgauvw3sy","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckm62ya1d000204whkp3s6c3m"},{"post_id":"ckmg3v1ge0000zhwhg3fprj71","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckmg3v1gn0002zhwhj6ldbjah"},{"post_id":"ckmg8d0cn00001swh6x4xk9h5","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckmg8d0cw00021swhtbnzzh2m"},{"post_id":"ckmkft63j0000c7wh3e6w2blw","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckmkft63r0003c7wh4a6eyq3k"},{"post_id":"ckmksczbg0000anwhfd3nt8lu","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckmksczbm0002anwhcsew99rn"},{"post_id":"ckmmt5zte0000zdwhwmpq1fbz","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckmmt5ztk0002zdwhla22nm3n"},{"post_id":"ckmt2gcie000066whwjlbqog0","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckmt2gcik000266whyqqacb39"},{"post_id":"ckn3b4oa80000muwh7ozk1lzv","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckn3b4oaf0002muwhsk9rb18q"},{"post_id":"cknetjuwf0000hkwh7c4o0jgf","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"cknetjuwv0002hkwhsozc9c8z"},{"post_id":"cknfl9s5i0000k3whsobicx7c","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"cknfl9s5y0002k3whpcjj07nn"},{"post_id":"ckng98pvq0000f0whpu6aodjv","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckng98pw10003f0whn8aqq8fs"},{"post_id":"ckng9exc200001cwh8xqwb3ic","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckng9excc00031cwhw3qnv7lp"},{"post_id":"ckng9kneo0000mjwh3fvu3h52","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckng9knf00003mjwh4gjeqzcv"},{"post_id":"ckngx630f0000mnwhkyuaff8d","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckngx630t0002mnwhh9w7s9zz"},{"post_id":"cknhnsj970000ozwh6i6xfcu9","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"cknhnsj9l0002ozwh1mai1t12"},{"post_id":"cko2as4m300003owhtkhym6sm","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"cko2as4mt00023owhtdsznupw"},{"post_id":"ckpmps6lg0000bwwhi1ly571l","category_id":"cklgpoic70004jxwh8k1ktj79","_id":"ckpmps6mq0002bwwhpegyoggz"}],"PostTag":[{"post_id":"cklgpoiby0000jxwhljy5ie06","tag_id":"cklgpoic80005jxwhwlpghfod","_id":"cklgpoice000bjxwhrvxc1w8k"},{"post_id":"cklgpoic40002jxwhb4rn38gm","tag_id":"cklgpoicd000ajxwhp4s1w7me","_id":"cklgpoico000jjxwhku2xu7zq"},{"post_id":"cklgpoic90006jxwhjesvmxr3","tag_id":"cklgpoicm000gjxwhvgcd33lx","_id":"cklgpoicr000pjxwhk7dp6th5"},{"post_id":"cklgpoica0007jxwhvgrjb97k","tag_id":"cklgpoicr000njxwh5042p4aw","_id":"cklgpoics000tjxwhn3vyk13w"},{"post_id":"cklgpoicc0008jxwh1xyvtnxq","tag_id":"cklgpoics000sjxwhiup4wmr0","_id":"cklgpoicv0010jxwh0xoo1lqq"},{"post_id":"cklgpoicc0008jxwh1xyvtnxq","tag_id":"cklgpoict000wjxwhc56qmc1n","_id":"cklgpoicv0012jxwh59ctb6dj"},{"post_id":"cklgpoicl000djxwhq0x5db66","tag_id":"cklgpoicm000gjxwhvgcd33lx","_id":"cklgpoicx0018jxwh3y1grrip"},{"post_id":"cklgpoicl000djxwhq0x5db66","tag_id":"cklgpoicw0016jxwhg64ru6ng","_id":"cklgpoicx0019jxwhw2gjk6rx"},{"post_id":"cklgpoico000hjxwhzqyuvhds","tag_id":"cklgpoics000sjxwhiup4wmr0","_id":"cklgpoicy001cjxwhsscv9cv5"},{"post_id":"cklgpoico000hjxwhzqyuvhds","tag_id":"cklgpoict000wjxwhc56qmc1n","_id":"cklgpoicy001djxwhmxzfx0ri"},{"post_id":"cklgpoicp000kjxwh37f8kw15","tag_id":"cklgpoics000sjxwhiup4wmr0","_id":"cklgpoicy001fjxwhqzu0f2wz"},{"post_id":"cklgpoicp000kjxwh37f8kw15","tag_id":"cklgpoict000wjxwhc56qmc1n","_id":"cklgpoicy001gjxwh3nedw27u"},{"post_id":"cklgpoidj001hjxwhb744vflm","tag_id":"cklgpoict000wjxwhc56qmc1n","_id":"cklgpoidk001ijxwhgohg3tfk"},{"post_id":"ckm4m9zff0000zdwhwejzddrm","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckm4m9zg00003zdwhyfxe3fhp"},{"post_id":"ckm4m9zff0000zdwhwejzddrm","tag_id":"cklgpoicr000njxwh5042p4aw","_id":"ckm4m9zg00004zdwhqr7duxyi"},{"post_id":"ckm4mergf0000fxwhog8egn3f","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckm4mergl0001fxwhjj2tf3ft"},{"post_id":"ckm4mergf0000fxwhog8egn3f","tag_id":"cklgpoicr000njxwh5042p4aw","_id":"ckm4mergl0002fxwhu71fbid9"},{"post_id":"ckm62ya14000004whgauvw3sy","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckm62ya1e000304whay89n2y3"},{"post_id":"ckm62ya14000004whgauvw3sy","tag_id":"cklgpoicr000njxwh5042p4aw","_id":"ckm62ya1e000404whghh9jp7r"},{"post_id":"ckm62ya14000004whgauvw3sy","tag_id":"ckm62ya1a000104whscclm6it","_id":"ckm62ya1e000504whuhsc3lu9"},{"post_id":"ckmg3v1ge0000zhwhg3fprj71","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckmg3v1go0003zhwh07o8qc2s"},{"post_id":"ckmg3v1ge0000zhwhg3fprj71","tag_id":"ckmg3v1gk0001zhwhpg4vl6rb","_id":"ckmg3v1go0004zhwh0isr404x"},{"post_id":"ckmg8d0cn00001swh6x4xk9h5","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckmg8d0cx00031swhmh46seo7"},{"post_id":"ckmg8d0cn00001swh6x4xk9h5","tag_id":"ckmg8d0ct00011swhm6xd4qsf","_id":"ckmg8d0cx00041swhwhn545fk"},{"post_id":"ckmkft63j0000c7wh3e6w2blw","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckmkft63q0001c7wh2rd11ytq"},{"post_id":"ckmkft63j0000c7wh3e6w2blw","tag_id":"ckmg3v1gk0001zhwhpg4vl6rb","_id":"ckmkft63r0002c7whmn1r59lk"},{"post_id":"ckmksczbg0000anwhfd3nt8lu","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckmksczbl0001anwh3z2qu8ue"},{"post_id":"ckmmt5zte0000zdwhwmpq1fbz","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckmmt5ztk0001zdwhy1yc8fqd"},{"post_id":"ckmt2gcie000066whwjlbqog0","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckmt2gcik000166whhhm9k47z"},{"post_id":"ckn3b4oa80000muwh7ozk1lzv","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckn3b4oae0001muwhkbvx7u4t"},{"post_id":"cknetjuwf0000hkwh7c4o0jgf","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"cknetjuwu0001hkwhiw52f1o9"},{"post_id":"cknfl9s5i0000k3whsobicx7c","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"cknfl9s5x0001k3whqf4gdaf1"},{"post_id":"ckng98pvq0000f0whpu6aodjv","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckng98pw00001f0wh8cz7g94p"},{"post_id":"ckng98pvq0000f0whpu6aodjv","tag_id":"cklgpoicr000njxwh5042p4aw","_id":"ckng98pw00002f0wh9e47dvyk"},{"post_id":"ckng9exc200001cwh8xqwb3ic","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckng9excc00011cwhrdeqf9qn"},{"post_id":"ckng9exc200001cwh8xqwb3ic","tag_id":"cklgpoicr000njxwh5042p4aw","_id":"ckng9excc00021cwhq1eeayrf"},{"post_id":"ckng9kneo0000mjwh3fvu3h52","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckng9knf00001mjwhbpz945o6"},{"post_id":"ckng9kneo0000mjwh3fvu3h52","tag_id":"cklgpoicr000njxwh5042p4aw","_id":"ckng9knf00002mjwhhtfjb73s"},{"post_id":"ckngx630f0000mnwhkyuaff8d","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"ckngx630s0001mnwhncoo886i"},{"post_id":"cknhnsj970000ozwh6i6xfcu9","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"cknhnsj9i0001ozwhteun0aew"},{"post_id":"cko2as4m300003owhtkhym6sm","tag_id":"ckm4m9zfw0001zdwhza2zeub0","_id":"cko2as4mr00013owhzkmdclvc"},{"post_id":"ckpmps6lg0000bwwhi1ly571l","tag_id":"ckpmps6ly0001bwwht8rffvno","_id":"ckpmps6mr0003bwwh0rwwjk86"}],"Tag":[{"name":"HTML","_id":"cklgpoic80005jxwhwlpghfod"},{"name":"服务器","_id":"cklgpoicd000ajxwhp4s1w7me"},{"name":"javaScript","_id":"cklgpoicm000gjxwhvgcd33lx"},{"name":"react","_id":"cklgpoicr000njxwh5042p4aw"},{"name":"心得","_id":"cklgpoics000sjxwhiup4wmr0"},{"name":"文章","_id":"cklgpoict000wjxwhc56qmc1n"},{"name":"标签","_id":"cklgpoicu000zjxwh3mhjks0t"},{"name":"技巧","_id":"cklgpoicw0016jxwhg64ru6ng"},{"name":"测试","_id":"cklgpqgoh0002r9whq0seuu90"},{"name":"前端","_id":"ckm4m9zfw0001zdwhza2zeub0"},{"name":"性能优化","_id":"ckm62ya1a000104whscclm6it"},{"name":"es6","_id":"ckmg3v1gk0001zhwhpg4vl6rb"},{"name":"正则","_id":"ckmg8d0ct00011swhm6xd4qsf"},{"name":"git","_id":"ckpmps6ly0001bwwht8rffvno"}]}}