{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/avatar.jpg","path":"avatar/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/archer/.gitignore","hash":"7e11730466038f7d81c67afdb7fb3c19bc4c0cc0","modified":1571822278666},{"_id":"themes/archer/.prettierrc.js","hash":"c77c76428fb4eefd727444d97fa2733a0c10286a","modified":1571627347543},{"_id":"themes/archer/.prettierignore","hash":"075b20da2bb3dfa7932394363d63d98cbb0b7042","modified":1571627347543},{"_id":"themes/archer/.eslintrc.json","hash":"5c79a54f29b1d32045e612fcb7379797d79ac380","modified":1571627347524},{"_id":"themes/archer/LICENSE","hash":"35f4fb806270f8243459c870a2141e795dfab166","modified":1571627347544},{"_id":"themes/archer/gulpfile.js","hash":"ba7c6a88298900460ddd1649300b5672956902f9","modified":1571627347551},{"_id":"themes/archer/README.md","hash":"e7ddbbdc5d5ec445a3bc99c684df83ae7783624c","modified":1571627347544},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1571627347525},{"_id":"themes/archer/webpack.prod.js","hash":"b6d35f7e9a9718b3e5e3e17c52fcc5e7c38330b0","modified":1571627347634},{"_id":"themes/archer/webpack.config.js","hash":"348da2932316c2789a3c0a3cf5efff0dd7cc4ffe","modified":1571627347634},{"_id":"source/_posts/使用hexo搭建博客时遇到的问题.md","hash":"cf2bfc3b325f1f2e86fb03a33a0077c546f93b5f","modified":1571819332030},{"_id":"source/_posts/BFC理解原理.md","hash":"ae3f76d0acb8924a11757486d40a71c6b9fd87be","modified":1594622992586},{"_id":"source/_posts/问题整理.md","hash":"956e09ce182e3ee3b824e92115ef5797c4a5743f","modified":1597809300652},{"_id":"themes/archer/_config.yml","hash":"16fe0f9d1df246ec6a7bd8beaba0939e5a93e223","modified":1594622971945},{"_id":"source/_posts/react-Context-上下文方法使用.md","hash":"11c59f7331e01ce0a303696741b3fffa9a16971a","modified":1571826636031},{"_id":"themes/archer/dev/archer.sh","hash":"9474c501c1c55f47f02cccdd9e2039498ebc5e43","modified":1571627347546},{"_id":"source/_posts/让h5页面强制横屏.md","hash":"2782d6b6bac1f5537025c46b89774c505ff9e7f6","modified":1571816353440},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c10293eb8ccad5d02412a1369ec1c7e77516b929","modified":1571627347548},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"522434202e5e810b3c7f9591eb3a4451a4e485f0","modified":1571627347548},{"_id":"themes/archer/package.json","hash":"c07c94772d0e92e77788b0fe5beb3d44eb3c245f","modified":1571627347581},{"_id":"themes/archer/languages/default.yml","hash":"c6e36691ded2a5e5939c67bf3c47104664ea56c6","modified":1571627347552},{"_id":"themes/archer/languages/en.yml","hash":"de8fe8ad1967854586fee2214094c4992dd05278","modified":1571627347553},{"_id":"themes/archer/layout/404.ejs","hash":"a054b4ea1147846bed4252dd56182cb8e32d95eb","modified":1571627347554},{"_id":"themes/archer/layout/about.ejs","hash":"990df15653a99453617e72dfc195fa0a75b9a5d1","modified":1571627347575},{"_id":"source/_posts/forEach兼容写法.md","hash":"1c4553e5c888b5910e49b76e6b4886d3ea8b2be9","modified":1571640059114},{"_id":"themes/archer/layout/post.ejs","hash":"f14b49c920a3afe8d9aa4cb1d843faf43d07c72e","modified":1571627347577},{"_id":"themes/archer/layout/site-meta.ejs","hash":"a9d85607fc7da51bb9becff7fe2f07a8b4fbc915","modified":1571627347578},{"_id":"source/tags/index.md","hash":"13d75ba9b54990e92b96961571a6ef5b734885ec","modified":1553855424064},{"_id":"source/categories/index.md","hash":"c838304e0c43d4ed20d012943da53282d4e47eac","modified":1553855428103},{"_id":"themes/archer/layout/layout.ejs","hash":"fffd1188977f74d19e2f9d267d085dddc9c6778e","modified":1571627347577},{"_id":"themes/archer/layout/index.ejs","hash":"c9ae77cd8f7b862d23137a7b4eb5eb01b558ed33","modified":1571627347576},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"21765ec5abc9a65513e6bff57cb021d3b3852d35","modified":1571627347556},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"179a712ae139d8c5123338d9bd39d2b09c5ed2ce","modified":1571627347557},{"_id":"themes/archer/docs/README-en.md","hash":"e4fff6fc13f3296c2b168ab220f847192bf1273b","modified":1571627347547},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"065f8d6c4aae6782e6819815911f7feb6402a4ec","modified":1571627347560},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"af76b1a18a63934e83b078bf5f9f886e972a0ceb","modified":1571627347559},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"5dadba1c15454e25740982b59ef382686f3c6e51","modified":1571627347560},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"e1b4893af2b18f502bad1b552c3f3381ecc3021f","modified":1571627347561},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"92ac580acc20bde7b3345bfe132671b9043bfbd6","modified":1571627347561},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"fc03729825ac7ffd4045f910bbd936bc5841c65e","modified":1571627347569},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1571627347583},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1571627347583},{"_id":"themes/archer/source/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1571627347585},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"a90bd2b089b335b141a6a0d8dee9a9cde60fdc5b","modified":1571627347556},{"_id":"themes/archer/source/css/mobile.css","hash":"770d2ffb986a814c5e5662d28d2ec38864d8b1a0","modified":1571627347588},{"_id":"themes/archer/source/css/style.css","hash":"49f5d23b1e24e73016efdd8a6b70964a45a601db","modified":1571627347589},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"b343f5a4c8bba1c71f3229390ed83a8679c2f375","modified":1571627347559},{"_id":"themes/archer/source/assets/favicon.ico","hash":"d6d9068d1928f9f69ddb2772816fccc01c74cde5","modified":1571629259727},{"_id":"themes/archer/source/avatar/avatar.jpg","hash":"061fcb1e751dd9f2d73e9abe1a841b107f84e792","modified":1571628019948},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1571627347592},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1571627347593},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1571627347608},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"6f18a92bbe8bed93113449ed6ff8d148c1e7565a","modified":1571627347606},{"_id":"themes/archer/src/js/fancybox.js","hash":"701720a4c56fb09d78ef3494fd3a88b4e2cde238","modified":1571627347611},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1571627347609},{"_id":"themes/archer/src/js/initSidebar.js","hash":"e27d52b4ccb9502836570a0673f6b656f9ce3661","modified":1571627347612},{"_id":"themes/archer/src/js/browser.js","hash":"35ea55f62c0f251817c46da0153f70aec323be3d","modified":1571627347610},{"_id":"themes/archer/src/js/main.js","hash":"673e19867b5ecf65b0c9c6579d40be587d0e8211","modified":1571627347612},{"_id":"themes/archer/source/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1571627347608},{"_id":"themes/archer/src/js/scroll.js","hash":"83f0885f2673234c911d84a56fcaaa020cdcc3e6","modified":1571627347614},{"_id":"themes/archer/src/js/init.js","hash":"0cf1eb883b87590a771b687431cc5180064d13cd","modified":1571627347611},{"_id":"themes/archer/src/js/sidebar.js","hash":"f2a5ec38766b3f48e3b043b84029f9da878d1c1a","modified":1571627347615},{"_id":"themes/archer/src/js/search.js","hash":"ef6533c876831377542a57f447550689144a6b71","modified":1571627347614},{"_id":"themes/archer/src/js/share.js","hash":"83a8ad056039cc673b939f47d69ad56337abc382","modified":1571627347615},{"_id":"themes/archer/src/js/tag.js","hash":"a868118bb0daf8902b63c48792797def36b9469a","modified":1571627347616},{"_id":"themes/archer/src/scss/_common.scss","hash":"05162d1562d4b141d9bad44c37b0b736371d8b08","modified":1571627347619},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"c6347bf137e80bb0c5b6368488ebd634c299016a","modified":1571627347619},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"fb6a1349bab25b65cf89b47e136d958d10947533","modified":1571627347620},{"_id":"themes/archer/src/scss/_variables.scss","hash":"2264c9b671643b3c64e002f968a75355e4091b61","modified":1571627347632},{"_id":"themes/archer/src/scss/mobile.scss","hash":"0a00e55e8b8d9551eed5966f53d8a6580b816dc5","modified":1571627347632},{"_id":"themes/archer/src/scss/style.scss","hash":"03bca94e57bc44723f8b73bb653f3e002b4b08a8","modified":1571627347633},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1571627347563},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1571627347591},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1571627347595},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1571627347597},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0c3192b500a4fd550e483cf77a49806a5872185b","modified":1571627347606},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1571627347594},{"_id":"themes/archer/src/js/mobile.js","hash":"cfc37862242d5b7bd17028269436d3bc42e142e8","modified":1571627347613},{"_id":"themes/archer/src/js/toc.js","hash":"5c4db488dc2d80315064c6832eecfb39017a8104","modified":1571627347617},{"_id":"themes/archer/src/js/util.js","hash":"7bec5b1ff8ee91f58d084c47e0ed3908b27adef7","modified":1571627347617},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"244a4c71b862e6385a6de1e83a4975418a8c6fe7","modified":1571627347562},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"f1f785de72e1f7056da8fdb12c85523d20a0b6b0","modified":1571627347565},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"483c07212879b116b772f428547c9962be96d2ce","modified":1571627347567},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cfdb15116abe89f4b54f7bb18a0b23a597c47a60","modified":1571627347563},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"c043a98e33252b9a628bfd31c4a3b2883dce2b99","modified":1571627347564},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"a6acb5d7778ade98ba5b6932e38a585460513f49","modified":1571627347564},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"9cd4798cdcd712cc01c9e797adbb4810649310d4","modified":1571627347568},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"4feb7c3d17a3c8994eb095d43d75fbd0f1ed5b4f","modified":1571627347574},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"4281841e5bbb5e1a83c3ebf6506dab057e1fe6b9","modified":1571627347570},{"_id":"themes/archer/package-lock.json","hash":"f3eae5d3878f7761231613b74be88173d3047c0c","modified":1571627347581},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"55c33bd49880ccaaa2f5d4dff44470886c3f3633","modified":1571627347621},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"08594f05f6ed238a7b79d48ebc1ff1e5c9deec46","modified":1571627347622},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"82a04b6ebb684a87f486cac8f08619ecb52605fd","modified":1571627347622},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"4d4713ec4b766a60577546af9f98eb721c4a63cd","modified":1571627347627},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1571627347551},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"c5ce643a06a2103aa4ac0d8279c024f90886d37f","modified":1571627347572},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1571627347600},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1571627347604},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"e96750b1aa7113322696857882b1e1fde11c1fc4","modified":1571627347575},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"e710acbc85e1cc5ae0e7ab5b5899837b9f222b97","modified":1571627347572},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"46d315718d86e9701573df2e39299895d8ca193c","modified":1571627347624},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"a1163d481627864e9dda441c4c356169cd33a3a1","modified":1571627347624},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"b3cf7523d8e91fce92cd6a118e308632047cc7b3","modified":1571627347625},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"1e4510959f51b5d4d3c5781468c77d25546ce905","modified":1571627347626},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"b6db1d4a29c34e1b834c54ca076b8084ceac4885","modified":1571627347626},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"c623385d72ce12fa403f5384ded79c3897d0fc9f","modified":1571627347627},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"30a3b9165c97bac6f6c795e598408639f5d9670a","modified":1571627347628},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"0691ca23bf6eabef65ff054c7710ec7432e4022c","modified":1571627347630},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"28b97b11f17d57a258747bb0facae0ad1911f9d5","modified":1571627347629},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b41904da65b1128510d28a57142298bfd844f7f5","modified":1571627347631},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1571627347602}],"Category":[{"name":"技术","_id":"ckctvtziv00041wek7qorz1br"},{"name":"记录","_id":"ckctvtzja00091weks4qeceql"}],"Data":[],"Page":[{"title":"标签","date":"2019-03-29T09:18:23.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-03-29 17:18:23\ntype: \"tags\" #新添加的内容\n\n---\n","updated":"2019-03-29T10:30:24.064Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckctvtzin00011wekkqdzzmvv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2019-03-29T09:17:36.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-03-29 17:17:36\ntype: \"categories\"   #这部分是新添加的\n---\n","updated":"2019-03-29T10:30:28.103Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckctvtzit00031wek7uxcugxf","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"BFC理解原理","date":"2020-07-13T06:26:43.000Z","copyright":false,"_content":"\n## 一、常见定位方案\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n- 普通流 (normal flow)\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n- 浮动 (float)\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n- 绝对定位 (absolute positioning)\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n## 二、BFC 概念\n Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n\n那么 BFC 是什么呢？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n## 三、触发 BFC\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素\n- 浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n","source":"_posts/BFC理解原理.md","raw":"---\ntitle: BFC理解原理\ndate: 2020-07-13 14:26:43\ntags: HTML\ncategories: 技术\ncopyright: false\n---\n\n## 一、常见定位方案\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n- 普通流 (normal flow)\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n- 浮动 (float)\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n- 绝对定位 (absolute positioning)\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n## 二、BFC 概念\n Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n\n那么 BFC 是什么呢？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n## 三、触发 BFC\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素\n- 浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n","slug":"BFC理解原理","published":1,"updated":"2020-07-13T06:49:52.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzig00001wekstb5te7h","content":"<h2 id=\"一、常见定位方案\"><a href=\"#一、常见定位方案\" class=\"headerlink\" title=\"一、常见定位方案\"></a>一、常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<ul>\n<li>普通流 (normal flow)<blockquote>\n<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n</blockquote>\n</li>\n<li>浮动 (float)<blockquote>\n<p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n</blockquote>\n</li>\n<li>绝对定位 (absolute positioning)<blockquote>\n<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"二、BFC-概念\"><a href=\"#二、BFC-概念\" class=\"headerlink\" title=\"二、BFC 概念\"></a>二、BFC 概念</h2><p> Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p>那么 BFC 是什么呢？</p>\n<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p>\n<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>\n<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h2 id=\"三、触发-BFC\"><a href=\"#三、触发-BFC\" class=\"headerlink\" title=\"三、触发 BFC\"></a>三、触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素</li>\n<li>浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、常见定位方案\"><a href=\"#一、常见定位方案\" class=\"headerlink\" title=\"一、常见定位方案\"></a>一、常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<ul>\n<li>普通流 (normal flow)<blockquote>\n<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n</blockquote>\n</li>\n<li>浮动 (float)<blockquote>\n<p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n</blockquote>\n</li>\n<li>绝对定位 (absolute positioning)<blockquote>\n<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"二、BFC-概念\"><a href=\"#二、BFC-概念\" class=\"headerlink\" title=\"二、BFC 概念\"></a>二、BFC 概念</h2><p> Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p>那么 BFC 是什么呢？</p>\n<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p>\n<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>\n<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h2 id=\"三、触发-BFC\"><a href=\"#三、触发-BFC\" class=\"headerlink\" title=\"三、触发 BFC\"></a>三、触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素</li>\n<li>浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n"},{"title":"使用hexo搭建博客时遇到的问题","date":"2018-07-13T09:45:51.000Z","_content":"\n\n花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。\n\n\n\n\n\n\n\n\n\n","source":"_posts/使用hexo搭建博客时遇到的问题.md","raw":"---\ntitle: 使用hexo搭建博客时遇到的问题\ndate: 2018-07-13 17:45:51\ntags: [心得,文章]\ncategories: 记录\n---\n\n\n花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。\n\n\n\n\n\n\n\n\n\n","slug":"使用hexo搭建博客时遇到的问题","published":1,"updated":"2019-10-23T08:28:52.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzip00021wekqviyz8gt","content":"<p>花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。</p>\n"},{"title":"问题整理","date":"2020-07-13T08:00:14.000Z","copyright":false,"_content":"\n### 介绍一下js的数据类型有哪些,值是如何存储的\n```\n一共有8种数据类型，7种基本数据类型\nString \nNumber \nBoolean \nNull \nUndefined \nSymbol（es6 新增类型，表示第一无二的值） \nBigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）\nObject（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）\n\n原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n\n引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n\n```\n### && 、 ||和!! 运算符分别能做什么\n```\n&& 并且符，使用时两边的值结果都必须为true才返回true\n|| 或者符，两边的值结果有一个为true最终判断结果就位true\n!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）\n\n```\n\n### JS的数据类型的转换\n```\n在 JS 中类型转换只有三种情况，分别是：\n\n- 转换为布尔值（调用Boolean()方法）\n- 转换为数字（调用Number()、parseInt()和parseFloat()方法）\n- 转换为字符串（调用.toString()或者String()方法）\n\nnull和underfined没有.toString方法\n\n```\n![image](https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()   \n>（1）typeof\n```\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object\n\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof\n```\n>（2）instanceof \n```\n//重点\ninstanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断\ninstanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。\n其意思就是判断对象是否是某一数据类型（如Array）的实例\n\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true    \n// console.log(undefined instanceof Undefined);      //报错\n// console.log(null instanceof Null);                //报错\n复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。\n我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，'str'不是实例，所以判断值为false。\n```\n>（3）constructor\n```\nconsole.log((2).constructor === Number); // true\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() {}).constructor === Function); // true\nconsole.log(({}).constructor === Object); // true\n\n这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了\n\nfunction Fn(){};\n \nFn.prototype=new Array();\n \nvar f=new Fn();\n \nconsole.log(f.constructor===Fn);    // false\nconsole.log(f.constructor===Array); // true\n```\n>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法\n```\nvar a = Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call('str'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n```\n### 介绍 JS 有哪些内置对象？\n```\n全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在\n全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n\n标准内置对象的分类\n\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。\n\n例如 Infinity、NaN、undefined、null 字面量\n\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n\n例如 eval()、parseFloat()、parseInt() 等\n\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。\n\n例如 Object、Function、Boolean、Symbol、Error 等\n\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。\n\n例如 Number、Math、Date\n\n（5）字符串，用来表示和操作字符串的对象。\n\n例如 String、RegExp\n\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。\n\n例如 Map、Set、WeakMap、WeakSet\n\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。\n\n例如 SIMD 等\n\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。\n\n例如 JSON 等\n\n（10）控制抽象对象\n\n例如 Promise、Generator 等\n\n（11）反射\n\n例如 Reflect、Proxy\n\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。\n\n例如 Intl、Intl.Collator 等\n\n（13）WebAssembly\n\n（14）其他\n\n例如 arguments\n```\n\n### undefined 与 undeclared 的区别？\n```\n已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。\n对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ\neof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 \"undefined\"。\n\n```\n\n### null 和 undefined 的区别？\n```\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，\nnull 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null\n主要用于赋值给一些可能会返回对象的变量，作为初始化。\n/*\n    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，\n    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。\n    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\n*/\nundefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它\n会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等\n号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n\n```\n\n### {}和[]的valueOf和toString的结果是什么？\n```\n{} 的 valueOf 结果为 {} ，toString 的结果为 \"[object Object]\"\n\n[] 的 valueOf 结果为 [] ，toString 的结果为 \"\"\n```\n\n### Javascript 的作用域和作用域链？\n```\n【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。\n【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。\n\n\n```\n### javascript 创建对象的几种方式？\n```\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n\n\n```\n\n### JavaScript 继承的几种实现方式？\n```\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。\n\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。\n\n```\n\n### 寄生式组合继承的实现？\n```\nPerson\nStudent\n\nfunction Person(name){\n    this.name = name;\n}\n\nPerson.prototype.sayName = function(){\n    console.log(123);\n}\n\nfunction Student(name, grade){\n    Person.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\nStudent.prototype.sayMyGrade = function() {\n  console.log(\"My grade is \" + this.grade + \".\");\n  \n}\n\n```\n\n### 谈谈你对this、call、apply和bind的理解\n```\n总结:\n1. 在浏览器里，在全局范围内this 指向window对象；\n2. 在函数中，this永远指向最后调用他的那个对象；\n3. 构造函数中，this指向new出来的那个新的对象；\n4. call、apply、bind中的this被强绑定在指定的那个对象上；\n5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；\n6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。\n\n区别:\n- call/apply改变了函数的this上下文后马上执行该函数\n- bind则是返回改变了上下文后的函数,不执行该函数\n```\n\n\n\n### JavaScript 原型，原型链？ 有什么特点？\n```\nprototype就是JS的原型，里面可以定义属性和方法\n当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。\n原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。\n\n```\n\n### js 获取原型的方法？\n```\np.proto\np.constructor.prototype\nObject.getPrototypeOf(p)\n```\n\n### 什么是闭包，为什么要用它？\n```\n闭包是指有权访问另一个函数作用域内变量的函数\n创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。\n\n闭包有两个常用的用途:\n- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\nfunction a(){\n    var n = 0;\n    function add(){\n       n++;\n       console.log(n);\n    }\n    return add;\n}\nvar a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；\na1();    //1\na1();    //2  第二次调用n变量还在内存中\n\n其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。\n\n```\n\n### 什么是 DOM 和 BOM？\n```\nDOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。\n\nBOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM\n的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）\n对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati\non 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对\n象的子对象。\n\n```\n\n### 三种事件模型是什么？\n```\nDOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。\nIE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\nDOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n```\n\n### 事件委托是什么？\n```\n事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到\n目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。\n使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。\n\n```\n\n### 什么是事件传播?\n```\n当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。\n事件传播有三个阶段：\n1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。\n2. 目标阶段–事件已达到目标元素。\n3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。\n\n\n```\n\n### 什么是事件捕获？\n```\n当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----> document----> html----> body ---->目标元素\n\nhtml:\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\njs:\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\n\n\n\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。\n\n\n```\n\n### 什么是事件冒泡？\n```\n事件冒泡刚好与事件捕获相反，当前元素---->body ----> html---->document ---->window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。\n假设有如下的 HTML 结构：\n\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\n对应的JS代码：\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。\n\n\n```\n\n### DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\n（1）创建新节点\n```\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n```\n（2）添加、移除、替换、插入\n```\nappendChild(node)\nremoveChild(node)\nreplaceChild(new,old)\ninsertBefore(new,old)\n```\n（3）查找\n```\ngetElementById();\ngetElementsByName();\ngetElementsByTagName();\ngetElementsByClassName();\nquerySelector();\nquerySelectorAll();\n```\n（4）属性操作\n```\ngetAttribute(key);\nsetAttribute(key, value);\nhasAttribute(key);\nremoveAttribute(key);\n```\n\n###  js数组和对象有哪些原生方法,列举一下\n![image](https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n![image](https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n### 常用的正则表达式\n\n### Ajax 是什么? 如何创建一个 Ajax？\n我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。\n创建步骤：\n![image](https://user-gold-cdn.xitu.io/2020/6/2/17274125a4cf4d61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n```\n//1：创建Ajax对象\nvar xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');    //兼容IE6及以下版本\n//2：配置 Ajax请求地址\nxhr.open('get','index.xml',true);\n//3：发送请求\nxhr.send(null); //严谨写法\n//4:监听请求，接受响应\nxhr.onreadysatechange = function(){\n    if(xhr.readySates == 4 && xhr.status == 200 || xhr.status == 304){\n        console.log(xhr.responsetXML);\n    }\n}\n```\npromise封装实现\n```\n// promise 封装实现：\n\nfunction getJSON(url) {\n  // 创建一个 promise 对象\n  let promise = new Promise(function(resolve, reject) {\n    let xhr = new XMLHttpRequest();\n\n    // 新建一个 http 请求\n    xhr.open(\"GET\", url, true);\n\n    // 设置状态的监听函数\n    xhr.onreadystatechange = function() {\n      if (this.readyState !== 4) return;\n\n      // 当请求成功或失败时，改变 promise 的状态\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n\n    // 设置错误监听函数\n    xhr.onerror = function() {\n      reject(new Error(this.statusText));\n    };\n\n    // 设置响应的数据类型\n    xhr.responseType = \"json\";\n\n    // 设置请求头信息\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n\n    // 发送 http 请求\n    xhr.send(null);\n  });\n\n  return promise;\n}\n\n```\n\n### js 延迟加载的方式有哪些？\n```\njs 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。\n我了解到的几种方式是：\n\n将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。\n给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。\n给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。\n动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。\n\n```\n\n### 谈谈你对模块化开发的理解？\n```\n我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念\n，但随着程序越来越复杂，代码的模块化开发变得越来越重要。\n由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污\n染，并且模块间没有联系。\n后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所\n有的所有的模块成员，外部代码可以修改内部属性的值。\n现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。\n```\n\n###  js 的几种模块规范？\n```\njs 中现在比较成熟的有四种模块加载方案：\n\n第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。\n第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。\n第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。\n第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。\n```\n\n### AMD和CMD 规范的区别？\n它们之间的主要区别有两个方面。\n\n1. 第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。\n2. 第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于\n    模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD\n    在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句\n    的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。\n\n```\n// CMD\ndefine(function(require, exports, module) {\n  var a = require(\"./a\");\n  a.doSomething();\n  // 此处略去 100 行\n  var b = require(\"./b\"); // 依赖可以就近书写\n  b.doSomething();\n  // ...\n});\n\n// AMD 默认推荐\ndefine([\"./a\", \"./b\"], function(a, b) {\n  // 依赖必须一开始就写好\n  a.doSomething();\n  // 此处略去 100 行\n  b.doSomething();\n  // ...\n});\n\n```\n\n### ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\n- 1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。\n- 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n### requireJS的核心原理是什么？ \nrequire.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。\n\n### 谈谈JS的运行机制\n1. js单线程\nJavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。\n>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n\n2. js事件循环\njs代码执行过程中会有很多任务，这些任务总的分成两类：\n- 同步任务\n- 异步任务\n当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：\n![image](https://user-gold-cdn.xitu.io/2020/6/2/172744a7fa2853c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n回答：\n1. 首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。\n2. 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务\n3. 当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。\n4. 任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。\n5. 当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。\n\n### arguments 的对象是什么？\narguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。\n我们可以使用Array.prototype.slice将arguments对象转换成一个数组。\n```\nfunction one() {\n  return Array.prototype.slice.call(arguments);\n}\n```\n注意:箭头函数中没有arguments对象。\n```\nfunction one() {\n  return arguments;\n}\nconst two = function () {\n  return arguments;\n}\nconst three = function three() {\n  return arguments;\n}\n\nconst four = () => arguments;\n\nfour(); // Throws an error  - arguments is not defined\n\n```\n\n### 为什么在调用这个函数时，代码中的b会变成一个全局变量?\n```\nfunction myFunc() {\n  let a = b = 0;\n}\n\nmyFunc();\n```\n原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：\n```\nfunction myFunc() {\n  let a = (b = 0);\n}\n\nmyFunc();\n```\n首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。\n\n我们可以通过在赋值之前先声明变量来解决这个问题。\n```\nfunction myFunc() {\n  let a,b;\n  a = b = 0;\n}\nmyFunc();\n```\n\n### 简单介绍一下V8引擎的垃圾回收机制\n```\nv8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。\n\n新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。\n\n新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：\n\n（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。\n\n（2）如果对象不存活，则释放对象的空间。\n\n（3）最后将 From 空间和 To 空间角色进行交换。\n\n新生代对象晋升到老生代有两个条件：\n\n（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。\n\n（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。\n\n老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。\n\n由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。\n\n```\n\n### 哪些操作会造成内存泄漏？ \n- 1.意外的全局变量\n- 2.被遗忘的计时器或回调函数\n- 3.脱离 DOM 的引用\n- 4.闭包\n\n- 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n- 第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n- 第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\n- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。\n\n### ECMAScript 是什么？\n```\nECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。\nECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件\n只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。\njavaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）\nECMAScript说什么JavaScript就得做什么！\nJavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！\n——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，\n那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。\n```\n### ECMAScript 2015（ES6）有哪些新特性？\n- 块作用域\n- 类\n- 箭头函数\n- 模板字符串\n- 加强的对象字面\n- 对象解构\n- Promise\n- 模块\n- Symbol\n- 代理（proxy）Set\n- 函数默认参数\n- rest 和展开\n\n### var,let和const的区别是什么？\nvar声明的变量会挂载在window上，而let和const声明的变量不会：\n```\nvar a = 100;\nconsole.log(a,window.a);    // 100 100\n\nlet b = 10;\nconsole.log(b,window.b);    // 10 undefined\n\nconst c = 1;\nconsole.log(c,window.c);    // 1 undefined\n```\nvar声明变量存在变量提升，let和const不存在变量提升:\n```\nconsole.log(a); // undefined  ===>  a已声明还没赋值，默认得到undefined值\nvar a = 100;\n\nconsole.log(b); // 报错：b is not defined  ===> 找不到b这个变量\nlet b = 10;\n\nconsole.log(c); // 报错：c is not defined  ===> 找不到c这个变量\nconst c = 10;\n```\nlet和const声明形成块作用域\n```\n\nif(1){\n  var a = 100;\n  let b = 10;\n}\n\nconsole.log(a); // 100\nconsole.log(b)  // 报错：b is not defined  ===> 找不到b这个变量\n\n-------------------------------------------------------------\n\nif(1){\n  var a = 100;\n  const c = 1;\n}\nconsole.log(a); // 100\nconsole.log(c)  // 报错：c is not defined  ===> 找不到c这个变量\n```\n同一作用域下let和const不能声明同名变量，而var可以\n```\nvar a = 100;\nconsole.log(a); // 100\n\nvar a = 10;\nconsole.log(a); // 10\n-------------------------------------\nlet a = 100;\nlet a = 10;\n\n//  控制台报错：Identifier 'a' has already been declared  ===> 标识符a已经被声明了。\n\n```\n暂存死区\n```\nvar a = 100;\n\nif(1){\n    a = 10;\n    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，\n    // 而这时，还未到声明时候，所以控制台Error:a is not defined\n    let a = 1;\n}\n```\nconst\n```\n\n/*\n* &emsp;&emsp;1、一旦声明必须赋值,不能使用null占位。\n*\n* &emsp;&emsp;2、声明后不能再修改\n*\n* &emsp;&emsp;3、如果声明的是复合类型数据，可以修改其属性\n*\n* */\n\nconst a = 100; \n\nconst list = [];\nlist[0] = 10;\nconsole.log(list);&emsp;&emsp;// [10]\n\nconst obj = {a:100};\nobj.name = 'apple';\nobj.a = 10000;\nconsole.log(obj);&emsp;&emsp;// {a:10000,name:'apple'}\n\n```\n\n### 什么是箭头函数？\n箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n```\n//ES5 Version\nvar getCurrentDate = function (){\n  return new Date();\n}\n\n//ES6 Version\nconst getCurrentDate = () => new Date();\n```\n在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。\n```\n//ES5 Version\nfunction greet(name) {\n  return 'Hello ' + name + '!';\n}\n\n//ES6 Version\nconst greet = (name) => `Hello ${name}`;\nconst greet2 = name => `Hello ${name}`;\n\n```\n我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。\n```\nconst getArgs = () => arguments\n\nconst getArgs2 = (...rest) => rest\n```\n箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。\n```\nconst data = {\n  result: 0,\n  nums: [1, 2, 3, 4, 5],\n  computeResult() {\n    // 这里的“this”指的是“data”对象\n    const addAll = () => {\n      return this.nums.reduce((total, cur) => total + cur, 0)\n    };\n    this.result = addAll();\n  }\n};\n\n```\n箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。\n\n\n### 什么是类？\n```\n类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。\n```\n\n### 什么是模板字符串？\n模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。\n```\n//ES5 Version\nvar greet = 'Hi I\\'m Mark';\n\n//ES6 Version\nlet greet = `Hi I'm Mark`;\n\n```\n在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：\n```\n//ES5 Version\nvar lastWords = '\\n'\n  + '   I  \\n'\n  + '   Am  \\n'\n  + 'Iron Man \\n';\n\n\n//ES6 Version\nlet lastWords = `\n    I\n    Am\n  Iron Man   \n`;\n\n```\n在ES5版本中，我们需要添加\\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。\n```\n//ES5 Version\nfunction greet(name) {\n  return 'Hello ' + name + '!';\n}\n\n\n//ES6 Version\nfunction greet(name) {\n  return `Hello ${name} !`;\n}\n\n```\n在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。\n\n### 什么是对象解构？ \n对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：\n```\nconst employee = {\n  firstName: \"Marko\",\n  lastName: \"Polo\",\n  position: \"Software Developer\",\n  yearHired: 2017\n};\n\n```\n从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。\n```\nvar firstName = employee.firstName;\nvar lastName = employee.lastName;\nvar position = employee.position;\nvar yearHired = employee.yearHired;\n\n```\n使用解构方式语法就变得简洁多了：\n```\n{ firstName, lastName, position, yearHired } = employee;\n\n```\n我们还可以为属性取别名：\n```\nlet { firstName: fName, lastName: lName, position, yearHired } = employee;\n\n```\n当然如果属性值为 undefined 时，我们还可以指定默认值，但是属性为null时指定的默认值则不生效：\n```\nlet { firstName = \"Mark\", lastName: lName, position, yearHired } = employee;\n```\n\n### 什么是Set对象，它是如何工作的？\nSet 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。\n\n我们可以使用Set构造函数创建Set实例。\n```\nconst set1 = new Set();\nconst set2 = new Set([\"a\",\"b\",\"c\",\"d\",\"d\",\"e\"]);\n\n```\n我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。\n```\nset2.add(\"f\");\nset2.add(\"g\").add(\"h\").add(\"i\").add(\"j\").add(\"k\").add(\"k\");\n// 后一个“k”不会被添加到set对象中，因为它已经存在了\n```\n我们可以使用has方法检查Set实例中是否存在特定的值。\n```\nset2.has(\"a\") // true\nset2.has(\"z\") // true\n\n```\n我们可以使用size属性获得Set实例的长度。\n```\nset2.size // returns 10\n\n```\n可以使用clear方法删除 Set 中的数据。\n```\nset2.clear();\n\n```\n我们可以使用Set对象来删除数组中重复的元素。\n```\nconst numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];\nconst uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]\n \n```\n另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。\n- Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n- WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。\n\n### 什么是Proxy？\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。\n\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\n### 写一个通用的事件侦听器函数？\n```\nconst EventUtils = {\n  // 视能力分别使用dom0||dom2||IE方式 来绑定事件\n  // 添加事件\n  addEvent: function(element, type, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(type, handler, false);\n    } else if (element.attachEvent) {\n      element.attachEvent(\"on\" + type, handler);\n    } else {\n      element[\"on\" + type] = handler;\n    }\n  },\n\n  // 移除事件\n  removeEvent: function(element, type, handler) {\n    if (element.removeEventListener) {\n      element.removeEventListener(type, handler, false);\n    } else if (element.detachEvent) {\n      element.detachEvent(\"on\" + type, handler);\n    } else {\n      element[\"on\" + type] = null;\n    }\n  },\n\n  // 获取事件目标\n  getTarget: function(event) {\n    return event.target || event.srcElement;\n  },\n\n  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event\n  getEvent: function(event) {\n    return event || window.event;\n  },\n\n  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）\n  stopPropagation: function(event) {\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      event.cancelBubble = true;\n    }\n  },\n\n  // 取消事件的默认行为\n  preventDefault: function(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n  }\n};\n\n```\n\n### 什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\n```\n函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。\n函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。\n函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。\n\n```\n\n### 什么是高阶函数？\n高阶函数只是将函数作为参数或返回值的函数。\n```\nfunction higherOrderFunction(param,callback){\n    return callback(param);\n}\n\n```\n\n### 为什么函数被称为一等公民？\n```\n在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:\n\n赋值（var func = function(){}）、\n传参(function func(x,callback){callback();})、\n返回(function(){return function(){}})，\n\n这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。\n\n```\n\n### 手动实现Array.prototype.map 方法\n```\nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\nfunction map(arr, mapCallback) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') { \n    return [];\n  } else {\n    let result = [];\n    // 每次调用此函数时，我们都会创建一个 result 数组\n    // 因为我们不想改变原始数组。\n    for (let i = 0, len = arr.length; i < len; i++) {\n      result.push(mapCallback(arr[i], i, arr)); \n      // 将 mapCallback 返回的结果 push 到 result 数组中\n    }\n    return result;\n  }\n}\n\n```\n\n### 手动实现Array.prototype.filter方法\n```\nfilter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。\nfunction filter(arr, filterCallback) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') \n  {\n    return [];\n  } else {\n    let result = [];\n     // 每次调用此函数时，我们都会创建一个 result 数组\n     // 因为我们不想改变原始数组。\n    for (let i = 0, len = arr.length; i < len; i++) {\n      // 检查 filterCallback 的返回值是否是真值\n      if (filterCallback(arr[i], i, arr)) { \n      // 如果条件为真，则将数组元素 push 到 result 中\n        result.push(arr[i]);\n      }\n    }\n    return result; // return the result array\n  }\n}\n\n```\n\n### 手动实现Array.prototype.reduce方法\n```\nreduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\nfunction reduce(arr, reduceCallback, initialValue) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function') \n  {\n    return [];\n  } else {\n    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue\n    let hasInitialValue = initialValue !== undefined;\n    let value = hasInitialValue ? initialValue : arr[0];\n   、\n\n    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始\n    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i < len; i++) {\n      value = reduceCallback(value, arr[i], i, arr); \n    }\n    return value;\n  }\n}\n```\n\n### js的深浅拷贝\n>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。\n- 浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\n- 深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。\n>浅拷贝的实现方式：\n- Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n- Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。\n- 拓展运算符...：\n```\nlet a = {\n    name: \"Jake\",\n    flag: {\n        title: \"better day by day\",\n        time: \"2020-05-31\"\n    }\n}\nlet b = {...a};\n\n```\n>深拷贝的实现方式：\n- 乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）\n- 基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）\n```\nfunction cloneDeep(target,map = new WeakMap()) {\n  if(typeOf taret ==='object'){\n     let cloneTarget = Array.isArray(target) ? [] : {};\n      \n     if(map.get(target)) {\n        return target;\n    }\n     map.set(target, cloneTarget);\n     for(const key in target){\n        cloneTarget[key] = cloneDeep(target[key], map);\n     }\n     return cloneTarget\n  }else{\n       return target\n  }\n \n}\n```\n- 终极版：\n```\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst objectTag = '[object Object]';\nconst argsTag = '[object Arguments]';\n\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst numberTag = '[object Number]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst errorTag = '[object Error]';\nconst regexpTag = '[object RegExp]';\nconst funcTag = '[object Function]';\n\nconst deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];\n\n\nfunction forEach(array, iteratee) {\n    let index = -1;\n    const length = array.length;\n    while (++index < length) {\n        iteratee(array[index], index);\n    }\n    return array;\n}\n\nfunction isObject(target) {\n    const type = typeof target;\n    return target !== null && (type === 'object' || type === 'function');\n}\n\nfunction getType(target) {\n    return Object.prototype.toString.call(target);\n}\n\nfunction getInit(target) {\n    const Ctor = target.constructor;\n    return new Ctor();\n}\n\nfunction cloneSymbol(targe) {\n    return Object(Symbol.prototype.valueOf.call(targe));\n}\n\nfunction cloneReg(targe) {\n    const reFlags = /\\w*$/;\n    const result = new targe.constructor(targe.source, reFlags.exec(targe));\n    result.lastIndex = targe.lastIndex;\n    return result;\n}\n\nfunction cloneFunction(func) {\n    const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n    const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n    const funcString = func.toString();\n    if (func.prototype) {\n        const param = paramReg.exec(funcString);\n        const body = bodyReg.exec(funcString);\n        if (body) {\n            if (param) {\n                const paramArr = param[0].split(',');\n                return new Function(...paramArr, body[0]);\n            } else {\n                return new Function(body[0]);\n            }\n        } else {\n            return null;\n        }\n    } else {\n        return eval(funcString);\n    }\n}\n\nfunction cloneOtherType(targe, type) {\n    const Ctor = targe.constructor;\n    switch (type) {\n        case boolTag:\n        case numberTag:\n        case stringTag:\n        case errorTag:\n        case dateTag:\n            return new Ctor(targe);\n        case regexpTag:\n            return cloneReg(targe);\n        case symbolTag:\n            return cloneSymbol(targe);\n        case funcTag:\n            return cloneFunction(targe);\n        default:\n            return null;\n    }\n}\n\nfunction clone(target, map = new WeakMap()) {\n\n    // 克隆原始类型\n    if (!isObject(target)) {\n        return target;\n    }\n\n    // 初始化\n    const type = getType(target);\n    let cloneTarget;\n    if (deepTag.includes(type)) {\n        cloneTarget = getInit(target, type);\n    } else {\n        return cloneOtherType(target, type);\n    }\n\n    // 防止循环引用\n    if (map.get(target)) {\n        return map.get(target);\n    }\n    map.set(target, cloneTarget);\n\n    // 克隆set\n    if (type === setTag) {\n        target.forEach(value => {\n            cloneTarget.add(clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆map\n    if (type === mapTag) {\n        target.forEach((value, key) => {\n            cloneTarget.set(key, clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆对象和数组\n    const keys = type === arrayTag ? undefined : Object.keys(target);\n    forEach(keys || target, (value, key) => {\n        if (keys) {\n            key = value;\n        }\n        cloneTarget[key] = clone(target[key], map);\n    });\n\n    return cloneTarget;\n}\n\nmodule.exports = {\n    clone\n};\n\n```\n\n### 手写call、apply及bind函数\ncall 函数的实现步骤：\n- 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 3.处理传入的参数，截取第一个参数后的所有参数。\n- 4.将函数作为上下文对象的一个属性。\n- 5.使用上下文对象来调用这个方法，并保存返回结果。\n- 6.删除刚才新增的属性。\n- 7.返回结果。\n```\n// call函数实现\nFunction.prototype.myCall = function(context) {\n  // 判断调用对象\n  if (typeof this !== \"function\") {\n    console.error(\"type error\");\n  }\n\n  // 获取参数\n  let args = [...arguments].slice(1),\n    result = null;\n\n  // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window;\n\n  // 将调用函数设为对象的方法\n  context.fn = this;\n\n  // 调用函数\n  result = context.fn(...args);\n\n  // 将属性删除\n  delete context.fn;\n\n  return result;\n};\n```\napply 函数的实现步骤：\n- 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 将函数作为上下文对象的一个属性。\n- 判断参数值是否传入\n- 使用上下文对象来调用这个方法，并保存返回结果。\n- 删除刚才新增的属性\n- 返回结果\n```\n\n// apply 函数实现\n\nFunction.prototype.myApply = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n\n  let result = null;\n\n  // 判断 context 是否存在，如果未传入则为 window\n  context = context || window;\n\n  // 将函数设为对象的方法\n  context.fn = this;\n\n  // 调用方法\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n\n  // 将属性删除\n  delete context.fn;\n\n  return result;\n};\n```\n\n\n\n\n\n### 函数柯里化的实现\n\n### js模拟new操作符的实现\n\n### 什么是回调函数？回调函数有什么缺点\n\n### Promise是什么，可以手写实现一下吗？\n\n### Iterator是什么，有什么作用？\n\n### Generator函数是什么，有什么作用？\n\n### 什么是 async/await及其如何工作,有什么优缺点？\n\n### instanceof的原理是什么，如何实现\n\n### js的节流与防抖\n\n### 什么是设计模式？\n\n### 9种前端常见的设计模式\n\n\n\n","source":"_posts/问题整理.md","raw":"---\ntitle: 问题整理\ndate: 2020-07-13 16:00:14\ntags: 文章\ncategories: 技术\ncopyright: false\n---\n\n### 介绍一下js的数据类型有哪些,值是如何存储的\n```\n一共有8种数据类型，7种基本数据类型\nString \nNumber \nBoolean \nNull \nUndefined \nSymbol（es6 新增类型，表示第一无二的值） \nBigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）\nObject（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）\n\n原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n\n引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n\n```\n### && 、 ||和!! 运算符分别能做什么\n```\n&& 并且符，使用时两边的值结果都必须为true才返回true\n|| 或者符，两边的值结果有一个为true最终判断结果就位true\n!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）\n\n```\n\n### JS的数据类型的转换\n```\n在 JS 中类型转换只有三种情况，分别是：\n\n- 转换为布尔值（调用Boolean()方法）\n- 转换为数字（调用Number()、parseInt()和parseFloat()方法）\n- 转换为字符串（调用.toString()或者String()方法）\n\nnull和underfined没有.toString方法\n\n```\n![image](https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()   \n>（1）typeof\n```\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object\n\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof\n```\n>（2）instanceof \n```\n//重点\ninstanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断\ninstanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。\n其意思就是判断对象是否是某一数据类型（如Array）的实例\n\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true    \n// console.log(undefined instanceof Undefined);      //报错\n// console.log(null instanceof Null);                //报错\n复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。\n我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，'str'不是实例，所以判断值为false。\n```\n>（3）constructor\n```\nconsole.log((2).constructor === Number); // true\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() {}).constructor === Function); // true\nconsole.log(({}).constructor === Object); // true\n\n这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了\n\nfunction Fn(){};\n \nFn.prototype=new Array();\n \nvar f=new Fn();\n \nconsole.log(f.constructor===Fn);    // false\nconsole.log(f.constructor===Array); // true\n```\n>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法\n```\nvar a = Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call('str'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n```\n### 介绍 JS 有哪些内置对象？\n```\n全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在\n全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n\n标准内置对象的分类\n\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。\n\n例如 Infinity、NaN、undefined、null 字面量\n\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n\n例如 eval()、parseFloat()、parseInt() 等\n\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。\n\n例如 Object、Function、Boolean、Symbol、Error 等\n\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。\n\n例如 Number、Math、Date\n\n（5）字符串，用来表示和操作字符串的对象。\n\n例如 String、RegExp\n\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。\n\n例如 Map、Set、WeakMap、WeakSet\n\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。\n\n例如 SIMD 等\n\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。\n\n例如 JSON 等\n\n（10）控制抽象对象\n\n例如 Promise、Generator 等\n\n（11）反射\n\n例如 Reflect、Proxy\n\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。\n\n例如 Intl、Intl.Collator 等\n\n（13）WebAssembly\n\n（14）其他\n\n例如 arguments\n```\n\n### undefined 与 undeclared 的区别？\n```\n已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。\n对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ\neof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 \"undefined\"。\n\n```\n\n### null 和 undefined 的区别？\n```\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，\nnull 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null\n主要用于赋值给一些可能会返回对象的变量，作为初始化。\n/*\n    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，\n    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。\n    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\n*/\nundefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它\n会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等\n号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n\n```\n\n### {}和[]的valueOf和toString的结果是什么？\n```\n{} 的 valueOf 结果为 {} ，toString 的结果为 \"[object Object]\"\n\n[] 的 valueOf 结果为 [] ，toString 的结果为 \"\"\n```\n\n### Javascript 的作用域和作用域链？\n```\n【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。\n【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。\n\n\n```\n### javascript 创建对象的几种方式？\n```\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n\n\n```\n\n### JavaScript 继承的几种实现方式？\n```\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。\n\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。\n\n```\n\n### 寄生式组合继承的实现？\n```\nPerson\nStudent\n\nfunction Person(name){\n    this.name = name;\n}\n\nPerson.prototype.sayName = function(){\n    console.log(123);\n}\n\nfunction Student(name, grade){\n    Person.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\nStudent.prototype.sayMyGrade = function() {\n  console.log(\"My grade is \" + this.grade + \".\");\n  \n}\n\n```\n\n### 谈谈你对this、call、apply和bind的理解\n```\n总结:\n1. 在浏览器里，在全局范围内this 指向window对象；\n2. 在函数中，this永远指向最后调用他的那个对象；\n3. 构造函数中，this指向new出来的那个新的对象；\n4. call、apply、bind中的this被强绑定在指定的那个对象上；\n5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；\n6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。\n\n区别:\n- call/apply改变了函数的this上下文后马上执行该函数\n- bind则是返回改变了上下文后的函数,不执行该函数\n```\n\n\n\n### JavaScript 原型，原型链？ 有什么特点？\n```\nprototype就是JS的原型，里面可以定义属性和方法\n当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。\n原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。\n\n```\n\n### js 获取原型的方法？\n```\np.proto\np.constructor.prototype\nObject.getPrototypeOf(p)\n```\n\n### 什么是闭包，为什么要用它？\n```\n闭包是指有权访问另一个函数作用域内变量的函数\n创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。\n\n闭包有两个常用的用途:\n- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\nfunction a(){\n    var n = 0;\n    function add(){\n       n++;\n       console.log(n);\n    }\n    return add;\n}\nvar a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；\na1();    //1\na1();    //2  第二次调用n变量还在内存中\n\n其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。\n\n```\n\n### 什么是 DOM 和 BOM？\n```\nDOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。\n\nBOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM\n的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）\n对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati\non 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对\n象的子对象。\n\n```\n\n### 三种事件模型是什么？\n```\nDOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。\nIE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\nDOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n```\n\n### 事件委托是什么？\n```\n事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到\n目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。\n使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。\n\n```\n\n### 什么是事件传播?\n```\n当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。\n事件传播有三个阶段：\n1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。\n2. 目标阶段–事件已达到目标元素。\n3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。\n\n\n```\n\n### 什么是事件捕获？\n```\n当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----> document----> html----> body ---->目标元素\n\nhtml:\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\njs:\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\n\n\n\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。\n\n\n```\n\n### 什么是事件冒泡？\n```\n事件冒泡刚好与事件捕获相反，当前元素---->body ----> html---->document ---->window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。\n假设有如下的 HTML 结构：\n\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\n对应的JS代码：\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。\n\n\n```\n\n### DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\n（1）创建新节点\n```\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n```\n（2）添加、移除、替换、插入\n```\nappendChild(node)\nremoveChild(node)\nreplaceChild(new,old)\ninsertBefore(new,old)\n```\n（3）查找\n```\ngetElementById();\ngetElementsByName();\ngetElementsByTagName();\ngetElementsByClassName();\nquerySelector();\nquerySelectorAll();\n```\n（4）属性操作\n```\ngetAttribute(key);\nsetAttribute(key, value);\nhasAttribute(key);\nremoveAttribute(key);\n```\n\n###  js数组和对象有哪些原生方法,列举一下\n![image](https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n![image](https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n\n### 常用的正则表达式\n\n### Ajax 是什么? 如何创建一个 Ajax？\n我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。\n创建步骤：\n![image](https://user-gold-cdn.xitu.io/2020/6/2/17274125a4cf4d61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n```\n//1：创建Ajax对象\nvar xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');    //兼容IE6及以下版本\n//2：配置 Ajax请求地址\nxhr.open('get','index.xml',true);\n//3：发送请求\nxhr.send(null); //严谨写法\n//4:监听请求，接受响应\nxhr.onreadysatechange = function(){\n    if(xhr.readySates == 4 && xhr.status == 200 || xhr.status == 304){\n        console.log(xhr.responsetXML);\n    }\n}\n```\npromise封装实现\n```\n// promise 封装实现：\n\nfunction getJSON(url) {\n  // 创建一个 promise 对象\n  let promise = new Promise(function(resolve, reject) {\n    let xhr = new XMLHttpRequest();\n\n    // 新建一个 http 请求\n    xhr.open(\"GET\", url, true);\n\n    // 设置状态的监听函数\n    xhr.onreadystatechange = function() {\n      if (this.readyState !== 4) return;\n\n      // 当请求成功或失败时，改变 promise 的状态\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n\n    // 设置错误监听函数\n    xhr.onerror = function() {\n      reject(new Error(this.statusText));\n    };\n\n    // 设置响应的数据类型\n    xhr.responseType = \"json\";\n\n    // 设置请求头信息\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n\n    // 发送 http 请求\n    xhr.send(null);\n  });\n\n  return promise;\n}\n\n```\n\n### js 延迟加载的方式有哪些？\n```\njs 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。\n我了解到的几种方式是：\n\n将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。\n给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。\n给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。\n动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。\n\n```\n\n### 谈谈你对模块化开发的理解？\n```\n我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念\n，但随着程序越来越复杂，代码的模块化开发变得越来越重要。\n由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污\n染，并且模块间没有联系。\n后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所\n有的所有的模块成员，外部代码可以修改内部属性的值。\n现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。\n```\n\n###  js 的几种模块规范？\n```\njs 中现在比较成熟的有四种模块加载方案：\n\n第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。\n第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。\n第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。\n第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。\n```\n\n### AMD和CMD 规范的区别？\n它们之间的主要区别有两个方面。\n\n1. 第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。\n2. 第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于\n    模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD\n    在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句\n    的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。\n\n```\n// CMD\ndefine(function(require, exports, module) {\n  var a = require(\"./a\");\n  a.doSomething();\n  // 此处略去 100 行\n  var b = require(\"./b\"); // 依赖可以就近书写\n  b.doSomething();\n  // ...\n});\n\n// AMD 默认推荐\ndefine([\"./a\", \"./b\"], function(a, b) {\n  // 依赖必须一开始就写好\n  a.doSomething();\n  // 此处略去 100 行\n  b.doSomething();\n  // ...\n});\n\n```\n\n### ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\n- 1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。\n- 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n### requireJS的核心原理是什么？ \nrequire.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。\n\n### 谈谈JS的运行机制\n1. js单线程\nJavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。\n>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\n\n2. js事件循环\njs代码执行过程中会有很多任务，这些任务总的分成两类：\n- 同步任务\n- 异步任务\n当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：\n![image](https://user-gold-cdn.xitu.io/2020/6/2/172744a7fa2853c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n回答：\n1. 首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。\n2. 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务\n3. 当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。\n4. 任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。\n5. 当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。\n\n### arguments 的对象是什么？\narguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。\n我们可以使用Array.prototype.slice将arguments对象转换成一个数组。\n```\nfunction one() {\n  return Array.prototype.slice.call(arguments);\n}\n```\n注意:箭头函数中没有arguments对象。\n```\nfunction one() {\n  return arguments;\n}\nconst two = function () {\n  return arguments;\n}\nconst three = function three() {\n  return arguments;\n}\n\nconst four = () => arguments;\n\nfour(); // Throws an error  - arguments is not defined\n\n```\n\n### 为什么在调用这个函数时，代码中的b会变成一个全局变量?\n```\nfunction myFunc() {\n  let a = b = 0;\n}\n\nmyFunc();\n```\n原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：\n```\nfunction myFunc() {\n  let a = (b = 0);\n}\n\nmyFunc();\n```\n首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。\n\n我们可以通过在赋值之前先声明变量来解决这个问题。\n```\nfunction myFunc() {\n  let a,b;\n  a = b = 0;\n}\nmyFunc();\n```\n\n### 简单介绍一下V8引擎的垃圾回收机制\n```\nv8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。\n\n新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。\n\n新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：\n\n（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。\n\n（2）如果对象不存活，则释放对象的空间。\n\n（3）最后将 From 空间和 To 空间角色进行交换。\n\n新生代对象晋升到老生代有两个条件：\n\n（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。\n\n（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。\n\n老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。\n\n由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。\n\n```\n\n### 哪些操作会造成内存泄漏？ \n- 1.意外的全局变量\n- 2.被遗忘的计时器或回调函数\n- 3.脱离 DOM 的引用\n- 4.闭包\n\n- 第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n- 第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n- 第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\n- 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。\n\n### ECMAScript 是什么？\n```\nECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。\nECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件\n只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。\njavaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）\nECMAScript说什么JavaScript就得做什么！\nJavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！\n——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，\n那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。\n```\n### ECMAScript 2015（ES6）有哪些新特性？\n- 块作用域\n- 类\n- 箭头函数\n- 模板字符串\n- 加强的对象字面\n- 对象解构\n- Promise\n- 模块\n- Symbol\n- 代理（proxy）Set\n- 函数默认参数\n- rest 和展开\n\n### var,let和const的区别是什么？\nvar声明的变量会挂载在window上，而let和const声明的变量不会：\n```\nvar a = 100;\nconsole.log(a,window.a);    // 100 100\n\nlet b = 10;\nconsole.log(b,window.b);    // 10 undefined\n\nconst c = 1;\nconsole.log(c,window.c);    // 1 undefined\n```\nvar声明变量存在变量提升，let和const不存在变量提升:\n```\nconsole.log(a); // undefined  ===>  a已声明还没赋值，默认得到undefined值\nvar a = 100;\n\nconsole.log(b); // 报错：b is not defined  ===> 找不到b这个变量\nlet b = 10;\n\nconsole.log(c); // 报错：c is not defined  ===> 找不到c这个变量\nconst c = 10;\n```\nlet和const声明形成块作用域\n```\n\nif(1){\n  var a = 100;\n  let b = 10;\n}\n\nconsole.log(a); // 100\nconsole.log(b)  // 报错：b is not defined  ===> 找不到b这个变量\n\n-------------------------------------------------------------\n\nif(1){\n  var a = 100;\n  const c = 1;\n}\nconsole.log(a); // 100\nconsole.log(c)  // 报错：c is not defined  ===> 找不到c这个变量\n```\n同一作用域下let和const不能声明同名变量，而var可以\n```\nvar a = 100;\nconsole.log(a); // 100\n\nvar a = 10;\nconsole.log(a); // 10\n-------------------------------------\nlet a = 100;\nlet a = 10;\n\n//  控制台报错：Identifier 'a' has already been declared  ===> 标识符a已经被声明了。\n\n```\n暂存死区\n```\nvar a = 100;\n\nif(1){\n    a = 10;\n    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，\n    // 而这时，还未到声明时候，所以控制台Error:a is not defined\n    let a = 1;\n}\n```\nconst\n```\n\n/*\n* &emsp;&emsp;1、一旦声明必须赋值,不能使用null占位。\n*\n* &emsp;&emsp;2、声明后不能再修改\n*\n* &emsp;&emsp;3、如果声明的是复合类型数据，可以修改其属性\n*\n* */\n\nconst a = 100; \n\nconst list = [];\nlist[0] = 10;\nconsole.log(list);&emsp;&emsp;// [10]\n\nconst obj = {a:100};\nobj.name = 'apple';\nobj.a = 10000;\nconsole.log(obj);&emsp;&emsp;// {a:10000,name:'apple'}\n\n```\n\n### 什么是箭头函数？\n箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n```\n//ES5 Version\nvar getCurrentDate = function (){\n  return new Date();\n}\n\n//ES6 Version\nconst getCurrentDate = () => new Date();\n```\n在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。\n```\n//ES5 Version\nfunction greet(name) {\n  return 'Hello ' + name + '!';\n}\n\n//ES6 Version\nconst greet = (name) => `Hello ${name}`;\nconst greet2 = name => `Hello ${name}`;\n\n```\n我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。\n```\nconst getArgs = () => arguments\n\nconst getArgs2 = (...rest) => rest\n```\n箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。\n```\nconst data = {\n  result: 0,\n  nums: [1, 2, 3, 4, 5],\n  computeResult() {\n    // 这里的“this”指的是“data”对象\n    const addAll = () => {\n      return this.nums.reduce((total, cur) => total + cur, 0)\n    };\n    this.result = addAll();\n  }\n};\n\n```\n箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。\n\n\n### 什么是类？\n```\n类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。\n```\n\n### 什么是模板字符串？\n模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。\n```\n//ES5 Version\nvar greet = 'Hi I\\'m Mark';\n\n//ES6 Version\nlet greet = `Hi I'm Mark`;\n\n```\n在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：\n```\n//ES5 Version\nvar lastWords = '\\n'\n  + '   I  \\n'\n  + '   Am  \\n'\n  + 'Iron Man \\n';\n\n\n//ES6 Version\nlet lastWords = `\n    I\n    Am\n  Iron Man   \n`;\n\n```\n在ES5版本中，我们需要添加\\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。\n```\n//ES5 Version\nfunction greet(name) {\n  return 'Hello ' + name + '!';\n}\n\n\n//ES6 Version\nfunction greet(name) {\n  return `Hello ${name} !`;\n}\n\n```\n在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。\n\n### 什么是对象解构？ \n对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：\n```\nconst employee = {\n  firstName: \"Marko\",\n  lastName: \"Polo\",\n  position: \"Software Developer\",\n  yearHired: 2017\n};\n\n```\n从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。\n```\nvar firstName = employee.firstName;\nvar lastName = employee.lastName;\nvar position = employee.position;\nvar yearHired = employee.yearHired;\n\n```\n使用解构方式语法就变得简洁多了：\n```\n{ firstName, lastName, position, yearHired } = employee;\n\n```\n我们还可以为属性取别名：\n```\nlet { firstName: fName, lastName: lName, position, yearHired } = employee;\n\n```\n当然如果属性值为 undefined 时，我们还可以指定默认值，但是属性为null时指定的默认值则不生效：\n```\nlet { firstName = \"Mark\", lastName: lName, position, yearHired } = employee;\n```\n\n### 什么是Set对象，它是如何工作的？\nSet 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。\n\n我们可以使用Set构造函数创建Set实例。\n```\nconst set1 = new Set();\nconst set2 = new Set([\"a\",\"b\",\"c\",\"d\",\"d\",\"e\"]);\n\n```\n我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。\n```\nset2.add(\"f\");\nset2.add(\"g\").add(\"h\").add(\"i\").add(\"j\").add(\"k\").add(\"k\");\n// 后一个“k”不会被添加到set对象中，因为它已经存在了\n```\n我们可以使用has方法检查Set实例中是否存在特定的值。\n```\nset2.has(\"a\") // true\nset2.has(\"z\") // true\n\n```\n我们可以使用size属性获得Set实例的长度。\n```\nset2.size // returns 10\n\n```\n可以使用clear方法删除 Set 中的数据。\n```\nset2.clear();\n\n```\n我们可以使用Set对象来删除数组中重复的元素。\n```\nconst numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];\nconst uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]\n \n```\n另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。\n- Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n- WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。\n\n### 什么是Proxy？\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。\n\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n\n### 写一个通用的事件侦听器函数？\n```\nconst EventUtils = {\n  // 视能力分别使用dom0||dom2||IE方式 来绑定事件\n  // 添加事件\n  addEvent: function(element, type, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(type, handler, false);\n    } else if (element.attachEvent) {\n      element.attachEvent(\"on\" + type, handler);\n    } else {\n      element[\"on\" + type] = handler;\n    }\n  },\n\n  // 移除事件\n  removeEvent: function(element, type, handler) {\n    if (element.removeEventListener) {\n      element.removeEventListener(type, handler, false);\n    } else if (element.detachEvent) {\n      element.detachEvent(\"on\" + type, handler);\n    } else {\n      element[\"on\" + type] = null;\n    }\n  },\n\n  // 获取事件目标\n  getTarget: function(event) {\n    return event.target || event.srcElement;\n  },\n\n  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event\n  getEvent: function(event) {\n    return event || window.event;\n  },\n\n  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）\n  stopPropagation: function(event) {\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      event.cancelBubble = true;\n    }\n  },\n\n  // 取消事件的默认行为\n  preventDefault: function(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n  }\n};\n\n```\n\n### 什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\n```\n函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。\n函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。\n函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。\n\n```\n\n### 什么是高阶函数？\n高阶函数只是将函数作为参数或返回值的函数。\n```\nfunction higherOrderFunction(param,callback){\n    return callback(param);\n}\n\n```\n\n### 为什么函数被称为一等公民？\n```\n在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:\n\n赋值（var func = function(){}）、\n传参(function func(x,callback){callback();})、\n返回(function(){return function(){}})，\n\n这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。\n\n```\n\n### 手动实现Array.prototype.map 方法\n```\nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\nfunction map(arr, mapCallback) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') { \n    return [];\n  } else {\n    let result = [];\n    // 每次调用此函数时，我们都会创建一个 result 数组\n    // 因为我们不想改变原始数组。\n    for (let i = 0, len = arr.length; i < len; i++) {\n      result.push(mapCallback(arr[i], i, arr)); \n      // 将 mapCallback 返回的结果 push 到 result 数组中\n    }\n    return result;\n  }\n}\n\n```\n\n### 手动实现Array.prototype.filter方法\n```\nfilter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。\nfunction filter(arr, filterCallback) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') \n  {\n    return [];\n  } else {\n    let result = [];\n     // 每次调用此函数时，我们都会创建一个 result 数组\n     // 因为我们不想改变原始数组。\n    for (let i = 0, len = arr.length; i < len; i++) {\n      // 检查 filterCallback 的返回值是否是真值\n      if (filterCallback(arr[i], i, arr)) { \n      // 如果条件为真，则将数组元素 push 到 result 中\n        result.push(arr[i]);\n      }\n    }\n    return result; // return the result array\n  }\n}\n\n```\n\n### 手动实现Array.prototype.reduce方法\n```\nreduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\nfunction reduce(arr, reduceCallback, initialValue) {\n  // 首先，检查传递的参数是否正确。\n  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== 'function') \n  {\n    return [];\n  } else {\n    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue\n    let hasInitialValue = initialValue !== undefined;\n    let value = hasInitialValue ? initialValue : arr[0];\n   、\n\n    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始\n    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i < len; i++) {\n      value = reduceCallback(value, arr[i], i, arr); \n    }\n    return value;\n  }\n}\n```\n\n### js的深浅拷贝\n>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。\n- 浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\n- 深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。\n>浅拷贝的实现方式：\n- Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n- Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。\n- 拓展运算符...：\n```\nlet a = {\n    name: \"Jake\",\n    flag: {\n        title: \"better day by day\",\n        time: \"2020-05-31\"\n    }\n}\nlet b = {...a};\n\n```\n>深拷贝的实现方式：\n- 乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）\n- 基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）\n```\nfunction cloneDeep(target,map = new WeakMap()) {\n  if(typeOf taret ==='object'){\n     let cloneTarget = Array.isArray(target) ? [] : {};\n      \n     if(map.get(target)) {\n        return target;\n    }\n     map.set(target, cloneTarget);\n     for(const key in target){\n        cloneTarget[key] = cloneDeep(target[key], map);\n     }\n     return cloneTarget\n  }else{\n       return target\n  }\n \n}\n```\n- 终极版：\n```\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst objectTag = '[object Object]';\nconst argsTag = '[object Arguments]';\n\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst numberTag = '[object Number]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst errorTag = '[object Error]';\nconst regexpTag = '[object RegExp]';\nconst funcTag = '[object Function]';\n\nconst deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];\n\n\nfunction forEach(array, iteratee) {\n    let index = -1;\n    const length = array.length;\n    while (++index < length) {\n        iteratee(array[index], index);\n    }\n    return array;\n}\n\nfunction isObject(target) {\n    const type = typeof target;\n    return target !== null && (type === 'object' || type === 'function');\n}\n\nfunction getType(target) {\n    return Object.prototype.toString.call(target);\n}\n\nfunction getInit(target) {\n    const Ctor = target.constructor;\n    return new Ctor();\n}\n\nfunction cloneSymbol(targe) {\n    return Object(Symbol.prototype.valueOf.call(targe));\n}\n\nfunction cloneReg(targe) {\n    const reFlags = /\\w*$/;\n    const result = new targe.constructor(targe.source, reFlags.exec(targe));\n    result.lastIndex = targe.lastIndex;\n    return result;\n}\n\nfunction cloneFunction(func) {\n    const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n    const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n    const funcString = func.toString();\n    if (func.prototype) {\n        const param = paramReg.exec(funcString);\n        const body = bodyReg.exec(funcString);\n        if (body) {\n            if (param) {\n                const paramArr = param[0].split(',');\n                return new Function(...paramArr, body[0]);\n            } else {\n                return new Function(body[0]);\n            }\n        } else {\n            return null;\n        }\n    } else {\n        return eval(funcString);\n    }\n}\n\nfunction cloneOtherType(targe, type) {\n    const Ctor = targe.constructor;\n    switch (type) {\n        case boolTag:\n        case numberTag:\n        case stringTag:\n        case errorTag:\n        case dateTag:\n            return new Ctor(targe);\n        case regexpTag:\n            return cloneReg(targe);\n        case symbolTag:\n            return cloneSymbol(targe);\n        case funcTag:\n            return cloneFunction(targe);\n        default:\n            return null;\n    }\n}\n\nfunction clone(target, map = new WeakMap()) {\n\n    // 克隆原始类型\n    if (!isObject(target)) {\n        return target;\n    }\n\n    // 初始化\n    const type = getType(target);\n    let cloneTarget;\n    if (deepTag.includes(type)) {\n        cloneTarget = getInit(target, type);\n    } else {\n        return cloneOtherType(target, type);\n    }\n\n    // 防止循环引用\n    if (map.get(target)) {\n        return map.get(target);\n    }\n    map.set(target, cloneTarget);\n\n    // 克隆set\n    if (type === setTag) {\n        target.forEach(value => {\n            cloneTarget.add(clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆map\n    if (type === mapTag) {\n        target.forEach((value, key) => {\n            cloneTarget.set(key, clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆对象和数组\n    const keys = type === arrayTag ? undefined : Object.keys(target);\n    forEach(keys || target, (value, key) => {\n        if (keys) {\n            key = value;\n        }\n        cloneTarget[key] = clone(target[key], map);\n    });\n\n    return cloneTarget;\n}\n\nmodule.exports = {\n    clone\n};\n\n```\n\n### 手写call、apply及bind函数\ncall 函数的实现步骤：\n- 1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 3.处理传入的参数，截取第一个参数后的所有参数。\n- 4.将函数作为上下文对象的一个属性。\n- 5.使用上下文对象来调用这个方法，并保存返回结果。\n- 6.删除刚才新增的属性。\n- 7.返回结果。\n```\n// call函数实现\nFunction.prototype.myCall = function(context) {\n  // 判断调用对象\n  if (typeof this !== \"function\") {\n    console.error(\"type error\");\n  }\n\n  // 获取参数\n  let args = [...arguments].slice(1),\n    result = null;\n\n  // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window;\n\n  // 将调用函数设为对象的方法\n  context.fn = this;\n\n  // 调用函数\n  result = context.fn(...args);\n\n  // 将属性删除\n  delete context.fn;\n\n  return result;\n};\n```\napply 函数的实现步骤：\n- 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 将函数作为上下文对象的一个属性。\n- 判断参数值是否传入\n- 使用上下文对象来调用这个方法，并保存返回结果。\n- 删除刚才新增的属性\n- 返回结果\n```\n\n// apply 函数实现\n\nFunction.prototype.myApply = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n\n  let result = null;\n\n  // 判断 context 是否存在，如果未传入则为 window\n  context = context || window;\n\n  // 将函数设为对象的方法\n  context.fn = this;\n\n  // 调用方法\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n\n  // 将属性删除\n  delete context.fn;\n\n  return result;\n};\n```\n\n\n\n\n\n### 函数柯里化的实现\n\n### js模拟new操作符的实现\n\n### 什么是回调函数？回调函数有什么缺点\n\n### Promise是什么，可以手写实现一下吗？\n\n### Iterator是什么，有什么作用？\n\n### Generator函数是什么，有什么作用？\n\n### 什么是 async/await及其如何工作,有什么优缺点？\n\n### instanceof的原理是什么，如何实现\n\n### js的节流与防抖\n\n### 什么是设计模式？\n\n### 9种前端常见的设计模式\n\n\n\n","slug":"问题整理","published":1,"updated":"2020-08-19T03:55:00.652Z","_id":"ckctvtzix00061wekghpraedi","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"介绍一下js的数据类型有哪些-值是如何存储的\"><a href=\"#介绍一下js的数据类型有哪些-值是如何存储的\" class=\"headerlink\" title=\"介绍一下js的数据类型有哪些,值是如何存储的\"></a>介绍一下js的数据类型有哪些,值是如何存储的</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一共有8种数据类型，7种基本数据类型</span><br><span class=\"line\">String </span><br><span class=\"line\">Number </span><br><span class=\"line\">Boolean </span><br><span class=\"line\">Null </span><br><span class=\"line\">Undefined </span><br><span class=\"line\">Symbol（es6 新增类型，表示第一无二的值） </span><br><span class=\"line\">BigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）</span><br><span class=\"line\">Object（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）</span><br><span class=\"line\"></span><br><span class=\"line\">原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class=\"line\"></span><br><span class=\"line\">引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure>\n<h3 id=\"amp-amp-、-和-运算符分别能做什么\"><a href=\"#amp-amp-、-和-运算符分别能做什么\" class=\"headerlink\" title=\"&amp;&amp; 、 ||和!! 运算符分别能做什么\"></a>&amp;&amp; 、 ||和!! 运算符分别能做什么</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;&amp; 并且符，使用时两边的值结果都必须为true才返回true</span><br><span class=\"line\">|| 或者符，两边的值结果有一个为true最终判断结果就位true</span><br><span class=\"line\">!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）</span><br></pre></td></tr></table></figure>\n<h3 id=\"JS的数据类型的转换\"><a href=\"#JS的数据类型的转换\" class=\"headerlink\" title=\"JS的数据类型的转换\"></a>JS的数据类型的转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在 JS 中类型转换只有三种情况，分别是：</span><br><span class=\"line\"></span><br><span class=\"line\">- 转换为布尔值（调用Boolean()方法）</span><br><span class=\"line\">- 转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class=\"line\">- 转换为字符串（调用.toString()或者String()方法）</span><br><span class=\"line\"></span><br><span class=\"line\">null和underfined没有.toString方法</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\"><a href=\"#JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\" class=\"headerlink\" title=\"JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()\"></a>JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()</h3><blockquote>\n<p>（1）typeof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typeof 对于原始类型来说，除了 null 都可以显示正确的类型</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof 2);               // number</span><br><span class=\"line\">console.log(typeof true);            // boolean</span><br><span class=\"line\">console.log(typeof &apos;str&apos;);           // string</span><br><span class=\"line\">console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object</span><br><span class=\"line\">console.log(typeof function()&#123;&#125;);    // function</span><br><span class=\"line\">console.log(typeof &#123;&#125;);              // object</span><br><span class=\"line\">console.log(typeof undefined);       // undefined</span><br><span class=\"line\">console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object</span><br><span class=\"line\"></span><br><span class=\"line\">typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（2）instanceof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//重点</span><br><span class=\"line\">instanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断</span><br><span class=\"line\">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class=\"line\">其意思就是判断对象是否是某一数据类型（如Array）的实例</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(2 instanceof Number);                    // false</span><br><span class=\"line\">console.log(true instanceof Boolean);                // false </span><br><span class=\"line\">console.log(&apos;str&apos; instanceof String);                // false  </span><br><span class=\"line\">console.log([] instanceof Array);                    // true</span><br><span class=\"line\">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class=\"line\">console.log(&#123;&#125; instanceof Object);                   // true    </span><br><span class=\"line\">// console.log(undefined instanceof Undefined);      //报错</span><br><span class=\"line\">// console.log(null instanceof Null);                //报错</span><br><span class=\"line\">复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。</span><br><span class=\"line\">我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，&apos;str&apos;不是实例，所以判断值为false。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（3）constructor<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log((2).constructor === Number); // true</span><br><span class=\"line\">console.log((true).constructor === Boolean); // true</span><br><span class=\"line\">console.log((&apos;str&apos;).constructor === String); // true</span><br><span class=\"line\">console.log(([]).constructor === Array); // true</span><br><span class=\"line\">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class=\"line\">console.log((&#123;&#125;).constructor === Object); // true</span><br><span class=\"line\"></span><br><span class=\"line\">这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了</span><br><span class=\"line\"></span><br><span class=\"line\">function Fn()&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">Fn.prototype=new Array();</span><br><span class=\"line\"> </span><br><span class=\"line\">var f=new Fn();</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(f.constructor===Fn);    // false</span><br><span class=\"line\">console.log(f.constructor===Array); // true</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = Object.prototype.toString;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(a.call(2));</span><br><span class=\"line\">console.log(a.call(true));</span><br><span class=\"line\">console.log(a.call(&apos;str&apos;));</span><br><span class=\"line\">console.log(a.call([]));</span><br><span class=\"line\">console.log(a.call(function()&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(undefined));</span><br><span class=\"line\">console.log(a.call(null));</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"介绍-JS-有哪些内置对象？\"><a href=\"#介绍-JS-有哪些内置对象？\" class=\"headerlink\" title=\"介绍 JS 有哪些内置对象？\"></a>介绍 JS 有哪些内置对象？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class=\"line\">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class=\"line\"></span><br><span class=\"line\">标准内置对象的分类</span><br><span class=\"line\"></span><br><span class=\"line\">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Infinity、NaN、undefined、null 字面量</span><br><span class=\"line\"></span><br><span class=\"line\">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 eval()、parseFloat()、parseInt() 等</span><br><span class=\"line\"></span><br><span class=\"line\">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class=\"line\"></span><br><span class=\"line\">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Number、Math、Date</span><br><span class=\"line\"></span><br><span class=\"line\">（5）字符串，用来表示和操作字符串的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 String、RegExp</span><br><span class=\"line\"></span><br><span class=\"line\">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class=\"line\"></span><br><span class=\"line\">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Map、Set、WeakMap、WeakSet</span><br><span class=\"line\"></span><br><span class=\"line\">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 SIMD 等</span><br><span class=\"line\"></span><br><span class=\"line\">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 JSON 等</span><br><span class=\"line\"></span><br><span class=\"line\">（10）控制抽象对象</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Promise、Generator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（11）反射</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Reflect、Proxy</span><br><span class=\"line\"></span><br><span class=\"line\">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Intl、Intl.Collator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（13）WebAssembly</span><br><span class=\"line\"></span><br><span class=\"line\">（14）其他</span><br><span class=\"line\"></span><br><span class=\"line\">例如 arguments</span><br></pre></td></tr></table></figure>\n<h3 id=\"undefined-与-undeclared-的区别？\"><a href=\"#undefined-与-undeclared-的区别？\" class=\"headerlink\" title=\"undefined 与 undeclared 的区别？\"></a>undefined 与 undeclared 的区别？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。</span><br><span class=\"line\">对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ</span><br><span class=\"line\">eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</span><br></pre></td></tr></table></figure>\n<h3 id=\"null-和-undefined-的区别？\"><a href=\"#null-和-undefined-的区别？\" class=\"headerlink\" title=\"null 和 undefined 的区别？\"></a>null 和 undefined 的区别？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class=\"line\">undefined 代表的含义是未定义，</span><br><span class=\"line\">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class=\"line\">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class=\"line\">/*</span><br><span class=\"line\">    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，</span><br><span class=\"line\">    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class=\"line\">    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</span><br><span class=\"line\">*/</span><br><span class=\"line\">undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它</span><br><span class=\"line\">会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</span><br><span class=\"line\">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等</span><br><span class=\"line\">号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>\n<h3 id=\"和-的valueOf和toString的结果是什么？\"><a href=\"#和-的valueOf和toString的结果是什么？\" class=\"headerlink\" title=\"{}和[]的valueOf和toString的结果是什么？\"></a>{}和[]的valueOf和toString的结果是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Javascript-的作用域和作用域链？\"><a href=\"#Javascript-的作用域和作用域链？\" class=\"headerlink\" title=\"Javascript 的作用域和作用域链？\"></a>Javascript 的作用域和作用域链？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class=\"line\">【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</span><br></pre></td></tr></table></figure>\n<h3 id=\"javascript-创建对象的几种方式？\"><a href=\"#javascript-创建对象的几种方式？\" class=\"headerlink\" title=\"javascript 创建对象的几种方式？\"></a>javascript 创建对象的几种方式？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript-继承的几种实现方式？\"><a href=\"#JavaScript-继承的几种实现方式？\" class=\"headerlink\" title=\"JavaScript 继承的几种实现方式？\"></a>JavaScript 继承的几种实现方式？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生式组合继承的实现？\"><a href=\"#寄生式组合继承的实现？\" class=\"headerlink\" title=\"寄生式组合继承的实现？\"></a>寄生式组合继承的实现？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person</span><br><span class=\"line\">Student</span><br><span class=\"line\"></span><br><span class=\"line\">function Person(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Student(name, grade)&#123;</span><br><span class=\"line\">    Person.call(this,name);</span><br><span class=\"line\">    this.grade = grade;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype = Object.create(Person.prototype);</span><br><span class=\"line\">Student.prototype.constructor = Student;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.sayMyGrade = function() &#123;</span><br><span class=\"line\">  console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"谈谈你对this、call、apply和bind的理解\"><a href=\"#谈谈你对this、call、apply和bind的理解\" class=\"headerlink\" title=\"谈谈你对this、call、apply和bind的理解\"></a>谈谈你对this、call、apply和bind的理解</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结:</span><br><span class=\"line\">1. 在浏览器里，在全局范围内this 指向window对象；</span><br><span class=\"line\">2. 在函数中，this永远指向最后调用他的那个对象；</span><br><span class=\"line\">3. 构造函数中，this指向new出来的那个新的对象；</span><br><span class=\"line\">4. call、apply、bind中的this被强绑定在指定的那个对象上；</span><br><span class=\"line\">5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</span><br><span class=\"line\">6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</span><br><span class=\"line\"></span><br><span class=\"line\">区别:</span><br><span class=\"line\">- call/apply改变了函数的this上下文后马上执行该函数</span><br><span class=\"line\">- bind则是返回改变了上下文后的函数,不执行该函数</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript-原型，原型链？-有什么特点？\"><a href=\"#JavaScript-原型，原型链？-有什么特点？\" class=\"headerlink\" title=\"JavaScript 原型，原型链？ 有什么特点？\"></a>JavaScript 原型，原型链？ 有什么特点？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">prototype就是JS的原型，里面可以定义属性和方法</span><br><span class=\"line\">当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。</span><br><span class=\"line\">原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br></pre></td></tr></table></figure>\n<h3 id=\"js-获取原型的方法？\"><a href=\"#js-获取原型的方法？\" class=\"headerlink\" title=\"js 获取原型的方法？\"></a>js 获取原型的方法？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p.proto</span><br><span class=\"line\">p.constructor.prototype</span><br><span class=\"line\">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是闭包，为什么要用它？\"><a href=\"#什么是闭包，为什么要用它？\" class=\"headerlink\" title=\"什么是闭包，为什么要用它？\"></a>什么是闭包，为什么要用它？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">闭包是指有权访问另一个函数作用域内变量的函数</span><br><span class=\"line\">创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。</span><br><span class=\"line\"></span><br><span class=\"line\">闭包有两个常用的用途:</span><br><span class=\"line\">- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class=\"line\">- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</span><br><span class=\"line\"></span><br><span class=\"line\">function a()&#123;</span><br><span class=\"line\">    var n = 0;</span><br><span class=\"line\">    function add()&#123;</span><br><span class=\"line\">       n++;</span><br><span class=\"line\">       console.log(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span><br><span class=\"line\">a1();    //1</span><br><span class=\"line\">a1();    //2  第二次调用n变量还在内存中</span><br><span class=\"line\"></span><br><span class=\"line\">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是-DOM-和-BOM？\"><a href=\"#什么是-DOM-和-BOM？\" class=\"headerlink\" title=\"什么是 DOM 和 BOM？\"></a>什么是 DOM 和 BOM？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class=\"line\"></span><br><span class=\"line\">BOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM</span><br><span class=\"line\">的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）</span><br><span class=\"line\">对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati</span><br><span class=\"line\">on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对</span><br><span class=\"line\">象的子对象。</span><br></pre></td></tr></table></figure>\n<h3 id=\"三种事件模型是什么？\"><a href=\"#三种事件模型是什么？\" class=\"headerlink\" title=\"三种事件模型是什么？\"></a>三种事件模型是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class=\"line\">IE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class=\"line\">DOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件委托是什么？\"><a href=\"#事件委托是什么？\" class=\"headerlink\" title=\"事件委托是什么？\"></a>事件委托是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class=\"line\">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class=\"line\">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件传播\"><a href=\"#什么是事件传播\" class=\"headerlink\" title=\"什么是事件传播?\"></a>什么是事件传播?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。</span><br><span class=\"line\">事件传播有三个阶段：</span><br><span class=\"line\">1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class=\"line\">2. 目标阶段–事件已达到目标元素。</span><br><span class=\"line\">3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件捕获？\"><a href=\"#什么是事件捕获？\" class=\"headerlink\" title=\"什么是事件捕获？\"></a>什么是事件捕获？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----&gt; document----&gt; html----&gt; body ----&gt;目标元素</span><br><span class=\"line\"></span><br><span class=\"line\">html:</span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">js:</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件冒泡？\"><a href=\"#什么是事件冒泡？\" class=\"headerlink\" title=\"什么是事件冒泡？\"></a>什么是事件冒泡？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br><span class=\"line\">假设有如下的 HTML 结构：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">对应的JS代码：</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\"><a href=\"#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\" class=\"headerlink\" title=\"DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><p>（1）创建新节点<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">createDocumentFragment()    //创建一个DOM片段</span><br><span class=\"line\">createElement()   //创建一个具体的元素</span><br><span class=\"line\">createTextNode()   //创建一个文本节点</span><br></pre></td></tr></table></figure></p>\n<p>（2）添加、移除、替换、插入<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendChild(node)</span><br><span class=\"line\">removeChild(node)</span><br><span class=\"line\">replaceChild(new,old)</span><br><span class=\"line\">insertBefore(new,old)</span><br></pre></td></tr></table></figure></p>\n<p>（3）查找<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getElementById();</span><br><span class=\"line\">getElementsByName();</span><br><span class=\"line\">getElementsByTagName();</span><br><span class=\"line\">getElementsByClassName();</span><br><span class=\"line\">querySelector();</span><br><span class=\"line\">querySelectorAll();</span><br></pre></td></tr></table></figure></p>\n<p>（4）属性操作<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getAttribute(key);</span><br><span class=\"line\">setAttribute(key, value);</span><br><span class=\"line\">hasAttribute(key);</span><br><span class=\"line\">removeAttribute(key);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"js数组和对象有哪些原生方法-列举一下\"><a href=\"#js数组和对象有哪些原生方法-列举一下\" class=\"headerlink\" title=\"js数组和对象有哪些原生方法,列举一下\"></a>js数组和对象有哪些原生方法,列举一下</h3><p><img src=\"https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h3><h3 id=\"Ajax-是什么-如何创建一个-Ajax？\"><a href=\"#Ajax-是什么-如何创建一个-Ajax？\" class=\"headerlink\" title=\"Ajax 是什么? 如何创建一个 Ajax？\"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。<br>创建步骤：<br><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/17274125a4cf4d61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//1：创建Ajax对象</span><br><span class=\"line\">var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);    //兼容IE6及以下版本</span><br><span class=\"line\">//2：配置 Ajax请求地址</span><br><span class=\"line\">xhr.open(&apos;get&apos;,&apos;index.xml&apos;,true);</span><br><span class=\"line\">//3：发送请求</span><br><span class=\"line\">xhr.send(null); //严谨写法</span><br><span class=\"line\">//4:监听请求，接受响应</span><br><span class=\"line\">xhr.onreadysatechange = function()&#123;</span><br><span class=\"line\">    if(xhr.readySates == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304)&#123;</span><br><span class=\"line\">        console.log(xhr.responsetXML);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>promise封装实现<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// promise 封装实现：</span><br><span class=\"line\"></span><br><span class=\"line\">function getJSON(url) &#123;</span><br><span class=\"line\">  // 创建一个 promise 对象</span><br><span class=\"line\">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    let xhr = new XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 新建一个 http 请求</span><br><span class=\"line\">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置状态的监听函数</span><br><span class=\"line\">    xhr.onreadystatechange = function() &#123;</span><br><span class=\"line\">      if (this.readyState !== 4) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class=\"line\">      if (this.status === 200) &#123;</span><br><span class=\"line\">        resolve(this.response);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        reject(new Error(this.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置错误监听函数</span><br><span class=\"line\">    xhr.onerror = function() &#123;</span><br><span class=\"line\">      reject(new Error(this.statusText));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置响应的数据类型</span><br><span class=\"line\">    xhr.responseType = &quot;json&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置请求头信息</span><br><span class=\"line\">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 发送 http 请求</span><br><span class=\"line\">    xhr.send(null);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return promise;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"js-延迟加载的方式有哪些？\"><a href=\"#js-延迟加载的方式有哪些？\" class=\"headerlink\" title=\"js 延迟加载的方式有哪些？\"></a>js 延迟加载的方式有哪些？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class=\"line\">我了解到的几种方式是：</span><br><span class=\"line\"></span><br><span class=\"line\">将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class=\"line\">给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class=\"line\">给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class=\"line\">动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure>\n<h3 id=\"谈谈你对模块化开发的理解？\"><a href=\"#谈谈你对模块化开发的理解？\" class=\"headerlink\" title=\"谈谈你对模块化开发的理解？\"></a>谈谈你对模块化开发的理解？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念</span><br><span class=\"line\">，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class=\"line\">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污</span><br><span class=\"line\">染，并且模块间没有联系。</span><br><span class=\"line\">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所</span><br><span class=\"line\">有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class=\"line\">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure>\n<h3 id=\"js-的几种模块规范？\"><a href=\"#js-的几种模块规范？\" class=\"headerlink\" title=\"js 的几种模块规范？\"></a>js 的几种模块规范？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">js 中现在比较成熟的有四种模块加载方案：</span><br><span class=\"line\"></span><br><span class=\"line\">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class=\"line\">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class=\"line\">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class=\"line\">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</span><br></pre></td></tr></table></figure>\n<h3 id=\"AMD和CMD-规范的区别？\"><a href=\"#AMD和CMD-规范的区别？\" class=\"headerlink\" title=\"AMD和CMD 规范的区别？\"></a>AMD和CMD 规范的区别？</h3><p>它们之间的主要区别有两个方面。</p>\n<ol>\n<li>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</li>\n<li>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br> 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br> 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br> 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">  var a = require(&quot;./a&quot;);</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 此处略去 100 行</span><br><span class=\"line\">  var b = require(&quot;./b&quot;); // 依赖可以就近书写</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) &#123;</span><br><span class=\"line\">  // 依赖必须一开始就写好</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 此处略去 100 行</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\"><a href=\"#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\" class=\"headerlink\" title=\"ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><ul>\n<li>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>\n<li>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>\n</ul>\n<h3 id=\"requireJS的核心原理是什么？\"><a href=\"#requireJS的核心原理是什么？\" class=\"headerlink\" title=\"requireJS的核心原理是什么？\"></a>requireJS的核心原理是什么？</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p>\n<h3 id=\"谈谈JS的运行机制\"><a href=\"#谈谈JS的运行机制\" class=\"headerlink\" title=\"谈谈JS的运行机制\"></a>谈谈JS的运行机制</h3><ol>\n<li><p>js单线程<br>JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。</p>\n<blockquote>\n<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>\n</blockquote>\n</li>\n<li><p>js事件循环<br>js代码执行过程中会有很多任务，这些任务总的分成两类：</p>\n</li>\n</ol>\n<ul>\n<li>同步任务</li>\n<li>异步任务<br>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：<br><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/172744a7fa2853c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></li>\n</ul>\n<p>回答：</p>\n<ol>\n<li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li>\n<li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li>\n<li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li>\n<li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li>\n<li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li>\n</ol>\n<h3 id=\"arguments-的对象是什么？\"><a href=\"#arguments-的对象是什么？\" class=\"headerlink\" title=\"arguments 的对象是什么？\"></a>arguments 的对象是什么？</h3><p>arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。<br>我们可以使用Array.prototype.slice将arguments对象转换成一个数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function one() &#123;</span><br><span class=\"line\">  return Array.prototype.slice.call(arguments);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意:箭头函数中没有arguments对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function one() &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const two = function () &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const three = function three() &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const four = () =&gt; arguments;</span><br><span class=\"line\"></span><br><span class=\"line\">four(); // Throws an error  - arguments is not defined</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为什么在调用这个函数时，代码中的b会变成一个全局变量\"><a href=\"#为什么在调用这个函数时，代码中的b会变成一个全局变量\" class=\"headerlink\" title=\"为什么在调用这个函数时，代码中的b会变成一个全局变量?\"></a>为什么在调用这个函数时，代码中的b会变成一个全局变量?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a = b = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure>\n<p>原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a = (b = 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure></p>\n<p>首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。</p>\n<p>我们可以通过在赋值之前先声明变量来解决这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a,b;</span><br><span class=\"line\">  a = b = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"简单介绍一下V8引擎的垃圾回收机制\"><a href=\"#简单介绍一下V8引擎的垃圾回收机制\" class=\"headerlink\" title=\"简单介绍一下V8引擎的垃圾回收机制\"></a>简单介绍一下V8引擎的垃圾回收机制</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class=\"line\"></span><br><span class=\"line\">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class=\"line\"></span><br><span class=\"line\">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）如果对象不存活，则释放对象的空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class=\"line\"></span><br><span class=\"line\">新生代对象晋升到老生代有两个条件：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class=\"line\"></span><br><span class=\"line\">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"哪些操作会造成内存泄漏？\"><a href=\"#哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"哪些操作会造成内存泄漏？\"></a>哪些操作会造成内存泄漏？</h3><ul>\n<li>1.意外的全局变量</li>\n<li>2.被遗忘的计时器或回调函数</li>\n<li>3.脱离 DOM 的引用</li>\n<li><p>4.闭包</p>\n</li>\n<li><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p>\n</li>\n<li>第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>\n<li>第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>\n<li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>\n</ul>\n<h3 id=\"ECMAScript-是什么？\"><a href=\"#ECMAScript-是什么？\" class=\"headerlink\" title=\"ECMAScript 是什么？\"></a>ECMAScript 是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。</span><br><span class=\"line\">ECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件</span><br><span class=\"line\">只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。</span><br><span class=\"line\">javaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）</span><br><span class=\"line\">ECMAScript说什么JavaScript就得做什么！</span><br><span class=\"line\">JavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！</span><br><span class=\"line\">——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，</span><br><span class=\"line\">那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。</span><br></pre></td></tr></table></figure>\n<h3 id=\"ECMAScript-2015（ES6）有哪些新特性？\"><a href=\"#ECMAScript-2015（ES6）有哪些新特性？\" class=\"headerlink\" title=\"ECMAScript 2015（ES6）有哪些新特性？\"></a>ECMAScript 2015（ES6）有哪些新特性？</h3><ul>\n<li>块作用域</li>\n<li>类</li>\n<li>箭头函数</li>\n<li>模板字符串</li>\n<li>加强的对象字面</li>\n<li>对象解构</li>\n<li>Promise</li>\n<li>模块</li>\n<li>Symbol</li>\n<li>代理（proxy）Set</li>\n<li>函数默认参数</li>\n<li>rest 和展开</li>\n</ul>\n<h3 id=\"var-let和const的区别是什么？\"><a href=\"#var-let和const的区别是什么？\" class=\"headerlink\" title=\"var,let和const的区别是什么？\"></a>var,let和const的区别是什么？</h3><p>var声明的变量会挂载在window上，而let和const声明的变量不会：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\">console.log(a,window.a);    // 100 100</span><br><span class=\"line\"></span><br><span class=\"line\">let b = 10;</span><br><span class=\"line\">console.log(b,window.b);    // 10 undefined</span><br><span class=\"line\"></span><br><span class=\"line\">const c = 1;</span><br><span class=\"line\">console.log(c,window.c);    // 1 undefined</span><br></pre></td></tr></table></figure></p>\n<p>var声明变量存在变量提升，let和const不存在变量提升:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(a); // undefined  ===&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class=\"line\">var a = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b); // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class=\"line\">let b = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(c); // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br><span class=\"line\">const c = 10;</span><br></pre></td></tr></table></figure></p>\n<p>let和const声明形成块作用域<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">  var a = 100;</span><br><span class=\"line\">  let b = 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\">console.log(b)  // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class=\"line\"></span><br><span class=\"line\">-------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">  var a = 100;</span><br><span class=\"line\">  const c = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\">console.log(c)  // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br></pre></td></tr></table></figure></p>\n<p>同一作用域下let和const不能声明同名变量，而var可以<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\"></span><br><span class=\"line\">var a = 10;</span><br><span class=\"line\">console.log(a); // 10</span><br><span class=\"line\">-------------------------------------</span><br><span class=\"line\">let a = 100;</span><br><span class=\"line\">let a = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">//  控制台报错：Identifier &apos;a&apos; has already been declared  ===&gt; 标识符a已经被声明了。</span><br></pre></td></tr></table></figure></p>\n<p>暂存死区<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">    a = 10;</span><br><span class=\"line\">    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class=\"line\">    // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class=\"line\">    let a = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>const<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;1、一旦声明必须赋值,不能使用null占位。</span><br><span class=\"line\">*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;2、声明后不能再修改</span><br><span class=\"line\">*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;3、如果声明的是复合类型数据，可以修改其属性</span><br><span class=\"line\">*</span><br><span class=\"line\">* */</span><br><span class=\"line\"></span><br><span class=\"line\">const a = 100; </span><br><span class=\"line\"></span><br><span class=\"line\">const list = [];</span><br><span class=\"line\">list[0] = 10;</span><br><span class=\"line\">console.log(list);&amp;emsp;&amp;emsp;// [10]</span><br><span class=\"line\"></span><br><span class=\"line\">const obj = &#123;a:100&#125;;</span><br><span class=\"line\">obj.name = &apos;apple&apos;;</span><br><span class=\"line\">obj.a = 10000;</span><br><span class=\"line\">console.log(obj);&amp;emsp;&amp;emsp;// &#123;a:10000,name:&apos;apple&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是箭头函数？\"><a href=\"#什么是箭头函数？\" class=\"headerlink\" title=\"什么是箭头函数？\"></a>什么是箭头函数？</h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var getCurrentDate = function ()&#123;</span><br><span class=\"line\">  return new Date();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">const getCurrentDate = () =&gt; new Date();</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">const greet = (name) =&gt; `Hello $&#123;name&#125;`;</span><br><span class=\"line\">const greet2 = name =&gt; `Hello $&#123;name&#125;`;</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const getArgs = () =&gt; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">const getArgs2 = (...rest) =&gt; rest</span><br></pre></td></tr></table></figure></p>\n<p>箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const data = &#123;</span><br><span class=\"line\">  result: 0,</span><br><span class=\"line\">  nums: [1, 2, 3, 4, 5],</span><br><span class=\"line\">  computeResult() &#123;</span><br><span class=\"line\">    // 这里的“this”指的是“data”对象</span><br><span class=\"line\">    const addAll = () =&gt; &#123;</span><br><span class=\"line\">      return this.nums.reduce((total, cur) =&gt; total + cur, 0)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.result = addAll();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。</p>\n<h3 id=\"什么是类？\"><a href=\"#什么是类？\" class=\"headerlink\" title=\"什么是类？\"></a>什么是类？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是模板字符串？\"><a href=\"#什么是模板字符串？\" class=\"headerlink\" title=\"什么是模板字符串？\"></a>什么是模板字符串？</h3><p>模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var greet = &apos;Hi I\\&apos;m Mark&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">let greet = `Hi I&apos;m Mark`;</span><br></pre></td></tr></table></figure></p>\n<p>在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var lastWords = &apos;\\n&apos;</span><br><span class=\"line\">  + &apos;   I  \\n&apos;</span><br><span class=\"line\">  + &apos;   Am  \\n&apos;</span><br><span class=\"line\">  + &apos;Iron Man \\n&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">let lastWords = `</span><br><span class=\"line\">    I</span><br><span class=\"line\">    Am</span><br><span class=\"line\">  Iron Man   </span><br><span class=\"line\">`;</span><br></pre></td></tr></table></figure></p>\n<p>在ES5版本中，我们需要添加\\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return `Hello $&#123;name&#125; !`;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。</p>\n<h3 id=\"什么是对象解构？\"><a href=\"#什么是对象解构？\" class=\"headerlink\" title=\"什么是对象解构？\"></a>什么是对象解构？</h3><p>对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const employee = &#123;</span><br><span class=\"line\">  firstName: &quot;Marko&quot;,</span><br><span class=\"line\">  lastName: &quot;Polo&quot;,</span><br><span class=\"line\">  position: &quot;Software Developer&quot;,</span><br><span class=\"line\">  yearHired: 2017</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var firstName = employee.firstName;</span><br><span class=\"line\">var lastName = employee.lastName;</span><br><span class=\"line\">var position = employee.position;</span><br><span class=\"line\">var yearHired = employee.yearHired;</span><br></pre></td></tr></table></figure></p>\n<p>使用解构方式语法就变得简洁多了：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; firstName, lastName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以为属性取别名：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let &#123; firstName: fName, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<p>当然如果属性值为 undefined 时，我们还可以指定默认值，但是属性为null时指定的默认值则不生效：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let &#123; firstName = &quot;Mark&quot;, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Set对象，它是如何工作的？\"><a href=\"#什么是Set对象，它是如何工作的？\" class=\"headerlink\" title=\"什么是Set对象，它是如何工作的？\"></a>什么是Set对象，它是如何工作的？</h3><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>\n<p>我们可以使用Set构造函数创建Set实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const set1 = new Set();</span><br><span class=\"line\">const set2 = new Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;e&quot;]);</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.add(&quot;f&quot;);</span><br><span class=\"line\">set2.add(&quot;g&quot;).add(&quot;h&quot;).add(&quot;i&quot;).add(&quot;j&quot;).add(&quot;k&quot;).add(&quot;k&quot;);</span><br><span class=\"line\">// 后一个“k”不会被添加到set对象中，因为它已经存在了</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用has方法检查Set实例中是否存在特定的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.has(&quot;a&quot;) // true</span><br><span class=\"line\">set2.has(&quot;z&quot;) // true</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用size属性获得Set实例的长度。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.size // returns 10</span><br></pre></td></tr></table></figure></p>\n<p>可以使用clear方法删除 Set 中的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.clear();</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用Set对象来删除数组中重复的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];</span><br><span class=\"line\">const uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></p>\n<p>另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。</p>\n<ul>\n<li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>\n<li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>\n</ul>\n<h3 id=\"什么是Proxy？\"><a href=\"#什么是Proxy？\" class=\"headerlink\" title=\"什么是Proxy？\"></a>什么是Proxy？</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n<h3 id=\"写一个通用的事件侦听器函数？\"><a href=\"#写一个通用的事件侦听器函数？\" class=\"headerlink\" title=\"写一个通用的事件侦听器函数？\"></a>写一个通用的事件侦听器函数？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const EventUtils = &#123;</span><br><span class=\"line\">  // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class=\"line\">  // 添加事件</span><br><span class=\"line\">  addEvent: function(element, type, handler) &#123;</span><br><span class=\"line\">    if (element.addEventListener) &#123;</span><br><span class=\"line\">      element.addEventListener(type, handler, false);</span><br><span class=\"line\">    &#125; else if (element.attachEvent) &#123;</span><br><span class=\"line\">      element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      element[&quot;on&quot; + type] = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 移除事件</span><br><span class=\"line\">  removeEvent: function(element, type, handler) &#123;</span><br><span class=\"line\">    if (element.removeEventListener) &#123;</span><br><span class=\"line\">      element.removeEventListener(type, handler, false);</span><br><span class=\"line\">    &#125; else if (element.detachEvent) &#123;</span><br><span class=\"line\">      element.detachEvent(&quot;on&quot; + type, handler);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      element[&quot;on&quot; + type] = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取事件目标</span><br><span class=\"line\">  getTarget: function(event) &#123;</span><br><span class=\"line\">    return event.target || event.srcElement;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span><br><span class=\"line\">  getEvent: function(event) &#123;</span><br><span class=\"line\">    return event || window.event;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span><br><span class=\"line\">  stopPropagation: function(event) &#123;</span><br><span class=\"line\">    if (event.stopPropagation) &#123;</span><br><span class=\"line\">      event.stopPropagation();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      event.cancelBubble = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 取消事件的默认行为</span><br><span class=\"line\">  preventDefault: function(event) &#123;</span><br><span class=\"line\">    if (event.preventDefault) &#123;</span><br><span class=\"line\">      event.preventDefault();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      event.returnValue = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\"><a href=\"#什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\" class=\"headerlink\" title=\"什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\"></a>什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</span><br><span class=\"line\">函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。</span><br><span class=\"line\">函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是高阶函数？\"><a href=\"#什么是高阶函数？\" class=\"headerlink\" title=\"什么是高阶函数？\"></a>什么是高阶函数？</h3><p>高阶函数只是将函数作为参数或返回值的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function higherOrderFunction(param,callback)&#123;</span><br><span class=\"line\">    return callback(param);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为什么函数被称为一等公民？\"><a href=\"#为什么函数被称为一等公民？\" class=\"headerlink\" title=\"为什么函数被称为一等公民？\"></a>为什么函数被称为一等公民？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:</span><br><span class=\"line\"></span><br><span class=\"line\">赋值（var func = function()&#123;&#125;）、</span><br><span class=\"line\">传参(function func(x,callback)&#123;callback();&#125;)、</span><br><span class=\"line\">返回(function()&#123;return function()&#123;&#125;&#125;)，</span><br><span class=\"line\"></span><br><span class=\"line\">这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-map-方法\"><a href=\"#手动实现Array-prototype-map-方法\" class=\"headerlink\" title=\"手动实现Array.prototype.map 方法\"></a>手动实现Array.prototype.map 方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</span><br><span class=\"line\">function map(arr, mapCallback) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== &apos;function&apos;) &#123; </span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let result = [];</span><br><span class=\"line\">    // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class=\"line\">    // 因为我们不想改变原始数组。</span><br><span class=\"line\">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      result.push(mapCallback(arr[i], i, arr)); </span><br><span class=\"line\">      // 将 mapCallback 返回的结果 push 到 result 数组中</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-filter方法\"><a href=\"#手动实现Array-prototype-filter方法\" class=\"headerlink\" title=\"手动实现Array.prototype.filter方法\"></a>手动实现Array.prototype.filter方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</span><br><span class=\"line\">function filter(arr, filterCallback) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== &apos;function&apos;) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let result = [];</span><br><span class=\"line\">     // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class=\"line\">     // 因为我们不想改变原始数组。</span><br><span class=\"line\">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      // 检查 filterCallback 的返回值是否是真值</span><br><span class=\"line\">      if (filterCallback(arr[i], i, arr)) &#123; </span><br><span class=\"line\">      // 如果条件为真，则将数组元素 push 到 result 中</span><br><span class=\"line\">        result.push(arr[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result; // return the result array</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-reduce方法\"><a href=\"#手动实现Array-prototype-reduce方法\" class=\"headerlink\" title=\"手动实现Array.prototype.reduce方法\"></a>手动实现Array.prototype.reduce方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。</span><br><span class=\"line\"></span><br><span class=\"line\">function reduce(arr, reduceCallback, initialValue) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== &apos;function&apos;) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span><br><span class=\"line\">    let hasInitialValue = initialValue !== undefined;</span><br><span class=\"line\">    let value = hasInitialValue ? initialValue : arr[0];</span><br><span class=\"line\">   、</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span><br><span class=\"line\">    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      value = reduceCallback(value, arr[i], i, arr); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"js的深浅拷贝\"><a href=\"#js的深浅拷贝\" class=\"headerlink\" title=\"js的深浅拷贝\"></a>js的深浅拷贝</h3><blockquote>\n<p>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。</p>\n<ul>\n<li>浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>\n<li>深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。<br>浅拷贝的实现方式：</li>\n<li>Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>\n<li>Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li>\n<li>拓展运算符…：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">    name: &quot;Jake&quot;,</span><br><span class=\"line\">    flag: &#123;</span><br><span class=\"line\">        title: &quot;better day by day&quot;,</span><br><span class=\"line\">        time: &quot;2020-05-31&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = &#123;...a&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>深拷贝的实现方式：</p>\n<ul>\n<li>乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）</li>\n<li>基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function cloneDeep(target,map = new WeakMap()) &#123;</span><br><span class=\"line\">  if(typeOf taret ===&apos;object&apos;)&#123;</span><br><span class=\"line\">     let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class=\"line\">      </span><br><span class=\"line\">     if(map.get(target)) &#123;</span><br><span class=\"line\">        return target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     map.set(target, cloneTarget);</span><br><span class=\"line\">     for(const key in target)&#123;</span><br><span class=\"line\">        cloneTarget[key] = cloneDeep(target[key], map);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return cloneTarget</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">       return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>终极版：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const mapTag = &apos;[object Map]&apos;;</span><br><span class=\"line\">const setTag = &apos;[object Set]&apos;;</span><br><span class=\"line\">const arrayTag = &apos;[object Array]&apos;;</span><br><span class=\"line\">const objectTag = &apos;[object Object]&apos;;</span><br><span class=\"line\">const argsTag = &apos;[object Arguments]&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const boolTag = &apos;[object Boolean]&apos;;</span><br><span class=\"line\">const dateTag = &apos;[object Date]&apos;;</span><br><span class=\"line\">const numberTag = &apos;[object Number]&apos;;</span><br><span class=\"line\">const stringTag = &apos;[object String]&apos;;</span><br><span class=\"line\">const symbolTag = &apos;[object Symbol]&apos;;</span><br><span class=\"line\">const errorTag = &apos;[object Error]&apos;;</span><br><span class=\"line\">const regexpTag = &apos;[object RegExp]&apos;;</span><br><span class=\"line\">const funcTag = &apos;[object Function]&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function forEach(array, iteratee) &#123;</span><br><span class=\"line\">    let index = -1;</span><br><span class=\"line\">    const length = array.length;</span><br><span class=\"line\">    while (++index &lt; length) &#123;</span><br><span class=\"line\">        iteratee(array[index], index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function isObject(target) &#123;</span><br><span class=\"line\">    const type = typeof target;</span><br><span class=\"line\">    return target !== null &amp;&amp; (type === &apos;object&apos; || type === &apos;function&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getType(target) &#123;</span><br><span class=\"line\">    return Object.prototype.toString.call(target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getInit(target) &#123;</span><br><span class=\"line\">    const Ctor = target.constructor;</span><br><span class=\"line\">    return new Ctor();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneSymbol(targe) &#123;</span><br><span class=\"line\">    return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneReg(targe) &#123;</span><br><span class=\"line\">    const reFlags = /\\w*$/;</span><br><span class=\"line\">    const result = new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class=\"line\">    result.lastIndex = targe.lastIndex;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneFunction(func) &#123;</span><br><span class=\"line\">    const bodyReg = /(?&lt;=&#123;)(.|\\n)+(?=&#125;)/m;</span><br><span class=\"line\">    const paramReg = /(?&lt;=\\().+(?=\\)\\s+&#123;)/;</span><br><span class=\"line\">    const funcString = func.toString();</span><br><span class=\"line\">    if (func.prototype) &#123;</span><br><span class=\"line\">        const param = paramReg.exec(funcString);</span><br><span class=\"line\">        const body = bodyReg.exec(funcString);</span><br><span class=\"line\">        if (body) &#123;</span><br><span class=\"line\">            if (param) &#123;</span><br><span class=\"line\">                const paramArr = param[0].split(&apos;,&apos;);</span><br><span class=\"line\">                return new Function(...paramArr, body[0]);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                return new Function(body[0]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return eval(funcString);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneOtherType(targe, type) &#123;</span><br><span class=\"line\">    const Ctor = targe.constructor;</span><br><span class=\"line\">    switch (type) &#123;</span><br><span class=\"line\">        case boolTag:</span><br><span class=\"line\">        case numberTag:</span><br><span class=\"line\">        case stringTag:</span><br><span class=\"line\">        case errorTag:</span><br><span class=\"line\">        case dateTag:</span><br><span class=\"line\">            return new Ctor(targe);</span><br><span class=\"line\">        case regexpTag:</span><br><span class=\"line\">            return cloneReg(targe);</span><br><span class=\"line\">        case symbolTag:</span><br><span class=\"line\">            return cloneSymbol(targe);</span><br><span class=\"line\">        case funcTag:</span><br><span class=\"line\">            return cloneFunction(targe);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function clone(target, map = new WeakMap()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆原始类型</span><br><span class=\"line\">    if (!isObject(target)) &#123;</span><br><span class=\"line\">        return target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化</span><br><span class=\"line\">    const type = getType(target);</span><br><span class=\"line\">    let cloneTarget;</span><br><span class=\"line\">    if (deepTag.includes(type)) &#123;</span><br><span class=\"line\">        cloneTarget = getInit(target, type);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return cloneOtherType(target, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 防止循环引用</span><br><span class=\"line\">    if (map.get(target)) &#123;</span><br><span class=\"line\">        return map.get(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map.set(target, cloneTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆set</span><br><span class=\"line\">    if (type === setTag) &#123;</span><br><span class=\"line\">        target.forEach(value =&gt; &#123;</span><br><span class=\"line\">            cloneTarget.add(clone(value, map));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return cloneTarget;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆map</span><br><span class=\"line\">    if (type === mapTag) &#123;</span><br><span class=\"line\">        target.forEach((value, key) =&gt; &#123;</span><br><span class=\"line\">            cloneTarget.set(key, clone(value, map));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return cloneTarget;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆对象和数组</span><br><span class=\"line\">    const keys = type === arrayTag ? undefined : Object.keys(target);</span><br><span class=\"line\">    forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class=\"line\">        if (keys) &#123;</span><br><span class=\"line\">            key = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cloneTarget[key] = clone(target[key], map);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return cloneTarget;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    clone</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"手写call、apply及bind函数\"><a href=\"#手写call、apply及bind函数\" class=\"headerlink\" title=\"手写call、apply及bind函数\"></a>手写call、apply及bind函数</h3><p>call 函数的实现步骤：</p>\n<ul>\n<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>3.处理传入的参数，截取第一个参数后的所有参数。</li>\n<li>4.将函数作为上下文对象的一个属性。</li>\n<li>5.使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>6.删除刚才新增的属性。</li>\n<li>7.返回结果。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// call函数实现</span><br><span class=\"line\">Function.prototype.myCall = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    console.error(&quot;type error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取参数</span><br><span class=\"line\">  let args = [...arguments].slice(1),</span><br><span class=\"line\">    result = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 判断 context 是否传入，如果未传入则设置为 window</span><br><span class=\"line\">  context = context || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将调用函数设为对象的方法</span><br><span class=\"line\">  context.fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用函数</span><br><span class=\"line\">  result = context.fn(...args);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将属性删除</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>apply 函数的实现步骤：</p>\n<ul>\n<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>将函数作为上下文对象的一个属性。</li>\n<li>判断参数值是否传入</li>\n<li>使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>删除刚才新增的属性</li>\n<li>返回结果<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// apply 函数实现</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.myApply = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象是否为函数</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    throw new TypeError(&quot;Error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  let result = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 判断 context 是否存在，如果未传入则为 window</span><br><span class=\"line\">  context = context || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将函数设为对象的方法</span><br><span class=\"line\">  context.fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用方法</span><br><span class=\"line\">  if (arguments[1]) &#123;</span><br><span class=\"line\">    result = context.fn(...arguments[1]);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    result = context.fn();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将属性删除</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"函数柯里化的实现\"><a href=\"#函数柯里化的实现\" class=\"headerlink\" title=\"函数柯里化的实现\"></a>函数柯里化的实现</h3><h3 id=\"js模拟new操作符的实现\"><a href=\"#js模拟new操作符的实现\" class=\"headerlink\" title=\"js模拟new操作符的实现\"></a>js模拟new操作符的实现</h3><h3 id=\"什么是回调函数？回调函数有什么缺点\"><a href=\"#什么是回调函数？回调函数有什么缺点\" class=\"headerlink\" title=\"什么是回调函数？回调函数有什么缺点\"></a>什么是回调函数？回调函数有什么缺点</h3><h3 id=\"Promise是什么，可以手写实现一下吗？\"><a href=\"#Promise是什么，可以手写实现一下吗？\" class=\"headerlink\" title=\"Promise是什么，可以手写实现一下吗？\"></a>Promise是什么，可以手写实现一下吗？</h3><h3 id=\"Iterator是什么，有什么作用？\"><a href=\"#Iterator是什么，有什么作用？\" class=\"headerlink\" title=\"Iterator是什么，有什么作用？\"></a>Iterator是什么，有什么作用？</h3><h3 id=\"Generator函数是什么，有什么作用？\"><a href=\"#Generator函数是什么，有什么作用？\" class=\"headerlink\" title=\"Generator函数是什么，有什么作用？\"></a>Generator函数是什么，有什么作用？</h3><h3 id=\"什么是-async-await及其如何工作-有什么优缺点？\"><a href=\"#什么是-async-await及其如何工作-有什么优缺点？\" class=\"headerlink\" title=\"什么是 async/await及其如何工作,有什么优缺点？\"></a>什么是 async/await及其如何工作,有什么优缺点？</h3><h3 id=\"instanceof的原理是什么，如何实现\"><a href=\"#instanceof的原理是什么，如何实现\" class=\"headerlink\" title=\"instanceof的原理是什么，如何实现\"></a>instanceof的原理是什么，如何实现</h3><h3 id=\"js的节流与防抖\"><a href=\"#js的节流与防抖\" class=\"headerlink\" title=\"js的节流与防抖\"></a>js的节流与防抖</h3><h3 id=\"什么是设计模式？\"><a href=\"#什么是设计模式？\" class=\"headerlink\" title=\"什么是设计模式？\"></a>什么是设计模式？</h3><h3 id=\"9种前端常见的设计模式\"><a href=\"#9种前端常见的设计模式\" class=\"headerlink\" title=\"9种前端常见的设计模式\"></a>9种前端常见的设计模式</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"介绍一下js的数据类型有哪些-值是如何存储的\"><a href=\"#介绍一下js的数据类型有哪些-值是如何存储的\" class=\"headerlink\" title=\"介绍一下js的数据类型有哪些,值是如何存储的\"></a>介绍一下js的数据类型有哪些,值是如何存储的</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一共有8种数据类型，7种基本数据类型</span><br><span class=\"line\">String </span><br><span class=\"line\">Number </span><br><span class=\"line\">Boolean </span><br><span class=\"line\">Null </span><br><span class=\"line\">Undefined </span><br><span class=\"line\">Symbol（es6 新增类型，表示第一无二的值） </span><br><span class=\"line\">BigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）</span><br><span class=\"line\">Object（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）</span><br><span class=\"line\"></span><br><span class=\"line\">原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class=\"line\"></span><br><span class=\"line\">引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure>\n<h3 id=\"amp-amp-、-和-运算符分别能做什么\"><a href=\"#amp-amp-、-和-运算符分别能做什么\" class=\"headerlink\" title=\"&amp;&amp; 、 ||和!! 运算符分别能做什么\"></a>&amp;&amp; 、 ||和!! 运算符分别能做什么</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;&amp; 并且符，使用时两边的值结果都必须为true才返回true</span><br><span class=\"line\">|| 或者符，两边的值结果有一个为true最终判断结果就位true</span><br><span class=\"line\">!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）</span><br></pre></td></tr></table></figure>\n<h3 id=\"JS的数据类型的转换\"><a href=\"#JS的数据类型的转换\" class=\"headerlink\" title=\"JS的数据类型的转换\"></a>JS的数据类型的转换</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在 JS 中类型转换只有三种情况，分别是：</span><br><span class=\"line\"></span><br><span class=\"line\">- 转换为布尔值（调用Boolean()方法）</span><br><span class=\"line\">- 转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class=\"line\">- 转换为字符串（调用.toString()或者String()方法）</span><br><span class=\"line\"></span><br><span class=\"line\">null和underfined没有.toString方法</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\"><a href=\"#JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\" class=\"headerlink\" title=\"JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()\"></a>JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()</h3><blockquote>\n<p>（1）typeof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typeof 对于原始类型来说，除了 null 都可以显示正确的类型</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof 2);               // number</span><br><span class=\"line\">console.log(typeof true);            // boolean</span><br><span class=\"line\">console.log(typeof &apos;str&apos;);           // string</span><br><span class=\"line\">console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object</span><br><span class=\"line\">console.log(typeof function()&#123;&#125;);    // function</span><br><span class=\"line\">console.log(typeof &#123;&#125;);              // object</span><br><span class=\"line\">console.log(typeof undefined);       // undefined</span><br><span class=\"line\">console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object</span><br><span class=\"line\"></span><br><span class=\"line\">typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（2）instanceof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//重点</span><br><span class=\"line\">instanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断</span><br><span class=\"line\">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class=\"line\">其意思就是判断对象是否是某一数据类型（如Array）的实例</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(2 instanceof Number);                    // false</span><br><span class=\"line\">console.log(true instanceof Boolean);                // false </span><br><span class=\"line\">console.log(&apos;str&apos; instanceof String);                // false  </span><br><span class=\"line\">console.log([] instanceof Array);                    // true</span><br><span class=\"line\">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class=\"line\">console.log(&#123;&#125; instanceof Object);                   // true    </span><br><span class=\"line\">// console.log(undefined instanceof Undefined);      //报错</span><br><span class=\"line\">// console.log(null instanceof Null);                //报错</span><br><span class=\"line\">复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。</span><br><span class=\"line\">我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，&apos;str&apos;不是实例，所以判断值为false。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（3）constructor<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log((2).constructor === Number); // true</span><br><span class=\"line\">console.log((true).constructor === Boolean); // true</span><br><span class=\"line\">console.log((&apos;str&apos;).constructor === String); // true</span><br><span class=\"line\">console.log(([]).constructor === Array); // true</span><br><span class=\"line\">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class=\"line\">console.log((&#123;&#125;).constructor === Object); // true</span><br><span class=\"line\"></span><br><span class=\"line\">这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了</span><br><span class=\"line\"></span><br><span class=\"line\">function Fn()&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">Fn.prototype=new Array();</span><br><span class=\"line\"> </span><br><span class=\"line\">var f=new Fn();</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(f.constructor===Fn);    // false</span><br><span class=\"line\">console.log(f.constructor===Array); // true</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = Object.prototype.toString;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(a.call(2));</span><br><span class=\"line\">console.log(a.call(true));</span><br><span class=\"line\">console.log(a.call(&apos;str&apos;));</span><br><span class=\"line\">console.log(a.call([]));</span><br><span class=\"line\">console.log(a.call(function()&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(undefined));</span><br><span class=\"line\">console.log(a.call(null));</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"介绍-JS-有哪些内置对象？\"><a href=\"#介绍-JS-有哪些内置对象？\" class=\"headerlink\" title=\"介绍 JS 有哪些内置对象？\"></a>介绍 JS 有哪些内置对象？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class=\"line\">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class=\"line\"></span><br><span class=\"line\">标准内置对象的分类</span><br><span class=\"line\"></span><br><span class=\"line\">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Infinity、NaN、undefined、null 字面量</span><br><span class=\"line\"></span><br><span class=\"line\">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 eval()、parseFloat()、parseInt() 等</span><br><span class=\"line\"></span><br><span class=\"line\">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class=\"line\"></span><br><span class=\"line\">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Number、Math、Date</span><br><span class=\"line\"></span><br><span class=\"line\">（5）字符串，用来表示和操作字符串的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 String、RegExp</span><br><span class=\"line\"></span><br><span class=\"line\">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class=\"line\"></span><br><span class=\"line\">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Map、Set、WeakMap、WeakSet</span><br><span class=\"line\"></span><br><span class=\"line\">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 SIMD 等</span><br><span class=\"line\"></span><br><span class=\"line\">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 JSON 等</span><br><span class=\"line\"></span><br><span class=\"line\">（10）控制抽象对象</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Promise、Generator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（11）反射</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Reflect、Proxy</span><br><span class=\"line\"></span><br><span class=\"line\">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Intl、Intl.Collator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（13）WebAssembly</span><br><span class=\"line\"></span><br><span class=\"line\">（14）其他</span><br><span class=\"line\"></span><br><span class=\"line\">例如 arguments</span><br></pre></td></tr></table></figure>\n<h3 id=\"undefined-与-undeclared-的区别？\"><a href=\"#undefined-与-undeclared-的区别？\" class=\"headerlink\" title=\"undefined 与 undeclared 的区别？\"></a>undefined 与 undeclared 的区别？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。</span><br><span class=\"line\">对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ</span><br><span class=\"line\">eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</span><br></pre></td></tr></table></figure>\n<h3 id=\"null-和-undefined-的区别？\"><a href=\"#null-和-undefined-的区别？\" class=\"headerlink\" title=\"null 和 undefined 的区别？\"></a>null 和 undefined 的区别？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class=\"line\">undefined 代表的含义是未定义，</span><br><span class=\"line\">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class=\"line\">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class=\"line\">/*</span><br><span class=\"line\">    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，</span><br><span class=\"line\">    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class=\"line\">    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</span><br><span class=\"line\">*/</span><br><span class=\"line\">undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它</span><br><span class=\"line\">会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</span><br><span class=\"line\">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等</span><br><span class=\"line\">号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>\n<h3 id=\"和-的valueOf和toString的结果是什么？\"><a href=\"#和-的valueOf和toString的结果是什么？\" class=\"headerlink\" title=\"{}和[]的valueOf和toString的结果是什么？\"></a>{}和[]的valueOf和toString的结果是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Javascript-的作用域和作用域链？\"><a href=\"#Javascript-的作用域和作用域链？\" class=\"headerlink\" title=\"Javascript 的作用域和作用域链？\"></a>Javascript 的作用域和作用域链？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class=\"line\">【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</span><br></pre></td></tr></table></figure>\n<h3 id=\"javascript-创建对象的几种方式？\"><a href=\"#javascript-创建对象的几种方式？\" class=\"headerlink\" title=\"javascript 创建对象的几种方式？\"></a>javascript 创建对象的几种方式？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript-继承的几种实现方式？\"><a href=\"#JavaScript-继承的几种实现方式？\" class=\"headerlink\" title=\"JavaScript 继承的几种实现方式？\"></a>JavaScript 继承的几种实现方式？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</span><br></pre></td></tr></table></figure>\n<h3 id=\"寄生式组合继承的实现？\"><a href=\"#寄生式组合继承的实现？\" class=\"headerlink\" title=\"寄生式组合继承的实现？\"></a>寄生式组合继承的实现？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person</span><br><span class=\"line\">Student</span><br><span class=\"line\"></span><br><span class=\"line\">function Person(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Student(name, grade)&#123;</span><br><span class=\"line\">    Person.call(this,name);</span><br><span class=\"line\">    this.grade = grade;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype = Object.create(Person.prototype);</span><br><span class=\"line\">Student.prototype.constructor = Student;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.sayMyGrade = function() &#123;</span><br><span class=\"line\">  console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"谈谈你对this、call、apply和bind的理解\"><a href=\"#谈谈你对this、call、apply和bind的理解\" class=\"headerlink\" title=\"谈谈你对this、call、apply和bind的理解\"></a>谈谈你对this、call、apply和bind的理解</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结:</span><br><span class=\"line\">1. 在浏览器里，在全局范围内this 指向window对象；</span><br><span class=\"line\">2. 在函数中，this永远指向最后调用他的那个对象；</span><br><span class=\"line\">3. 构造函数中，this指向new出来的那个新的对象；</span><br><span class=\"line\">4. call、apply、bind中的this被强绑定在指定的那个对象上；</span><br><span class=\"line\">5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</span><br><span class=\"line\">6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</span><br><span class=\"line\"></span><br><span class=\"line\">区别:</span><br><span class=\"line\">- call/apply改变了函数的this上下文后马上执行该函数</span><br><span class=\"line\">- bind则是返回改变了上下文后的函数,不执行该函数</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript-原型，原型链？-有什么特点？\"><a href=\"#JavaScript-原型，原型链？-有什么特点？\" class=\"headerlink\" title=\"JavaScript 原型，原型链？ 有什么特点？\"></a>JavaScript 原型，原型链？ 有什么特点？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">prototype就是JS的原型，里面可以定义属性和方法</span><br><span class=\"line\">当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。</span><br><span class=\"line\">原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br></pre></td></tr></table></figure>\n<h3 id=\"js-获取原型的方法？\"><a href=\"#js-获取原型的方法？\" class=\"headerlink\" title=\"js 获取原型的方法？\"></a>js 获取原型的方法？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p.proto</span><br><span class=\"line\">p.constructor.prototype</span><br><span class=\"line\">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是闭包，为什么要用它？\"><a href=\"#什么是闭包，为什么要用它？\" class=\"headerlink\" title=\"什么是闭包，为什么要用它？\"></a>什么是闭包，为什么要用它？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">闭包是指有权访问另一个函数作用域内变量的函数</span><br><span class=\"line\">创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。</span><br><span class=\"line\"></span><br><span class=\"line\">闭包有两个常用的用途:</span><br><span class=\"line\">- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class=\"line\">- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</span><br><span class=\"line\"></span><br><span class=\"line\">function a()&#123;</span><br><span class=\"line\">    var n = 0;</span><br><span class=\"line\">    function add()&#123;</span><br><span class=\"line\">       n++;</span><br><span class=\"line\">       console.log(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span><br><span class=\"line\">a1();    //1</span><br><span class=\"line\">a1();    //2  第二次调用n变量还在内存中</span><br><span class=\"line\"></span><br><span class=\"line\">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是-DOM-和-BOM？\"><a href=\"#什么是-DOM-和-BOM？\" class=\"headerlink\" title=\"什么是 DOM 和 BOM？\"></a>什么是 DOM 和 BOM？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class=\"line\"></span><br><span class=\"line\">BOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM</span><br><span class=\"line\">的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）</span><br><span class=\"line\">对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati</span><br><span class=\"line\">on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对</span><br><span class=\"line\">象的子对象。</span><br></pre></td></tr></table></figure>\n<h3 id=\"三种事件模型是什么？\"><a href=\"#三种事件模型是什么？\" class=\"headerlink\" title=\"三种事件模型是什么？\"></a>三种事件模型是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class=\"line\">IE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class=\"line\">DOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"事件委托是什么？\"><a href=\"#事件委托是什么？\" class=\"headerlink\" title=\"事件委托是什么？\"></a>事件委托是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class=\"line\">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class=\"line\">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件传播\"><a href=\"#什么是事件传播\" class=\"headerlink\" title=\"什么是事件传播?\"></a>什么是事件传播?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。</span><br><span class=\"line\">事件传播有三个阶段：</span><br><span class=\"line\">1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class=\"line\">2. 目标阶段–事件已达到目标元素。</span><br><span class=\"line\">3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件捕获？\"><a href=\"#什么是事件捕获？\" class=\"headerlink\" title=\"什么是事件捕获？\"></a>什么是事件捕获？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----&gt; document----&gt; html----&gt; body ----&gt;目标元素</span><br><span class=\"line\"></span><br><span class=\"line\">html:</span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">js:</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是事件冒泡？\"><a href=\"#什么是事件冒泡？\" class=\"headerlink\" title=\"什么是事件冒泡？\"></a>什么是事件冒泡？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br><span class=\"line\">假设有如下的 HTML 结构：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">对应的JS代码：</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。</span><br></pre></td></tr></table></figure>\n<h3 id=\"DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\"><a href=\"#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\" class=\"headerlink\" title=\"DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><p>（1）创建新节点<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">createDocumentFragment()    //创建一个DOM片段</span><br><span class=\"line\">createElement()   //创建一个具体的元素</span><br><span class=\"line\">createTextNode()   //创建一个文本节点</span><br></pre></td></tr></table></figure></p>\n<p>（2）添加、移除、替换、插入<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendChild(node)</span><br><span class=\"line\">removeChild(node)</span><br><span class=\"line\">replaceChild(new,old)</span><br><span class=\"line\">insertBefore(new,old)</span><br></pre></td></tr></table></figure></p>\n<p>（3）查找<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getElementById();</span><br><span class=\"line\">getElementsByName();</span><br><span class=\"line\">getElementsByTagName();</span><br><span class=\"line\">getElementsByClassName();</span><br><span class=\"line\">querySelector();</span><br><span class=\"line\">querySelectorAll();</span><br></pre></td></tr></table></figure></p>\n<p>（4）属性操作<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getAttribute(key);</span><br><span class=\"line\">setAttribute(key, value);</span><br><span class=\"line\">hasAttribute(key);</span><br><span class=\"line\">removeAttribute(key);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"js数组和对象有哪些原生方法-列举一下\"><a href=\"#js数组和对象有哪些原生方法-列举一下\" class=\"headerlink\" title=\"js数组和对象有哪些原生方法,列举一下\"></a>js数组和对象有哪些原生方法,列举一下</h3><p><img src=\"https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h3 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h3><h3 id=\"Ajax-是什么-如何创建一个-Ajax？\"><a href=\"#Ajax-是什么-如何创建一个-Ajax？\" class=\"headerlink\" title=\"Ajax 是什么? 如何创建一个 Ajax？\"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。<br>创建步骤：<br><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/17274125a4cf4d61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//1：创建Ajax对象</span><br><span class=\"line\">var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);    //兼容IE6及以下版本</span><br><span class=\"line\">//2：配置 Ajax请求地址</span><br><span class=\"line\">xhr.open(&apos;get&apos;,&apos;index.xml&apos;,true);</span><br><span class=\"line\">//3：发送请求</span><br><span class=\"line\">xhr.send(null); //严谨写法</span><br><span class=\"line\">//4:监听请求，接受响应</span><br><span class=\"line\">xhr.onreadysatechange = function()&#123;</span><br><span class=\"line\">    if(xhr.readySates == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304)&#123;</span><br><span class=\"line\">        console.log(xhr.responsetXML);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>promise封装实现<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// promise 封装实现：</span><br><span class=\"line\"></span><br><span class=\"line\">function getJSON(url) &#123;</span><br><span class=\"line\">  // 创建一个 promise 对象</span><br><span class=\"line\">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">    let xhr = new XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 新建一个 http 请求</span><br><span class=\"line\">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置状态的监听函数</span><br><span class=\"line\">    xhr.onreadystatechange = function() &#123;</span><br><span class=\"line\">      if (this.readyState !== 4) return;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class=\"line\">      if (this.status === 200) &#123;</span><br><span class=\"line\">        resolve(this.response);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        reject(new Error(this.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置错误监听函数</span><br><span class=\"line\">    xhr.onerror = function() &#123;</span><br><span class=\"line\">      reject(new Error(this.statusText));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置响应的数据类型</span><br><span class=\"line\">    xhr.responseType = &quot;json&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置请求头信息</span><br><span class=\"line\">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 发送 http 请求</span><br><span class=\"line\">    xhr.send(null);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return promise;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"js-延迟加载的方式有哪些？\"><a href=\"#js-延迟加载的方式有哪些？\" class=\"headerlink\" title=\"js 延迟加载的方式有哪些？\"></a>js 延迟加载的方式有哪些？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class=\"line\">我了解到的几种方式是：</span><br><span class=\"line\"></span><br><span class=\"line\">将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class=\"line\">给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class=\"line\">给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class=\"line\">动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure>\n<h3 id=\"谈谈你对模块化开发的理解？\"><a href=\"#谈谈你对模块化开发的理解？\" class=\"headerlink\" title=\"谈谈你对模块化开发的理解？\"></a>谈谈你对模块化开发的理解？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念</span><br><span class=\"line\">，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class=\"line\">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污</span><br><span class=\"line\">染，并且模块间没有联系。</span><br><span class=\"line\">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所</span><br><span class=\"line\">有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class=\"line\">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure>\n<h3 id=\"js-的几种模块规范？\"><a href=\"#js-的几种模块规范？\" class=\"headerlink\" title=\"js 的几种模块规范？\"></a>js 的几种模块规范？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">js 中现在比较成熟的有四种模块加载方案：</span><br><span class=\"line\"></span><br><span class=\"line\">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class=\"line\">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class=\"line\">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class=\"line\">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</span><br></pre></td></tr></table></figure>\n<h3 id=\"AMD和CMD-规范的区别？\"><a href=\"#AMD和CMD-规范的区别？\" class=\"headerlink\" title=\"AMD和CMD 规范的区别？\"></a>AMD和CMD 规范的区别？</h3><p>它们之间的主要区别有两个方面。</p>\n<ol>\n<li>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</li>\n<li>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br> 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br> 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br> 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">  var a = require(&quot;./a&quot;);</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 此处略去 100 行</span><br><span class=\"line\">  var b = require(&quot;./b&quot;); // 依赖可以就近书写</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) &#123;</span><br><span class=\"line\">  // 依赖必须一开始就写好</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 此处略去 100 行</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\"><a href=\"#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\" class=\"headerlink\" title=\"ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><ul>\n<li>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>\n<li>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>\n</ul>\n<h3 id=\"requireJS的核心原理是什么？\"><a href=\"#requireJS的核心原理是什么？\" class=\"headerlink\" title=\"requireJS的核心原理是什么？\"></a>requireJS的核心原理是什么？</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p>\n<h3 id=\"谈谈JS的运行机制\"><a href=\"#谈谈JS的运行机制\" class=\"headerlink\" title=\"谈谈JS的运行机制\"></a>谈谈JS的运行机制</h3><ol>\n<li><p>js单线程<br>JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。</p>\n<blockquote>\n<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>\n</blockquote>\n</li>\n<li><p>js事件循环<br>js代码执行过程中会有很多任务，这些任务总的分成两类：</p>\n</li>\n</ol>\n<ul>\n<li>同步任务</li>\n<li>异步任务<br>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：<br><img src=\"https://user-gold-cdn.xitu.io/2020/6/2/172744a7fa2853c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></li>\n</ul>\n<p>回答：</p>\n<ol>\n<li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li>\n<li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li>\n<li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li>\n<li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li>\n<li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li>\n</ol>\n<h3 id=\"arguments-的对象是什么？\"><a href=\"#arguments-的对象是什么？\" class=\"headerlink\" title=\"arguments 的对象是什么？\"></a>arguments 的对象是什么？</h3><p>arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。<br>我们可以使用Array.prototype.slice将arguments对象转换成一个数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function one() &#123;</span><br><span class=\"line\">  return Array.prototype.slice.call(arguments);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意:箭头函数中没有arguments对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function one() &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const two = function () &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const three = function three() &#123;</span><br><span class=\"line\">  return arguments;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const four = () =&gt; arguments;</span><br><span class=\"line\"></span><br><span class=\"line\">four(); // Throws an error  - arguments is not defined</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为什么在调用这个函数时，代码中的b会变成一个全局变量\"><a href=\"#为什么在调用这个函数时，代码中的b会变成一个全局变量\" class=\"headerlink\" title=\"为什么在调用这个函数时，代码中的b会变成一个全局变量?\"></a>为什么在调用这个函数时，代码中的b会变成一个全局变量?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a = b = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure>\n<p>原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a = (b = 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure></p>\n<p>首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。</p>\n<p>我们可以通过在赋值之前先声明变量来解决这个问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myFunc() &#123;</span><br><span class=\"line\">  let a,b;</span><br><span class=\"line\">  a = b = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"简单介绍一下V8引擎的垃圾回收机制\"><a href=\"#简单介绍一下V8引擎的垃圾回收机制\" class=\"headerlink\" title=\"简单介绍一下V8引擎的垃圾回收机制\"></a>简单介绍一下V8引擎的垃圾回收机制</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class=\"line\"></span><br><span class=\"line\">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class=\"line\"></span><br><span class=\"line\">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）如果对象不存活，则释放对象的空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class=\"line\"></span><br><span class=\"line\">新生代对象晋升到老生代有两个条件：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class=\"line\"></span><br><span class=\"line\">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class=\"line\"></span><br><span class=\"line\">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"哪些操作会造成内存泄漏？\"><a href=\"#哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"哪些操作会造成内存泄漏？\"></a>哪些操作会造成内存泄漏？</h3><ul>\n<li>1.意外的全局变量</li>\n<li>2.被遗忘的计时器或回调函数</li>\n<li>3.脱离 DOM 的引用</li>\n<li><p>4.闭包</p>\n</li>\n<li><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p>\n</li>\n<li>第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>\n<li>第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>\n<li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>\n</ul>\n<h3 id=\"ECMAScript-是什么？\"><a href=\"#ECMAScript-是什么？\" class=\"headerlink\" title=\"ECMAScript 是什么？\"></a>ECMAScript 是什么？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。</span><br><span class=\"line\">ECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件</span><br><span class=\"line\">只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。</span><br><span class=\"line\">javaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）</span><br><span class=\"line\">ECMAScript说什么JavaScript就得做什么！</span><br><span class=\"line\">JavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！</span><br><span class=\"line\">——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，</span><br><span class=\"line\">那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。</span><br></pre></td></tr></table></figure>\n<h3 id=\"ECMAScript-2015（ES6）有哪些新特性？\"><a href=\"#ECMAScript-2015（ES6）有哪些新特性？\" class=\"headerlink\" title=\"ECMAScript 2015（ES6）有哪些新特性？\"></a>ECMAScript 2015（ES6）有哪些新特性？</h3><ul>\n<li>块作用域</li>\n<li>类</li>\n<li>箭头函数</li>\n<li>模板字符串</li>\n<li>加强的对象字面</li>\n<li>对象解构</li>\n<li>Promise</li>\n<li>模块</li>\n<li>Symbol</li>\n<li>代理（proxy）Set</li>\n<li>函数默认参数</li>\n<li>rest 和展开</li>\n</ul>\n<h3 id=\"var-let和const的区别是什么？\"><a href=\"#var-let和const的区别是什么？\" class=\"headerlink\" title=\"var,let和const的区别是什么？\"></a>var,let和const的区别是什么？</h3><p>var声明的变量会挂载在window上，而let和const声明的变量不会：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\">console.log(a,window.a);    // 100 100</span><br><span class=\"line\"></span><br><span class=\"line\">let b = 10;</span><br><span class=\"line\">console.log(b,window.b);    // 10 undefined</span><br><span class=\"line\"></span><br><span class=\"line\">const c = 1;</span><br><span class=\"line\">console.log(c,window.c);    // 1 undefined</span><br></pre></td></tr></table></figure></p>\n<p>var声明变量存在变量提升，let和const不存在变量提升:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(a); // undefined  ===&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class=\"line\">var a = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b); // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class=\"line\">let b = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(c); // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br><span class=\"line\">const c = 10;</span><br></pre></td></tr></table></figure></p>\n<p>let和const声明形成块作用域<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">  var a = 100;</span><br><span class=\"line\">  let b = 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\">console.log(b)  // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class=\"line\"></span><br><span class=\"line\">-------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">  var a = 100;</span><br><span class=\"line\">  const c = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\">console.log(c)  // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br></pre></td></tr></table></figure></p>\n<p>同一作用域下let和const不能声明同名变量，而var可以<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\">console.log(a); // 100</span><br><span class=\"line\"></span><br><span class=\"line\">var a = 10;</span><br><span class=\"line\">console.log(a); // 10</span><br><span class=\"line\">-------------------------------------</span><br><span class=\"line\">let a = 100;</span><br><span class=\"line\">let a = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">//  控制台报错：Identifier &apos;a&apos; has already been declared  ===&gt; 标识符a已经被声明了。</span><br></pre></td></tr></table></figure></p>\n<p>暂存死区<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">if(1)&#123;</span><br><span class=\"line\">    a = 10;</span><br><span class=\"line\">    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class=\"line\">    // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class=\"line\">    let a = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>const<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;1、一旦声明必须赋值,不能使用null占位。</span><br><span class=\"line\">*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;2、声明后不能再修改</span><br><span class=\"line\">*</span><br><span class=\"line\">* &amp;emsp;&amp;emsp;3、如果声明的是复合类型数据，可以修改其属性</span><br><span class=\"line\">*</span><br><span class=\"line\">* */</span><br><span class=\"line\"></span><br><span class=\"line\">const a = 100; </span><br><span class=\"line\"></span><br><span class=\"line\">const list = [];</span><br><span class=\"line\">list[0] = 10;</span><br><span class=\"line\">console.log(list);&amp;emsp;&amp;emsp;// [10]</span><br><span class=\"line\"></span><br><span class=\"line\">const obj = &#123;a:100&#125;;</span><br><span class=\"line\">obj.name = &apos;apple&apos;;</span><br><span class=\"line\">obj.a = 10000;</span><br><span class=\"line\">console.log(obj);&amp;emsp;&amp;emsp;// &#123;a:10000,name:&apos;apple&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是箭头函数？\"><a href=\"#什么是箭头函数？\" class=\"headerlink\" title=\"什么是箭头函数？\"></a>什么是箭头函数？</h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var getCurrentDate = function ()&#123;</span><br><span class=\"line\">  return new Date();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">const getCurrentDate = () =&gt; new Date();</span><br></pre></td></tr></table></figure></p>\n<p>在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">const greet = (name) =&gt; `Hello $&#123;name&#125;`;</span><br><span class=\"line\">const greet2 = name =&gt; `Hello $&#123;name&#125;`;</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const getArgs = () =&gt; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">const getArgs2 = (...rest) =&gt; rest</span><br></pre></td></tr></table></figure></p>\n<p>箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const data = &#123;</span><br><span class=\"line\">  result: 0,</span><br><span class=\"line\">  nums: [1, 2, 3, 4, 5],</span><br><span class=\"line\">  computeResult() &#123;</span><br><span class=\"line\">    // 这里的“this”指的是“data”对象</span><br><span class=\"line\">    const addAll = () =&gt; &#123;</span><br><span class=\"line\">      return this.nums.reduce((total, cur) =&gt; total + cur, 0)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.result = addAll();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。</p>\n<h3 id=\"什么是类？\"><a href=\"#什么是类？\" class=\"headerlink\" title=\"什么是类？\"></a>什么是类？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是模板字符串？\"><a href=\"#什么是模板字符串？\" class=\"headerlink\" title=\"什么是模板字符串？\"></a>什么是模板字符串？</h3><p>模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var greet = &apos;Hi I\\&apos;m Mark&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">let greet = `Hi I&apos;m Mark`;</span><br></pre></td></tr></table></figure></p>\n<p>在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">var lastWords = &apos;\\n&apos;</span><br><span class=\"line\">  + &apos;   I  \\n&apos;</span><br><span class=\"line\">  + &apos;   Am  \\n&apos;</span><br><span class=\"line\">  + &apos;Iron Man \\n&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">let lastWords = `</span><br><span class=\"line\">    I</span><br><span class=\"line\">    Am</span><br><span class=\"line\">  Iron Man   </span><br><span class=\"line\">`;</span><br></pre></td></tr></table></figure></p>\n<p>在ES5版本中，我们需要添加\\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//ES5 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//ES6 Version</span><br><span class=\"line\">function greet(name) &#123;</span><br><span class=\"line\">  return `Hello $&#123;name&#125; !`;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。</p>\n<h3 id=\"什么是对象解构？\"><a href=\"#什么是对象解构？\" class=\"headerlink\" title=\"什么是对象解构？\"></a>什么是对象解构？</h3><p>对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const employee = &#123;</span><br><span class=\"line\">  firstName: &quot;Marko&quot;,</span><br><span class=\"line\">  lastName: &quot;Polo&quot;,</span><br><span class=\"line\">  position: &quot;Software Developer&quot;,</span><br><span class=\"line\">  yearHired: 2017</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var firstName = employee.firstName;</span><br><span class=\"line\">var lastName = employee.lastName;</span><br><span class=\"line\">var position = employee.position;</span><br><span class=\"line\">var yearHired = employee.yearHired;</span><br></pre></td></tr></table></figure></p>\n<p>使用解构方式语法就变得简洁多了：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; firstName, lastName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<p>我们还可以为属性取别名：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let &#123; firstName: fName, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<p>当然如果属性值为 undefined 时，我们还可以指定默认值，但是属性为null时指定的默认值则不生效：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let &#123; firstName = &quot;Mark&quot;, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"什么是Set对象，它是如何工作的？\"><a href=\"#什么是Set对象，它是如何工作的？\" class=\"headerlink\" title=\"什么是Set对象，它是如何工作的？\"></a>什么是Set对象，它是如何工作的？</h3><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>\n<p>我们可以使用Set构造函数创建Set实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const set1 = new Set();</span><br><span class=\"line\">const set2 = new Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;e&quot;]);</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.add(&quot;f&quot;);</span><br><span class=\"line\">set2.add(&quot;g&quot;).add(&quot;h&quot;).add(&quot;i&quot;).add(&quot;j&quot;).add(&quot;k&quot;).add(&quot;k&quot;);</span><br><span class=\"line\">// 后一个“k”不会被添加到set对象中，因为它已经存在了</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用has方法检查Set实例中是否存在特定的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.has(&quot;a&quot;) // true</span><br><span class=\"line\">set2.has(&quot;z&quot;) // true</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用size属性获得Set实例的长度。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.size // returns 10</span><br></pre></td></tr></table></figure></p>\n<p>可以使用clear方法删除 Set 中的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set2.clear();</span><br></pre></td></tr></table></figure></p>\n<p>我们可以使用Set对象来删除数组中重复的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];</span><br><span class=\"line\">const uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></p>\n<p>另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。</p>\n<ul>\n<li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>\n<li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>\n</ul>\n<h3 id=\"什么是Proxy？\"><a href=\"#什么是Proxy？\" class=\"headerlink\" title=\"什么是Proxy？\"></a>什么是Proxy？</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n<h3 id=\"写一个通用的事件侦听器函数？\"><a href=\"#写一个通用的事件侦听器函数？\" class=\"headerlink\" title=\"写一个通用的事件侦听器函数？\"></a>写一个通用的事件侦听器函数？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const EventUtils = &#123;</span><br><span class=\"line\">  // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class=\"line\">  // 添加事件</span><br><span class=\"line\">  addEvent: function(element, type, handler) &#123;</span><br><span class=\"line\">    if (element.addEventListener) &#123;</span><br><span class=\"line\">      element.addEventListener(type, handler, false);</span><br><span class=\"line\">    &#125; else if (element.attachEvent) &#123;</span><br><span class=\"line\">      element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      element[&quot;on&quot; + type] = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 移除事件</span><br><span class=\"line\">  removeEvent: function(element, type, handler) &#123;</span><br><span class=\"line\">    if (element.removeEventListener) &#123;</span><br><span class=\"line\">      element.removeEventListener(type, handler, false);</span><br><span class=\"line\">    &#125; else if (element.detachEvent) &#123;</span><br><span class=\"line\">      element.detachEvent(&quot;on&quot; + type, handler);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      element[&quot;on&quot; + type] = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取事件目标</span><br><span class=\"line\">  getTarget: function(event) &#123;</span><br><span class=\"line\">    return event.target || event.srcElement;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span><br><span class=\"line\">  getEvent: function(event) &#123;</span><br><span class=\"line\">    return event || window.event;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span><br><span class=\"line\">  stopPropagation: function(event) &#123;</span><br><span class=\"line\">    if (event.stopPropagation) &#123;</span><br><span class=\"line\">      event.stopPropagation();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      event.cancelBubble = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // 取消事件的默认行为</span><br><span class=\"line\">  preventDefault: function(event) &#123;</span><br><span class=\"line\">    if (event.preventDefault) &#123;</span><br><span class=\"line\">      event.preventDefault();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      event.returnValue = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\"><a href=\"#什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\" class=\"headerlink\" title=\"什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\"></a>什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</span><br><span class=\"line\">函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。</span><br><span class=\"line\">函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是高阶函数？\"><a href=\"#什么是高阶函数？\" class=\"headerlink\" title=\"什么是高阶函数？\"></a>什么是高阶函数？</h3><p>高阶函数只是将函数作为参数或返回值的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function higherOrderFunction(param,callback)&#123;</span><br><span class=\"line\">    return callback(param);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"为什么函数被称为一等公民？\"><a href=\"#为什么函数被称为一等公民？\" class=\"headerlink\" title=\"为什么函数被称为一等公民？\"></a>为什么函数被称为一等公民？</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:</span><br><span class=\"line\"></span><br><span class=\"line\">赋值（var func = function()&#123;&#125;）、</span><br><span class=\"line\">传参(function func(x,callback)&#123;callback();&#125;)、</span><br><span class=\"line\">返回(function()&#123;return function()&#123;&#125;&#125;)，</span><br><span class=\"line\"></span><br><span class=\"line\">这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-map-方法\"><a href=\"#手动实现Array-prototype-map-方法\" class=\"headerlink\" title=\"手动实现Array.prototype.map 方法\"></a>手动实现Array.prototype.map 方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</span><br><span class=\"line\">function map(arr, mapCallback) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== &apos;function&apos;) &#123; </span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let result = [];</span><br><span class=\"line\">    // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class=\"line\">    // 因为我们不想改变原始数组。</span><br><span class=\"line\">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      result.push(mapCallback(arr[i], i, arr)); </span><br><span class=\"line\">      // 将 mapCallback 返回的结果 push 到 result 数组中</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-filter方法\"><a href=\"#手动实现Array-prototype-filter方法\" class=\"headerlink\" title=\"手动实现Array.prototype.filter方法\"></a>手动实现Array.prototype.filter方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</span><br><span class=\"line\">function filter(arr, filterCallback) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== &apos;function&apos;) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let result = [];</span><br><span class=\"line\">     // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class=\"line\">     // 因为我们不想改变原始数组。</span><br><span class=\"line\">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      // 检查 filterCallback 的返回值是否是真值</span><br><span class=\"line\">      if (filterCallback(arr[i], i, arr)) &#123; </span><br><span class=\"line\">      // 如果条件为真，则将数组元素 push 到 result 中</span><br><span class=\"line\">        result.push(arr[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result; // return the result array</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"手动实现Array-prototype-reduce方法\"><a href=\"#手动实现Array-prototype-reduce方法\" class=\"headerlink\" title=\"手动实现Array.prototype.reduce方法\"></a>手动实现Array.prototype.reduce方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。</span><br><span class=\"line\"></span><br><span class=\"line\">function reduce(arr, reduceCallback, initialValue) &#123;</span><br><span class=\"line\">  // 首先，检查传递的参数是否正确。</span><br><span class=\"line\">  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== &apos;function&apos;) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    return [];</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span><br><span class=\"line\">    let hasInitialValue = initialValue !== undefined;</span><br><span class=\"line\">    let value = hasInitialValue ? initialValue : arr[0];</span><br><span class=\"line\">   、</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span><br><span class=\"line\">    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">      value = reduceCallback(value, arr[i], i, arr); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"js的深浅拷贝\"><a href=\"#js的深浅拷贝\" class=\"headerlink\" title=\"js的深浅拷贝\"></a>js的深浅拷贝</h3><blockquote>\n<p>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。</p>\n<ul>\n<li>浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>\n<li>深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。<br>浅拷贝的实现方式：</li>\n<li>Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>\n<li>Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li>\n<li>拓展运算符…：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">    name: &quot;Jake&quot;,</span><br><span class=\"line\">    flag: &#123;</span><br><span class=\"line\">        title: &quot;better day by day&quot;,</span><br><span class=\"line\">        time: &quot;2020-05-31&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = &#123;...a&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>深拷贝的实现方式：</p>\n<ul>\n<li>乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）</li>\n<li>基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function cloneDeep(target,map = new WeakMap()) &#123;</span><br><span class=\"line\">  if(typeOf taret ===&apos;object&apos;)&#123;</span><br><span class=\"line\">     let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class=\"line\">      </span><br><span class=\"line\">     if(map.get(target)) &#123;</span><br><span class=\"line\">        return target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     map.set(target, cloneTarget);</span><br><span class=\"line\">     for(const key in target)&#123;</span><br><span class=\"line\">        cloneTarget[key] = cloneDeep(target[key], map);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     return cloneTarget</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">       return target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>终极版：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const mapTag = &apos;[object Map]&apos;;</span><br><span class=\"line\">const setTag = &apos;[object Set]&apos;;</span><br><span class=\"line\">const arrayTag = &apos;[object Array]&apos;;</span><br><span class=\"line\">const objectTag = &apos;[object Object]&apos;;</span><br><span class=\"line\">const argsTag = &apos;[object Arguments]&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const boolTag = &apos;[object Boolean]&apos;;</span><br><span class=\"line\">const dateTag = &apos;[object Date]&apos;;</span><br><span class=\"line\">const numberTag = &apos;[object Number]&apos;;</span><br><span class=\"line\">const stringTag = &apos;[object String]&apos;;</span><br><span class=\"line\">const symbolTag = &apos;[object Symbol]&apos;;</span><br><span class=\"line\">const errorTag = &apos;[object Error]&apos;;</span><br><span class=\"line\">const regexpTag = &apos;[object RegExp]&apos;;</span><br><span class=\"line\">const funcTag = &apos;[object Function]&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function forEach(array, iteratee) &#123;</span><br><span class=\"line\">    let index = -1;</span><br><span class=\"line\">    const length = array.length;</span><br><span class=\"line\">    while (++index &lt; length) &#123;</span><br><span class=\"line\">        iteratee(array[index], index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function isObject(target) &#123;</span><br><span class=\"line\">    const type = typeof target;</span><br><span class=\"line\">    return target !== null &amp;&amp; (type === &apos;object&apos; || type === &apos;function&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getType(target) &#123;</span><br><span class=\"line\">    return Object.prototype.toString.call(target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getInit(target) &#123;</span><br><span class=\"line\">    const Ctor = target.constructor;</span><br><span class=\"line\">    return new Ctor();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneSymbol(targe) &#123;</span><br><span class=\"line\">    return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneReg(targe) &#123;</span><br><span class=\"line\">    const reFlags = /\\w*$/;</span><br><span class=\"line\">    const result = new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class=\"line\">    result.lastIndex = targe.lastIndex;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneFunction(func) &#123;</span><br><span class=\"line\">    const bodyReg = /(?&lt;=&#123;)(.|\\n)+(?=&#125;)/m;</span><br><span class=\"line\">    const paramReg = /(?&lt;=\\().+(?=\\)\\s+&#123;)/;</span><br><span class=\"line\">    const funcString = func.toString();</span><br><span class=\"line\">    if (func.prototype) &#123;</span><br><span class=\"line\">        const param = paramReg.exec(funcString);</span><br><span class=\"line\">        const body = bodyReg.exec(funcString);</span><br><span class=\"line\">        if (body) &#123;</span><br><span class=\"line\">            if (param) &#123;</span><br><span class=\"line\">                const paramArr = param[0].split(&apos;,&apos;);</span><br><span class=\"line\">                return new Function(...paramArr, body[0]);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                return new Function(body[0]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return eval(funcString);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneOtherType(targe, type) &#123;</span><br><span class=\"line\">    const Ctor = targe.constructor;</span><br><span class=\"line\">    switch (type) &#123;</span><br><span class=\"line\">        case boolTag:</span><br><span class=\"line\">        case numberTag:</span><br><span class=\"line\">        case stringTag:</span><br><span class=\"line\">        case errorTag:</span><br><span class=\"line\">        case dateTag:</span><br><span class=\"line\">            return new Ctor(targe);</span><br><span class=\"line\">        case regexpTag:</span><br><span class=\"line\">            return cloneReg(targe);</span><br><span class=\"line\">        case symbolTag:</span><br><span class=\"line\">            return cloneSymbol(targe);</span><br><span class=\"line\">        case funcTag:</span><br><span class=\"line\">            return cloneFunction(targe);</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function clone(target, map = new WeakMap()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆原始类型</span><br><span class=\"line\">    if (!isObject(target)) &#123;</span><br><span class=\"line\">        return target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化</span><br><span class=\"line\">    const type = getType(target);</span><br><span class=\"line\">    let cloneTarget;</span><br><span class=\"line\">    if (deepTag.includes(type)) &#123;</span><br><span class=\"line\">        cloneTarget = getInit(target, type);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return cloneOtherType(target, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 防止循环引用</span><br><span class=\"line\">    if (map.get(target)) &#123;</span><br><span class=\"line\">        return map.get(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map.set(target, cloneTarget);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆set</span><br><span class=\"line\">    if (type === setTag) &#123;</span><br><span class=\"line\">        target.forEach(value =&gt; &#123;</span><br><span class=\"line\">            cloneTarget.add(clone(value, map));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return cloneTarget;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆map</span><br><span class=\"line\">    if (type === mapTag) &#123;</span><br><span class=\"line\">        target.forEach((value, key) =&gt; &#123;</span><br><span class=\"line\">            cloneTarget.set(key, clone(value, map));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return cloneTarget;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 克隆对象和数组</span><br><span class=\"line\">    const keys = type === arrayTag ? undefined : Object.keys(target);</span><br><span class=\"line\">    forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class=\"line\">        if (keys) &#123;</span><br><span class=\"line\">            key = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cloneTarget[key] = clone(target[key], map);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return cloneTarget;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    clone</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"手写call、apply及bind函数\"><a href=\"#手写call、apply及bind函数\" class=\"headerlink\" title=\"手写call、apply及bind函数\"></a>手写call、apply及bind函数</h3><p>call 函数的实现步骤：</p>\n<ul>\n<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>3.处理传入的参数，截取第一个参数后的所有参数。</li>\n<li>4.将函数作为上下文对象的一个属性。</li>\n<li>5.使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>6.删除刚才新增的属性。</li>\n<li>7.返回结果。<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// call函数实现</span><br><span class=\"line\">Function.prototype.myCall = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    console.error(&quot;type error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 获取参数</span><br><span class=\"line\">  let args = [...arguments].slice(1),</span><br><span class=\"line\">    result = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 判断 context 是否传入，如果未传入则设置为 window</span><br><span class=\"line\">  context = context || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将调用函数设为对象的方法</span><br><span class=\"line\">  context.fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用函数</span><br><span class=\"line\">  result = context.fn(...args);</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将属性删除</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>apply 函数的实现步骤：</p>\n<ul>\n<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>将函数作为上下文对象的一个属性。</li>\n<li>判断参数值是否传入</li>\n<li>使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>删除刚才新增的属性</li>\n<li>返回结果<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// apply 函数实现</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.myApply = function(context) &#123;</span><br><span class=\"line\">  // 判断调用对象是否为函数</span><br><span class=\"line\">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class=\"line\">    throw new TypeError(&quot;Error&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  let result = null;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 判断 context 是否存在，如果未传入则为 window</span><br><span class=\"line\">  context = context || window;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将函数设为对象的方法</span><br><span class=\"line\">  context.fn = this;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 调用方法</span><br><span class=\"line\">  if (arguments[1]) &#123;</span><br><span class=\"line\">    result = context.fn(...arguments[1]);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    result = context.fn();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 将属性删除</span><br><span class=\"line\">  delete context.fn;</span><br><span class=\"line\"></span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"函数柯里化的实现\"><a href=\"#函数柯里化的实现\" class=\"headerlink\" title=\"函数柯里化的实现\"></a>函数柯里化的实现</h3><h3 id=\"js模拟new操作符的实现\"><a href=\"#js模拟new操作符的实现\" class=\"headerlink\" title=\"js模拟new操作符的实现\"></a>js模拟new操作符的实现</h3><h3 id=\"什么是回调函数？回调函数有什么缺点\"><a href=\"#什么是回调函数？回调函数有什么缺点\" class=\"headerlink\" title=\"什么是回调函数？回调函数有什么缺点\"></a>什么是回调函数？回调函数有什么缺点</h3><h3 id=\"Promise是什么，可以手写实现一下吗？\"><a href=\"#Promise是什么，可以手写实现一下吗？\" class=\"headerlink\" title=\"Promise是什么，可以手写实现一下吗？\"></a>Promise是什么，可以手写实现一下吗？</h3><h3 id=\"Iterator是什么，有什么作用？\"><a href=\"#Iterator是什么，有什么作用？\" class=\"headerlink\" title=\"Iterator是什么，有什么作用？\"></a>Iterator是什么，有什么作用？</h3><h3 id=\"Generator函数是什么，有什么作用？\"><a href=\"#Generator函数是什么，有什么作用？\" class=\"headerlink\" title=\"Generator函数是什么，有什么作用？\"></a>Generator函数是什么，有什么作用？</h3><h3 id=\"什么是-async-await及其如何工作-有什么优缺点？\"><a href=\"#什么是-async-await及其如何工作-有什么优缺点？\" class=\"headerlink\" title=\"什么是 async/await及其如何工作,有什么优缺点？\"></a>什么是 async/await及其如何工作,有什么优缺点？</h3><h3 id=\"instanceof的原理是什么，如何实现\"><a href=\"#instanceof的原理是什么，如何实现\" class=\"headerlink\" title=\"instanceof的原理是什么，如何实现\"></a>instanceof的原理是什么，如何实现</h3><h3 id=\"js的节流与防抖\"><a href=\"#js的节流与防抖\" class=\"headerlink\" title=\"js的节流与防抖\"></a>js的节流与防抖</h3><h3 id=\"什么是设计模式？\"><a href=\"#什么是设计模式？\" class=\"headerlink\" title=\"什么是设计模式？\"></a>什么是设计模式？</h3><h3 id=\"9种前端常见的设计模式\"><a href=\"#9种前端常见的设计模式\" class=\"headerlink\" title=\"9种前端常见的设计模式\"></a>9种前端常见的设计模式</h3>"},{"title":"让h5页面强制横屏","date":"2018-07-25T07:51:43.000Z","_content":"\n>转载至：https://blog.csdn.net/qq_36457584/article/details/80967278\n\n```\n//注意设置*{padding:0;margin:0;} 不然有滚动条\n/**\n    * H5强制横屏\n    * @param {Object}\n    */   \nvar wrapper = document.getElementById(\"root\");      \nvar mark = window.orientation == 90 || window.orientation == -90;    //初始角度\n//不同角度宽高需要互换\nvar width = document.documentElement[mark ? 'clientHeight' : 'clientWidth']; \nvar height = document.documentElement[mark ? 'clientWidth' : 'clientHeight'];                         \nvar detectOrient = function() {\n    var style = \"\";                            \n    if (window.orientation == 90 || window.orientation == -90) { //横屏                             \n        style += \"width:100%;\"; \n        style += \"height:100%;\";\n        style += \"-webkit-transform: rotate(0); transform: rotate(0);\";\n        style += \"-webkit-transform-origin: 0 0;\";\n        style += \"transform-origin: 0 0;\";\n    } else if(window.orientation == 180 || window.orientation == 0){ //竖屏                    \n        style += \"width:\" + height + \"px;\";// 注意旋转后的宽高切换\n        style += \"height:\"+  width + \"px;\";\n        style += \"-webkit-transform: rotate(90deg); transform: rotate(90deg);\";\n        // 注意旋转中点的处理\n        style += \"-webkit-transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n        style += \"transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n    }\n    style += \"visibility: initial;\";\n    wrapper.style.cssText = style;\n    $(\"#progress\").addClass(\"animate-progress\");\n}        \nwindow.addEventListener(\"load\", detectOrient, false);\nwindow.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", detectOrient, false);\ndetectOrient();  \n\n```","source":"_posts/让h5页面强制横屏.md","raw":"---\ntitle: 让h5页面强制横屏\ndate: 2018-07-25 15:51:43\ntags: [javaScript,技巧]\ncategories: 技术\n---\n\n>转载至：https://blog.csdn.net/qq_36457584/article/details/80967278\n\n```\n//注意设置*{padding:0;margin:0;} 不然有滚动条\n/**\n    * H5强制横屏\n    * @param {Object}\n    */   \nvar wrapper = document.getElementById(\"root\");      \nvar mark = window.orientation == 90 || window.orientation == -90;    //初始角度\n//不同角度宽高需要互换\nvar width = document.documentElement[mark ? 'clientHeight' : 'clientWidth']; \nvar height = document.documentElement[mark ? 'clientWidth' : 'clientHeight'];                         \nvar detectOrient = function() {\n    var style = \"\";                            \n    if (window.orientation == 90 || window.orientation == -90) { //横屏                             \n        style += \"width:100%;\"; \n        style += \"height:100%;\";\n        style += \"-webkit-transform: rotate(0); transform: rotate(0);\";\n        style += \"-webkit-transform-origin: 0 0;\";\n        style += \"transform-origin: 0 0;\";\n    } else if(window.orientation == 180 || window.orientation == 0){ //竖屏                    \n        style += \"width:\" + height + \"px;\";// 注意旋转后的宽高切换\n        style += \"height:\"+  width + \"px;\";\n        style += \"-webkit-transform: rotate(90deg); transform: rotate(90deg);\";\n        // 注意旋转中点的处理\n        style += \"-webkit-transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n        style += \"transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n    }\n    style += \"visibility: initial;\";\n    wrapper.style.cssText = style;\n    $(\"#progress\").addClass(\"animate-progress\");\n}        \nwindow.addEventListener(\"load\", detectOrient, false);\nwindow.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", detectOrient, false);\ndetectOrient();  \n\n```","slug":"让h5页面强制横屏","published":1,"updated":"2019-10-23T07:39:13.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzj500071wek0tyq6vov","content":"<blockquote>\n<p>转载至：<a href=\"https://blog.csdn.net/qq_36457584/article/details/80967278\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_36457584/article/details/80967278</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//注意设置*&#123;padding:0;margin:0;&#125; 不然有滚动条</span><br><span class=\"line\">/**</span><br><span class=\"line\">    * H5强制横屏</span><br><span class=\"line\">    * @param &#123;Object&#125;</span><br><span class=\"line\">    */   </span><br><span class=\"line\">var wrapper = document.getElementById(&quot;root&quot;);      </span><br><span class=\"line\">var mark = window.orientation == 90 || window.orientation == -90;    //初始角度</span><br><span class=\"line\">//不同角度宽高需要互换</span><br><span class=\"line\">var width = document.documentElement[mark ? &apos;clientHeight&apos; : &apos;clientWidth&apos;]; </span><br><span class=\"line\">var height = document.documentElement[mark ? &apos;clientWidth&apos; : &apos;clientHeight&apos;];                         </span><br><span class=\"line\">var detectOrient = function() &#123;</span><br><span class=\"line\">    var style = &quot;&quot;;                            </span><br><span class=\"line\">    if (window.orientation == 90 || window.orientation == -90) &#123; //横屏                             </span><br><span class=\"line\">        style += &quot;width:100%;&quot;; </span><br><span class=\"line\">        style += &quot;height:100%;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(0); transform: rotate(0);&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: 0 0;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: 0 0;&quot;;</span><br><span class=\"line\">    &#125; else if(window.orientation == 180 || window.orientation == 0)&#123; //竖屏                    </span><br><span class=\"line\">        style += &quot;width:&quot; + height + &quot;px;&quot;;// 注意旋转后的宽高切换</span><br><span class=\"line\">        style += &quot;height:&quot;+  width + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(90deg); transform: rotate(90deg);&quot;;</span><br><span class=\"line\">        // 注意旋转中点的处理</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    style += &quot;visibility: initial;&quot;;</span><br><span class=\"line\">    wrapper.style.cssText = style;</span><br><span class=\"line\">    $(&quot;#progress&quot;).addClass(&quot;animate-progress&quot;);</span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&quot;load&quot;, detectOrient, false);</span><br><span class=\"line\">window.addEventListener(&quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;, detectOrient, false);</span><br><span class=\"line\">detectOrient();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>转载至：<a href=\"https://blog.csdn.net/qq_36457584/article/details/80967278\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_36457584/article/details/80967278</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//注意设置*&#123;padding:0;margin:0;&#125; 不然有滚动条</span><br><span class=\"line\">/**</span><br><span class=\"line\">    * H5强制横屏</span><br><span class=\"line\">    * @param &#123;Object&#125;</span><br><span class=\"line\">    */   </span><br><span class=\"line\">var wrapper = document.getElementById(&quot;root&quot;);      </span><br><span class=\"line\">var mark = window.orientation == 90 || window.orientation == -90;    //初始角度</span><br><span class=\"line\">//不同角度宽高需要互换</span><br><span class=\"line\">var width = document.documentElement[mark ? &apos;clientHeight&apos; : &apos;clientWidth&apos;]; </span><br><span class=\"line\">var height = document.documentElement[mark ? &apos;clientWidth&apos; : &apos;clientHeight&apos;];                         </span><br><span class=\"line\">var detectOrient = function() &#123;</span><br><span class=\"line\">    var style = &quot;&quot;;                            </span><br><span class=\"line\">    if (window.orientation == 90 || window.orientation == -90) &#123; //横屏                             </span><br><span class=\"line\">        style += &quot;width:100%;&quot;; </span><br><span class=\"line\">        style += &quot;height:100%;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(0); transform: rotate(0);&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: 0 0;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: 0 0;&quot;;</span><br><span class=\"line\">    &#125; else if(window.orientation == 180 || window.orientation == 0)&#123; //竖屏                    </span><br><span class=\"line\">        style += &quot;width:&quot; + height + &quot;px;&quot;;// 注意旋转后的宽高切换</span><br><span class=\"line\">        style += &quot;height:&quot;+  width + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(90deg); transform: rotate(90deg);&quot;;</span><br><span class=\"line\">        // 注意旋转中点的处理</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    style += &quot;visibility: initial;&quot;;</span><br><span class=\"line\">    wrapper.style.cssText = style;</span><br><span class=\"line\">    $(&quot;#progress&quot;).addClass(&quot;animate-progress&quot;);</span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&quot;load&quot;, detectOrient, false);</span><br><span class=\"line\">window.addEventListener(&quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;, detectOrient, false);</span><br><span class=\"line\">detectOrient();</span><br></pre></td></tr></table></figure>"},{"title":"react Context(上下文方法使用)","date":"2019-03-29T06:41:51.000Z","_content":"\n> 使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件\n\n```\n//定义\nconst defaultValue = 'aaa';\nconst LocaleContext = React.createContext(defaultValue);\n\n//父组件\nclass LocaleProvider extends React.Component{\n    state = {\n        locale: defaultValue\n    }\n    render(){\n        return (\n            <LocaleContext.Provider value={this.state.locale}>\n                <button onClick={()=>this.setState({locale: 'bbb')})} >\n                    切换\n                </button>\n                {this.props.children]\n            </LocaleContext.Provider>\n        )\n    }\n}\n\n//子组件\nclass LocaledButtons extends React.Componet{\n    render(){\n        return (\n            <LocaleContext.Consumer>\n                {locale => (\n                    <div>\n                        <span>{locale}</span>\n                    </div>\n                }\n            </LocaleContext.Consumer>        \n        )\n    }\n}\n\n//实际使用\nexport default () => (\n    <LocaleProvider>\n        <LocaledButtons />\n    </LocaleProvider>\n)\n\n\n```\n","source":"_posts/react-Context-上下文方法使用.md","raw":"---\ntitle: react Context(上下文方法使用)\ndate: 2019-03-29 14:41:51\ntags: react\ncategories: 技术\n---\n\n> 使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件\n\n```\n//定义\nconst defaultValue = 'aaa';\nconst LocaleContext = React.createContext(defaultValue);\n\n//父组件\nclass LocaleProvider extends React.Component{\n    state = {\n        locale: defaultValue\n    }\n    render(){\n        return (\n            <LocaleContext.Provider value={this.state.locale}>\n                <button onClick={()=>this.setState({locale: 'bbb')})} >\n                    切换\n                </button>\n                {this.props.children]\n            </LocaleContext.Provider>\n        )\n    }\n}\n\n//子组件\nclass LocaledButtons extends React.Componet{\n    render(){\n        return (\n            <LocaleContext.Consumer>\n                {locale => (\n                    <div>\n                        <span>{locale}</span>\n                    </div>\n                }\n            </LocaleContext.Consumer>        \n        )\n    }\n}\n\n//实际使用\nexport default () => (\n    <LocaleProvider>\n        <LocaledButtons />\n    </LocaleProvider>\n)\n\n\n```\n","slug":"react-Context-上下文方法使用","published":1,"updated":"2019-10-23T10:30:36.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzj900081wek5nzhm0ja","content":"<blockquote>\n<p>使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">const defaultValue = &apos;aaa&apos;;</span><br><span class=\"line\">const LocaleContext = React.createContext(defaultValue);</span><br><span class=\"line\"></span><br><span class=\"line\">//父组件</span><br><span class=\"line\">class LocaleProvider extends React.Component&#123;</span><br><span class=\"line\">    state = &#123;</span><br><span class=\"line\">        locale: defaultValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Provider value=&#123;this.state.locale&#125;&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;locale: &apos;bbb&apos;)&#125;)&#125; &gt;</span><br><span class=\"line\">                    切换</span><br><span class=\"line\">                &lt;/button&gt;</span><br><span class=\"line\">                &#123;this.props.children]</span><br><span class=\"line\">            &lt;/LocaleContext.Provider&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子组件</span><br><span class=\"line\">class LocaledButtons extends React.Componet&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Consumer&gt;</span><br><span class=\"line\">                &#123;locale =&gt; (</span><br><span class=\"line\">                    &lt;div&gt;</span><br><span class=\"line\">                        &lt;span&gt;&#123;locale&#125;&lt;/span&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &lt;/LocaleContext.Consumer&gt;        </span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//实际使用</span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">    &lt;LocaleProvider&gt;</span><br><span class=\"line\">        &lt;LocaledButtons /&gt;</span><br><span class=\"line\">    &lt;/LocaleProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">const defaultValue = &apos;aaa&apos;;</span><br><span class=\"line\">const LocaleContext = React.createContext(defaultValue);</span><br><span class=\"line\"></span><br><span class=\"line\">//父组件</span><br><span class=\"line\">class LocaleProvider extends React.Component&#123;</span><br><span class=\"line\">    state = &#123;</span><br><span class=\"line\">        locale: defaultValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Provider value=&#123;this.state.locale&#125;&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;locale: &apos;bbb&apos;)&#125;)&#125; &gt;</span><br><span class=\"line\">                    切换</span><br><span class=\"line\">                &lt;/button&gt;</span><br><span class=\"line\">                &#123;this.props.children]</span><br><span class=\"line\">            &lt;/LocaleContext.Provider&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子组件</span><br><span class=\"line\">class LocaledButtons extends React.Componet&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Consumer&gt;</span><br><span class=\"line\">                &#123;locale =&gt; (</span><br><span class=\"line\">                    &lt;div&gt;</span><br><span class=\"line\">                        &lt;span&gt;&#123;locale&#125;&lt;/span&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &lt;/LocaleContext.Consumer&gt;        </span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//实际使用</span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">    &lt;LocaleProvider&gt;</span><br><span class=\"line\">        &lt;LocaledButtons /&gt;</span><br><span class=\"line\">    &lt;/LocaleProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n"},{"title":"forEach兼容写法","date":"2018-07-25T07:51:43.000Z","_content":"\n最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。\n\n最后在网上找到这段(兼容IE8)\n\n```\n\n    if ( !Array.prototype.forEach ) {\n        Array.prototype.forEach = function forEach( callback, thisArg ) {\n            var T, k;\n            if ( this == null ) {\n                throw new TypeError( \"this is null or not defined\" );\n            }\n            var O = Object(this);\n            var len = O.length >>> 0;\n            if ( typeof callback !== \"function\" ) {\n                throw new TypeError( callback + \" is not a function\" );\n            }\n            if ( arguments.length > 1 ) {\n                T = thisArg;\n            }\n            k = 0;\n            while( k < len ) {\n    \n                var kValue;\n                if ( k in O ) {\n                    kValue = O[ k ];\n                    callback.call( T, kValue, k, O );\n                }\n                k++;\n            }\n        };\n    }\n\n```\n","source":"_posts/forEach兼容写法.md","raw":"---\ntitle: forEach兼容写法\ndate: 2018-07-25 15:51:43\ntags: javaScript\ncategories: 技术\n---\n\n最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。\n\n最后在网上找到这段(兼容IE8)\n\n```\n\n    if ( !Array.prototype.forEach ) {\n        Array.prototype.forEach = function forEach( callback, thisArg ) {\n            var T, k;\n            if ( this == null ) {\n                throw new TypeError( \"this is null or not defined\" );\n            }\n            var O = Object(this);\n            var len = O.length >>> 0;\n            if ( typeof callback !== \"function\" ) {\n                throw new TypeError( callback + \" is not a function\" );\n            }\n            if ( arguments.length > 1 ) {\n                T = thisArg;\n            }\n            k = 0;\n            while( k < len ) {\n    \n                var kValue;\n                if ( k in O ) {\n                    kValue = O[ k ];\n                    callback.call( T, kValue, k, O );\n                }\n                k++;\n            }\n        };\n    }\n\n```\n","slug":"forEach兼容写法","published":1,"updated":"2019-10-21T06:40:59.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzjc000c1wekqeb8rq6n","content":"<p>最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。</p>\n<p>最后在网上找到这段(兼容IE8)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if ( !Array.prototype.forEach ) &#123;</span><br><span class=\"line\">    Array.prototype.forEach = function forEach( callback, thisArg ) &#123;</span><br><span class=\"line\">        var T, k;</span><br><span class=\"line\">        if ( this == null ) &#123;</span><br><span class=\"line\">            throw new TypeError( &quot;this is null or not defined&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var O = Object(this);</span><br><span class=\"line\">        var len = O.length &gt;&gt;&gt; 0;</span><br><span class=\"line\">        if ( typeof callback !== &quot;function&quot; ) &#123;</span><br><span class=\"line\">            throw new TypeError( callback + &quot; is not a function&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if ( arguments.length &gt; 1 ) &#123;</span><br><span class=\"line\">            T = thisArg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k = 0;</span><br><span class=\"line\">        while( k &lt; len ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            var kValue;</span><br><span class=\"line\">            if ( k in O ) &#123;</span><br><span class=\"line\">                kValue = O[ k ];</span><br><span class=\"line\">                callback.call( T, kValue, k, O );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。</p>\n<p>最后在网上找到这段(兼容IE8)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if ( !Array.prototype.forEach ) &#123;</span><br><span class=\"line\">    Array.prototype.forEach = function forEach( callback, thisArg ) &#123;</span><br><span class=\"line\">        var T, k;</span><br><span class=\"line\">        if ( this == null ) &#123;</span><br><span class=\"line\">            throw new TypeError( &quot;this is null or not defined&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var O = Object(this);</span><br><span class=\"line\">        var len = O.length &gt;&gt;&gt; 0;</span><br><span class=\"line\">        if ( typeof callback !== &quot;function&quot; ) &#123;</span><br><span class=\"line\">            throw new TypeError( callback + &quot; is not a function&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if ( arguments.length &gt; 1 ) &#123;</span><br><span class=\"line\">            T = thisArg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k = 0;</span><br><span class=\"line\">        while( k &lt; len ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            var kValue;</span><br><span class=\"line\">            if ( k in O ) &#123;</span><br><span class=\"line\">                kValue = O[ k ];</span><br><span class=\"line\">                callback.call( T, kValue, k, O );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckctvtzj500071wek0tyq6vov","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzje000d1wekykf2dk3e"},{"post_id":"ckctvtzig00001wekstb5te7h","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzji000g1wekui4m90t1"},{"post_id":"ckctvtzj900081wek5nzhm0ja","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzji000h1wekkxw16h2t"},{"post_id":"ckctvtzjc000c1wekqeb8rq6n","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzjk000j1wekp72ev8wt"},{"post_id":"ckctvtzip00021wekqviyz8gt","category_id":"ckctvtzja00091weks4qeceql","_id":"ckctvtzjl000l1weka7ugd6k4"},{"post_id":"ckctvtzix00061wekghpraedi","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzjm000o1wekjbokwphf"}],"PostTag":[{"post_id":"ckctvtzig00001wekstb5te7h","tag_id":"ckctvtziw00051wekusqz81mk","_id":"ckctvtzjc000b1weka61s6hiw"},{"post_id":"ckctvtzip00021wekqviyz8gt","tag_id":"ckctvtzjb000a1wek7rg8kmal","_id":"ckctvtzjk000k1wekhi1zlcv0"},{"post_id":"ckctvtzip00021wekqviyz8gt","tag_id":"ckctvtzjg000f1wekutqrxhf8","_id":"ckctvtzjl000m1wekg0v5oujq"},{"post_id":"ckctvtzix00061wekghpraedi","tag_id":"ckctvtzjg000f1wekutqrxhf8","_id":"ckctvtzjn000p1wekpuzhthfg"},{"post_id":"ckctvtzj500071wek0tyq6vov","tag_id":"ckctvtzjl000n1wek7pw7zbt4","_id":"ckctvtzjp000s1wekaic7iyya"},{"post_id":"ckctvtzj500071wek0tyq6vov","tag_id":"ckctvtzjo000q1wekgg7kl9k4","_id":"ckctvtzjp000t1wek0veqdd9w"},{"post_id":"ckctvtzj900081wek5nzhm0ja","tag_id":"ckctvtzjo000r1wekaf5u99ej","_id":"ckctvtzjq000v1wek9zt4cest"},{"post_id":"ckctvtzjc000c1wekqeb8rq6n","tag_id":"ckctvtzjl000n1wek7pw7zbt4","_id":"ckctvtzjq000w1wekibtkdhov"}],"Tag":[{"name":"HTML","_id":"ckctvtziw00051wekusqz81mk"},{"name":"心得","_id":"ckctvtzjb000a1wek7rg8kmal"},{"name":"文章","_id":"ckctvtzjg000f1wekutqrxhf8"},{"name":"javaScript","_id":"ckctvtzjl000n1wek7pw7zbt4"},{"name":"技巧","_id":"ckctvtzjo000q1wekgg7kl9k4"},{"name":"react","_id":"ckctvtzjo000r1wekaf5u99ej"}]}}