{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":1,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":1,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":1,"renderable":1},{"_id":"themes/archer/source/avatar/avatar.jpg","path":"avatar/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":1,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":1,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":1,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":1,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/archer/.gitignore","hash":"7e11730466038f7d81c67afdb7fb3c19bc4c0cc0","modified":1571822278666},{"_id":"themes/archer/.prettierrc.js","hash":"c77c76428fb4eefd727444d97fa2733a0c10286a","modified":1571627347543},{"_id":"themes/archer/.prettierignore","hash":"075b20da2bb3dfa7932394363d63d98cbb0b7042","modified":1571627347543},{"_id":"themes/archer/.eslintrc.json","hash":"5c79a54f29b1d32045e612fcb7379797d79ac380","modified":1571627347524},{"_id":"themes/archer/LICENSE","hash":"35f4fb806270f8243459c870a2141e795dfab166","modified":1571627347544},{"_id":"themes/archer/gulpfile.js","hash":"ba7c6a88298900460ddd1649300b5672956902f9","modified":1571627347551},{"_id":"themes/archer/README.md","hash":"e7ddbbdc5d5ec445a3bc99c684df83ae7783624c","modified":1571627347544},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1571627347525},{"_id":"themes/archer/webpack.prod.js","hash":"b6d35f7e9a9718b3e5e3e17c52fcc5e7c38330b0","modified":1571627347634},{"_id":"themes/archer/webpack.config.js","hash":"348da2932316c2789a3c0a3cf5efff0dd7cc4ffe","modified":1571627347634},{"_id":"source/_posts/使用hexo搭建博客时遇到的问题.md","hash":"cf2bfc3b325f1f2e86fb03a33a0077c546f93b5f","modified":1571819332030},{"_id":"source/_posts/BFC理解原理.md","hash":"ae3f76d0acb8924a11757486d40a71c6b9fd87be","modified":1594622992586},{"_id":"source/_posts/问题整理.md","hash":"36e1aeb08344107c49b0f1c0b989cbc4ce1efb92","modified":1595211636739},{"_id":"themes/archer/_config.yml","hash":"16fe0f9d1df246ec6a7bd8beaba0939e5a93e223","modified":1594622971945},{"_id":"source/_posts/react-Context-上下文方法使用.md","hash":"11c59f7331e01ce0a303696741b3fffa9a16971a","modified":1571826636031},{"_id":"themes/archer/dev/archer.sh","hash":"9474c501c1c55f47f02cccdd9e2039498ebc5e43","modified":1571627347546},{"_id":"source/_posts/让h5页面强制横屏.md","hash":"2782d6b6bac1f5537025c46b89774c505ff9e7f6","modified":1571816353440},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c10293eb8ccad5d02412a1369ec1c7e77516b929","modified":1571627347548},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"522434202e5e810b3c7f9591eb3a4451a4e485f0","modified":1571627347548},{"_id":"themes/archer/package.json","hash":"c07c94772d0e92e77788b0fe5beb3d44eb3c245f","modified":1571627347581},{"_id":"themes/archer/languages/default.yml","hash":"c6e36691ded2a5e5939c67bf3c47104664ea56c6","modified":1571627347552},{"_id":"themes/archer/languages/en.yml","hash":"de8fe8ad1967854586fee2214094c4992dd05278","modified":1571627347553},{"_id":"themes/archer/layout/404.ejs","hash":"a054b4ea1147846bed4252dd56182cb8e32d95eb","modified":1571627347554},{"_id":"themes/archer/layout/about.ejs","hash":"990df15653a99453617e72dfc195fa0a75b9a5d1","modified":1571627347575},{"_id":"source/_posts/forEach兼容写法.md","hash":"1c4553e5c888b5910e49b76e6b4886d3ea8b2be9","modified":1571640059114},{"_id":"themes/archer/layout/post.ejs","hash":"f14b49c920a3afe8d9aa4cb1d843faf43d07c72e","modified":1571627347577},{"_id":"themes/archer/layout/site-meta.ejs","hash":"a9d85607fc7da51bb9becff7fe2f07a8b4fbc915","modified":1571627347578},{"_id":"source/tags/index.md","hash":"13d75ba9b54990e92b96961571a6ef5b734885ec","modified":1553855424064},{"_id":"source/categories/index.md","hash":"c838304e0c43d4ed20d012943da53282d4e47eac","modified":1553855428103},{"_id":"themes/archer/layout/layout.ejs","hash":"fffd1188977f74d19e2f9d267d085dddc9c6778e","modified":1571627347577},{"_id":"themes/archer/layout/index.ejs","hash":"c9ae77cd8f7b862d23137a7b4eb5eb01b558ed33","modified":1571627347576},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"21765ec5abc9a65513e6bff57cb021d3b3852d35","modified":1571627347556},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"179a712ae139d8c5123338d9bd39d2b09c5ed2ce","modified":1571627347557},{"_id":"themes/archer/docs/README-en.md","hash":"e4fff6fc13f3296c2b168ab220f847192bf1273b","modified":1571627347547},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"065f8d6c4aae6782e6819815911f7feb6402a4ec","modified":1571627347560},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"af76b1a18a63934e83b078bf5f9f886e972a0ceb","modified":1571627347559},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"5dadba1c15454e25740982b59ef382686f3c6e51","modified":1571627347560},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"e1b4893af2b18f502bad1b552c3f3381ecc3021f","modified":1571627347561},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"92ac580acc20bde7b3345bfe132671b9043bfbd6","modified":1571627347561},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"fc03729825ac7ffd4045f910bbd936bc5841c65e","modified":1571627347569},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1571627347583},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1571627347583},{"_id":"themes/archer/source/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1571627347585},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"a90bd2b089b335b141a6a0d8dee9a9cde60fdc5b","modified":1571627347556},{"_id":"themes/archer/source/css/mobile.css","hash":"770d2ffb986a814c5e5662d28d2ec38864d8b1a0","modified":1571627347588},{"_id":"themes/archer/source/css/style.css","hash":"49f5d23b1e24e73016efdd8a6b70964a45a601db","modified":1571627347589},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"b343f5a4c8bba1c71f3229390ed83a8679c2f375","modified":1571627347559},{"_id":"themes/archer/source/assets/favicon.ico","hash":"d6d9068d1928f9f69ddb2772816fccc01c74cde5","modified":1571629259727},{"_id":"themes/archer/source/avatar/avatar.jpg","hash":"061fcb1e751dd9f2d73e9abe1a841b107f84e792","modified":1571628019948},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1571627347592},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1571627347593},{"_id":"themes/archer/source/scripts/search.js","hash":"d5f739e261e8ce74f993c6157b248663bda122bf","modified":1571627347608},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"6f18a92bbe8bed93113449ed6ff8d148c1e7565a","modified":1571627347606},{"_id":"themes/archer/src/js/fancybox.js","hash":"701720a4c56fb09d78ef3494fd3a88b4e2cde238","modified":1571627347611},{"_id":"themes/archer/source/scripts/share.js","hash":"bb5bb37ce7f47f8c084b232df3e5fe2378d7ca01","modified":1571627347609},{"_id":"themes/archer/src/js/initSidebar.js","hash":"e27d52b4ccb9502836570a0673f6b656f9ce3661","modified":1571627347612},{"_id":"themes/archer/src/js/browser.js","hash":"35ea55f62c0f251817c46da0153f70aec323be3d","modified":1571627347610},{"_id":"themes/archer/src/js/main.js","hash":"673e19867b5ecf65b0c9c6579d40be587d0e8211","modified":1571627347612},{"_id":"themes/archer/source/scripts/main.js","hash":"e89a9651131684204118fa74bd19cb781d76a372","modified":1571627347608},{"_id":"themes/archer/src/js/scroll.js","hash":"83f0885f2673234c911d84a56fcaaa020cdcc3e6","modified":1571627347614},{"_id":"themes/archer/src/js/init.js","hash":"0cf1eb883b87590a771b687431cc5180064d13cd","modified":1571627347611},{"_id":"themes/archer/src/js/sidebar.js","hash":"f2a5ec38766b3f48e3b043b84029f9da878d1c1a","modified":1571627347615},{"_id":"themes/archer/src/js/search.js","hash":"ef6533c876831377542a57f447550689144a6b71","modified":1571627347614},{"_id":"themes/archer/src/js/share.js","hash":"83a8ad056039cc673b939f47d69ad56337abc382","modified":1571627347615},{"_id":"themes/archer/src/js/tag.js","hash":"a868118bb0daf8902b63c48792797def36b9469a","modified":1571627347616},{"_id":"themes/archer/src/scss/_common.scss","hash":"05162d1562d4b141d9bad44c37b0b736371d8b08","modified":1571627347619},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"c6347bf137e80bb0c5b6368488ebd634c299016a","modified":1571627347619},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"fb6a1349bab25b65cf89b47e136d958d10947533","modified":1571627347620},{"_id":"themes/archer/src/scss/_variables.scss","hash":"2264c9b671643b3c64e002f968a75355e4091b61","modified":1571627347632},{"_id":"themes/archer/src/scss/mobile.scss","hash":"0a00e55e8b8d9551eed5966f53d8a6580b816dc5","modified":1571627347632},{"_id":"themes/archer/src/scss/style.scss","hash":"03bca94e57bc44723f8b73bb653f3e002b4b08a8","modified":1571627347633},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1571627347563},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1571627347591},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1571627347595},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1571627347597},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"0c3192b500a4fd550e483cf77a49806a5872185b","modified":1571627347606},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1571627347594},{"_id":"themes/archer/src/js/mobile.js","hash":"cfc37862242d5b7bd17028269436d3bc42e142e8","modified":1571627347613},{"_id":"themes/archer/src/js/toc.js","hash":"5c4db488dc2d80315064c6832eecfb39017a8104","modified":1571627347617},{"_id":"themes/archer/src/js/util.js","hash":"7bec5b1ff8ee91f58d084c47e0ed3908b27adef7","modified":1571627347617},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"244a4c71b862e6385a6de1e83a4975418a8c6fe7","modified":1571627347562},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"f1f785de72e1f7056da8fdb12c85523d20a0b6b0","modified":1571627347565},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"483c07212879b116b772f428547c9962be96d2ce","modified":1571627347567},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"cfdb15116abe89f4b54f7bb18a0b23a597c47a60","modified":1571627347563},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"c043a98e33252b9a628bfd31c4a3b2883dce2b99","modified":1571627347564},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"a6acb5d7778ade98ba5b6932e38a585460513f49","modified":1571627347564},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"9cd4798cdcd712cc01c9e797adbb4810649310d4","modified":1571627347568},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"4feb7c3d17a3c8994eb095d43d75fbd0f1ed5b4f","modified":1571627347574},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"4281841e5bbb5e1a83c3ebf6506dab057e1fe6b9","modified":1571627347570},{"_id":"themes/archer/package-lock.json","hash":"f3eae5d3878f7761231613b74be88173d3047c0c","modified":1571627347581},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"55c33bd49880ccaaa2f5d4dff44470886c3f3633","modified":1571627347621},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"08594f05f6ed238a7b79d48ebc1ff1e5c9deec46","modified":1571627347622},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"82a04b6ebb684a87f486cac8f08619ecb52605fd","modified":1571627347622},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"4d4713ec4b766a60577546af9f98eb721c4a63cd","modified":1571627347627},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1571627347551},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"c5ce643a06a2103aa4ac0d8279c024f90886d37f","modified":1571627347572},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1571627347600},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1571627347604},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"e96750b1aa7113322696857882b1e1fde11c1fc4","modified":1571627347575},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"e710acbc85e1cc5ae0e7ab5b5899837b9f222b97","modified":1571627347572},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"46d315718d86e9701573df2e39299895d8ca193c","modified":1571627347624},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"a1163d481627864e9dda441c4c356169cd33a3a1","modified":1571627347624},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"b3cf7523d8e91fce92cd6a118e308632047cc7b3","modified":1571627347625},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"1e4510959f51b5d4d3c5781468c77d25546ce905","modified":1571627347626},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"b6db1d4a29c34e1b834c54ca076b8084ceac4885","modified":1571627347626},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"c623385d72ce12fa403f5384ded79c3897d0fc9f","modified":1571627347627},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"30a3b9165c97bac6f6c795e598408639f5d9670a","modified":1571627347628},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"0691ca23bf6eabef65ff054c7710ec7432e4022c","modified":1571627347630},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"28b97b11f17d57a258747bb0facae0ad1911f9d5","modified":1571627347629},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b41904da65b1128510d28a57142298bfd844f7f5","modified":1571627347631},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1571627347602}],"Category":[{"name":"技术","_id":"ckctvtziv00041wek7qorz1br"},{"name":"记录","_id":"ckctvtzja00091weks4qeceql"}],"Data":[],"Page":[{"title":"标签","date":"2019-03-29T09:18:23.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-03-29 17:18:23\ntype: \"tags\" #新添加的内容\n\n---\n","updated":"2019-03-29T10:30:24.064Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckctvtzin00011wekkqdzzmvv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"文章分类","date":"2019-03-29T09:17:36.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-03-29 17:17:36\ntype: \"categories\"   #这部分是新添加的\n---\n","updated":"2019-03-29T10:30:28.103Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckctvtzit00031wek7uxcugxf","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"BFC理解原理","date":"2020-07-13T06:26:43.000Z","copyright":false,"_content":"\n## 一、常见定位方案\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n- 普通流 (normal flow)\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n- 浮动 (float)\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n- 绝对定位 (absolute positioning)\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n## 二、BFC 概念\n Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n\n那么 BFC 是什么呢？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n## 三、触发 BFC\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素\n- 浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n","source":"_posts/BFC理解原理.md","raw":"---\ntitle: BFC理解原理\ndate: 2020-07-13 14:26:43\ntags: HTML\ncategories: 技术\ncopyright: false\n---\n\n## 一、常见定位方案\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:\n\n- 普通流 (normal flow)\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n- 浮动 (float)\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n- 绝对定位 (absolute positioning)\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n## 二、BFC 概念\n Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n\n那么 BFC 是什么呢？\n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n## 三、触发 BFC\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n- body 根元素\n- 浮动元素：float 除 none 以外的值\n- 绝对定位元素：position (absolute、fixed)\n- display 为 inline-block、table-cells、flex\n- overflow 除了 visible 以外的值 (hidden、auto、scroll)\n","slug":"BFC理解原理","published":1,"updated":"2020-07-13T06:49:52.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzig00001wekstb5te7h","content":"<h2 id=\"一、常见定位方案\"><a href=\"#一、常见定位方案\" class=\"headerlink\" title=\"一、常见定位方案\"></a>一、常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<ul>\n<li>普通流 (normal flow)<blockquote>\n<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n</blockquote>\n</li>\n<li>浮动 (float)<blockquote>\n<p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n</blockquote>\n</li>\n<li>绝对定位 (absolute positioning)<blockquote>\n<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"二、BFC-概念\"><a href=\"#二、BFC-概念\" class=\"headerlink\" title=\"二、BFC 概念\"></a>二、BFC 概念</h2><p> Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p>那么 BFC 是什么呢？</p>\n<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p>\n<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>\n<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h2 id=\"三、触发-BFC\"><a href=\"#三、触发-BFC\" class=\"headerlink\" title=\"三、触发 BFC\"></a>三、触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素</li>\n<li>浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、常见定位方案\"><a href=\"#一、常见定位方案\" class=\"headerlink\" title=\"一、常见定位方案\"></a>一、常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p>\n<ul>\n<li>普通流 (normal flow)<blockquote>\n<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>\n</blockquote>\n</li>\n<li>浮动 (float)<blockquote>\n<p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>\n</blockquote>\n</li>\n<li>绝对定位 (absolute positioning)<blockquote>\n<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"二、BFC-概念\"><a href=\"#二、BFC-概念\" class=\"headerlink\" title=\"二、BFC 概念\"></a>二、BFC 概念</h2><p> Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<p>那么 BFC 是什么呢？</p>\n<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。</p>\n<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>\n<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h2 id=\"三、触发-BFC\"><a href=\"#三、触发-BFC\" class=\"headerlink\" title=\"三、触发 BFC\"></a>三、触发 BFC</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p>\n<ul>\n<li>body 根元素</li>\n<li>浮动元素：float 除 none 以外的值</li>\n<li>绝对定位元素：position (absolute、fixed)</li>\n<li>display 为 inline-block、table-cells、flex</li>\n<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>\n</ul>\n"},{"title":"使用hexo搭建博客时遇到的问题","date":"2018-07-13T09:45:51.000Z","_content":"\n\n花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。\n\n\n\n\n\n\n\n\n\n","source":"_posts/使用hexo搭建博客时遇到的问题.md","raw":"---\ntitle: 使用hexo搭建博客时遇到的问题\ndate: 2018-07-13 17:45:51\ntags: [心得,文章]\ncategories: 记录\n---\n\n\n花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。\n\n\n\n\n\n\n\n\n\n","slug":"使用hexo搭建博客时遇到的问题","published":1,"updated":"2019-10-23T08:28:52.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzip00021wekqviyz8gt","content":"<p>花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>花了一下午时间终于把这个博客弄好了，大概就是坑在hexo的教程版本不一样导致，最后卡在执行 hexo d 命令时提示没有权限，在网上找到了解决方法，.deploy_git 文件删除在执行就OK了。</p>\n"},{"title":"问题整理","date":"2020-07-13T08:00:14.000Z","copyright":false,"_content":"\n#### 介绍一下js的数据类型有哪些,值是如何存储的\n```\n一共有8种数据类型，7种基本数据类型\nString \nNumber \nBoolean \nNull \nUndefined \nSymbol（es6 新增类型，表示第一无二的值） \nBigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）\nObject（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）\n\n原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n\n引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n\n```\n### && 、 ||和!! 运算符分别能做什么\n```\n&& 并且符，使用时两边的值结果都必须为true才返回true\n|| 或者符，两边的值结果有一个为true最终判断结果就位true\n!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）\n\n```\n\n#### JS的数据类型的转换\n```\n在 JS 中类型转换只有三种情况，分别是：\n\n- 转换为布尔值（调用Boolean()方法）\n- 转换为数字（调用Number()、parseInt()和parseFloat()方法）\n- 转换为字符串（调用.toString()或者String()方法）\n\nnull和underfined没有.toString方法\n\n```\n![image](https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n#### JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()   \n>（1）typeof\n```\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object\n\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof\n```\n>（2）instanceof \n```\n//重点\ninstanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断\ninstanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。\n其意思就是判断对象是否是某一数据类型（如Array）的实例\n\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true    \n// console.log(undefined instanceof Undefined);      //报错\n// console.log(null instanceof Null);                //报错\n复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。\n我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，'str'不是实例，所以判断值为false。\n```\n>（3）constructor\n```\nconsole.log((2).constructor === Number); // true\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() {}).constructor === Function); // true\nconsole.log(({}).constructor === Object); // true\n\n这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了\n\nfunction Fn(){};\n \nFn.prototype=new Array();\n \nvar f=new Fn();\n \nconsole.log(f.constructor===Fn);    // false\nconsole.log(f.constructor===Array); // true\n```\n>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法\n```\nvar a = Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call('str'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n```\n#### 介绍 JS 有哪些内置对象？\n```\n全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在\n全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n\n标准内置对象的分类\n\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。\n\n例如 Infinity、NaN、undefined、null 字面量\n\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n\n例如 eval()、parseFloat()、parseInt() 等\n\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。\n\n例如 Object、Function、Boolean、Symbol、Error 等\n\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。\n\n例如 Number、Math、Date\n\n（5）字符串，用来表示和操作字符串的对象。\n\n例如 String、RegExp\n\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。\n\n例如 Map、Set、WeakMap、WeakSet\n\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。\n\n例如 SIMD 等\n\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。\n\n例如 JSON 等\n\n（10）控制抽象对象\n\n例如 Promise、Generator 等\n\n（11）反射\n\n例如 Reflect、Proxy\n\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。\n\n例如 Intl、Intl.Collator 等\n\n（13）WebAssembly\n\n（14）其他\n\n例如 arguments\n```\n\n#### undefined 与 undeclared 的区别？\n```\n已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。\n对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ\neof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 \"undefined\"。\n\n```\n\n#### null 和 undefined 的区别？\n```\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，\nnull 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null\n主要用于赋值给一些可能会返回对象的变量，作为初始化。\n/*\n    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，\n    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。\n    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\n*/\nundefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它\n会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等\n号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n\n```\n\n#### {}和[]的valueOf和toString的结果是什么？\n```\n{} 的 valueOf 结果为 {} ，toString 的结果为 \"[object Object]\"\n\n[] 的 valueOf 结果为 [] ，toString 的结果为 \"\"\n```\n\n#### Javascript 的作用域和作用域链？\n```\n【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。\n【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。\n\n\n```\n#### javascript 创建对象的几种方式？\n```\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n\n\n```\n\n#### JavaScript 继承的几种实现方式？\n```\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。\n\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。\n\n```\n\n#### 寄生式组合继承的实现？\n```\nPerson\nStudent\n\nfunction Person(name){\n    this.name = name;\n}\n\nPerson.prototype.sayName = function(){\n    console.log(123);\n}\n\nfunction Student(name, grade){\n    Person.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\nStudent.prototype.sayMyGrade = function() {\n  console.log(\"My grade is \" + this.grade + \".\");\n  \n}\n\n```\n\n#### 谈谈你对this、call、apply和bind的理解\n```\n总结:\n1. 在浏览器里，在全局范围内this 指向window对象；\n2. 在函数中，this永远指向最后调用他的那个对象；\n3. 构造函数中，this指向new出来的那个新的对象；\n4. call、apply、bind中的this被强绑定在指定的那个对象上；\n5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；\n6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。\n\n区别:\n- call/apply改变了函数的this上下文后马上执行该函数\n- bind则是返回改变了上下文后的函数,不执行该函数\n```\n\n\n\n#### JavaScript 原型，原型链？ 有什么特点？\n```\nprototype就是JS的原型，里面可以定义属性和方法\n当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。\n原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。\n\n```\n\n#### js 获取原型的方法？\n```\np.proto\np.constructor.prototype\nObject.getPrototypeOf(p)\n```\n\n#### 什么是闭包，为什么要用它？\n```\n闭包是指有权访问另一个函数作用域内变量的函数\n创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。\n\n闭包有两个常用的用途:\n- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\nfunction a(){\n    var n = 0;\n    function add(){\n       n++;\n       console.log(n);\n    }\n    return add;\n}\nvar a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；\na1();    //1\na1();    //2  第二次调用n变量还在内存中\n\n其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。\n\n```\n\n#### 什么是 DOM 和 BOM？\n```\nDOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。\n\nBOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM\n的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）\n对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati\non 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对\n象的子对象。\n\n```\n\n#### 三种事件模型是什么？\n```\nDOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。\nIE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\nDOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n```\n\n#### 事件委托是什么？\n```\n事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到\n目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。\n使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。\n\n```\n\n#### 什么是事件传播?\n```\n当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。\n事件传播有三个阶段：\n1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。\n2. 目标阶段–事件已达到目标元素。\n3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。\n\n\n```\n\n#### 什么是事件捕获？\n```\n当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----> document----> html----> body ---->目标元素\n\nhtml:\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\njs:\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\n\n\n\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。\n\n\n```\n\n#### 什么是事件冒泡？\n```\n事件冒泡刚好与事件捕获相反，当前元素---->body ----> html---->document ---->window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。\n假设有如下的 HTML 结构：\n\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\n对应的JS代码：\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。\n\n\n```\n\n#### DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\n（1）创建新节点\n```\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n```\n（2）添加、移除、替换、插入\n```\nappendChild(node)\nremoveChild(node)\nreplaceChild(new,old)\ninsertBefore(new,old)\n```\n（3）查找\n```\ngetElementById();\ngetElementsByName();\ngetElementsByTagName();\ngetElementsByClassName();\nquerySelector();\nquerySelectorAll();\n```\n（4）属性操作\n```\ngetAttribute(key);\nsetAttribute(key, value);\nhasAttribute(key);\nremoveAttribute(key);\n```\n\n####  js数组和对象有哪些原生方法,列举一下\n[image](https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n```\n\n```\n\n#### 常用的正则表达式\n\n#### Ajax 是什么? 如何创建一个 Ajax？\n\n#### js 延迟加载的方式有哪些？\n\n#### 谈谈你对模块化开发的理解？\n\n####  js 的几种模块规范？\n\n#### AMD和CMD 规范的区别？\n\n#### ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\n\n#### requireJS的核心原理是什么？ 33. 谈谈JS的运行机制\n\n#### arguments 的对象是什么？\n\n#### 为什么在调用这个函数时，代码中的b会变成一个全局变量?\n\n#### 简单介绍一下V8引擎的垃圾回收机制\n\n#### 哪些操作会造成内存泄漏？ 38. ECMAScript 是什么？\n\n#### ECMAScript 2015（ES6）有哪些新特性？\n\n#### var,let和const的区别是什么？\n\n#### 什么是箭头函数？\n\n#### 什么是类？\n\n#### 什么是模板字符串？\n\n#### 什么是对象解构？\n\n#### 什么是Set对象，它是如何工作的？\n\n#### 什么是Proxy？\n\n#### 写一个通用的事件侦听器函数，为什么要用它？\n\n#### 什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\n\n#### 什么是高阶函数？\n\n#### 为什么函数被称为一等公民？\n\n#### 手动实现Array.prototype.map 方法\n\n#### 手动实现Array.prototype.filter方法\n\n#### 手动实现Array.prototype.reduce方法\n\n#### js的深浅拷贝\n\n#### 手写call、apply及bind函数\n\n#### 函数柯里化的实现\n\n#### js模拟new操作符的实现\n\n#### 什么是回调函数？回调函数有什么缺点\n\n#### Promise是什么，可以手写实现一下吗？\n\n#### Iterator是什么，有什么作用？\n\n#### Generator函数是什么，有什么作用？\n\n#### 什么是 async/await及其如何工作,有什么优缺点？\n\n#### instanceof的原理是什么，如何实现\n\n#### js的节流与防抖\n\n#### 什么是设计模式？\n\n#### 9种前端常见的设计模式\n\n\n\n","source":"_posts/问题整理.md","raw":"---\ntitle: 问题整理\ndate: 2020-07-13 16:00:14\ntags: 文章\ncategories: 技术\ncopyright: false\n---\n\n#### 介绍一下js的数据类型有哪些,值是如何存储的\n```\n一共有8种数据类型，7种基本数据类型\nString \nNumber \nBoolean \nNull \nUndefined \nSymbol（es6 新增类型，表示第一无二的值） \nBigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）\nObject（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）\n\n原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n\n引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n\n```\n### && 、 ||和!! 运算符分别能做什么\n```\n&& 并且符，使用时两边的值结果都必须为true才返回true\n|| 或者符，两边的值结果有一个为true最终判断结果就位true\n!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）\n\n```\n\n#### JS的数据类型的转换\n```\n在 JS 中类型转换只有三种情况，分别是：\n\n- 转换为布尔值（调用Boolean()方法）\n- 转换为数字（调用Number()、parseInt()和parseFloat()方法）\n- 转换为字符串（调用.toString()或者String()方法）\n\nnull和underfined没有.toString方法\n\n```\n![image](https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n#### JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()   \n>（1）typeof\n```\ntypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object\n\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof\n```\n>（2）instanceof \n```\n//重点\ninstanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断\ninstanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。\n其意思就是判断对象是否是某一数据类型（如Array）的实例\n\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true    \n// console.log(undefined instanceof Undefined);      //报错\n// console.log(null instanceof Null);                //报错\n复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。\n我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，'str'不是实例，所以判断值为false。\n```\n>（3）constructor\n```\nconsole.log((2).constructor === Number); // true\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() {}).constructor === Function); // true\nconsole.log(({}).constructor === Object); // true\n\n这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了\n\nfunction Fn(){};\n \nFn.prototype=new Array();\n \nvar f=new Fn();\n \nconsole.log(f.constructor===Fn);    // false\nconsole.log(f.constructor===Array); // true\n```\n>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法\n```\nvar a = Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call('str'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n```\n#### 介绍 JS 有哪些内置对象？\n```\n全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在\n全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n\n标准内置对象的分类\n\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。\n\n例如 Infinity、NaN、undefined、null 字面量\n\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n\n例如 eval()、parseFloat()、parseInt() 等\n\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。\n\n例如 Object、Function、Boolean、Symbol、Error 等\n\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。\n\n例如 Number、Math、Date\n\n（5）字符串，用来表示和操作字符串的对象。\n\n例如 String、RegExp\n\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。\n\n例如 Map、Set、WeakMap、WeakSet\n\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。\n\n例如 SIMD 等\n\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。\n\n例如 JSON 等\n\n（10）控制抽象对象\n\n例如 Promise、Generator 等\n\n（11）反射\n\n例如 Reflect、Proxy\n\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。\n\n例如 Intl、Intl.Collator 等\n\n（13）WebAssembly\n\n（14）其他\n\n例如 arguments\n```\n\n#### undefined 与 undeclared 的区别？\n```\n已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。\n对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ\neof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 \"undefined\"。\n\n```\n\n#### null 和 undefined 的区别？\n```\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，\nnull 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null\n主要用于赋值给一些可能会返回对象的变量，作为初始化。\n/*\n    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，\n    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。\n    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。\n*/\nundefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它\n会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等\n号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n\n```\n\n#### {}和[]的valueOf和toString的结果是什么？\n```\n{} 的 valueOf 结果为 {} ，toString 的结果为 \"[object Object]\"\n\n[] 的 valueOf 结果为 [] ，toString 的结果为 \"\"\n```\n\n#### Javascript 的作用域和作用域链？\n```\n【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。\n【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。\n\n\n```\n#### javascript 创建对象的几种方式？\n```\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n\n\n```\n\n#### JavaScript 继承的几种实现方式？\n```\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。\n\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。\n\n```\n\n#### 寄生式组合继承的实现？\n```\nPerson\nStudent\n\nfunction Person(name){\n    this.name = name;\n}\n\nPerson.prototype.sayName = function(){\n    console.log(123);\n}\n\nfunction Student(name, grade){\n    Person.call(this,name);\n    this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\nStudent.prototype.sayMyGrade = function() {\n  console.log(\"My grade is \" + this.grade + \".\");\n  \n}\n\n```\n\n#### 谈谈你对this、call、apply和bind的理解\n```\n总结:\n1. 在浏览器里，在全局范围内this 指向window对象；\n2. 在函数中，this永远指向最后调用他的那个对象；\n3. 构造函数中，this指向new出来的那个新的对象；\n4. call、apply、bind中的this被强绑定在指定的那个对象上；\n5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；\n6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。\n\n区别:\n- call/apply改变了函数的this上下文后马上执行该函数\n- bind则是返回改变了上下文后的函数,不执行该函数\n```\n\n\n\n#### JavaScript 原型，原型链？ 有什么特点？\n```\nprototype就是JS的原型，里面可以定义属性和方法\n当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。\n原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。\n\n```\n\n#### js 获取原型的方法？\n```\np.proto\np.constructor.prototype\nObject.getPrototypeOf(p)\n```\n\n#### 什么是闭包，为什么要用它？\n```\n闭包是指有权访问另一个函数作用域内变量的函数\n创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。\n\n闭包有两个常用的用途:\n- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\nfunction a(){\n    var n = 0;\n    function add(){\n       n++;\n       console.log(n);\n    }\n    return add;\n}\nvar a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；\na1();    //1\na1();    //2  第二次调用n变量还在内存中\n\n其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。\n\n```\n\n#### 什么是 DOM 和 BOM？\n```\nDOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。\n\nBOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM\n的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）\n对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati\non 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对\n象的子对象。\n\n```\n\n#### 三种事件模型是什么？\n```\nDOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。\nIE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\nDOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n```\n\n#### 事件委托是什么？\n```\n事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到\n目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。\n使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。\n\n```\n\n#### 什么是事件传播?\n```\n当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。\n事件传播有三个阶段：\n1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。\n2. 目标阶段–事件已达到目标元素。\n3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。\n\n\n```\n\n#### 什么是事件捕获？\n```\n当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----> document----> html----> body ---->目标元素\n\nhtml:\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\njs:\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\n\n\n\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。\n\n\n```\n\n#### 什么是事件冒泡？\n```\n事件冒泡刚好与事件捕获相反，当前元素---->body ----> html---->document ---->window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。\n假设有如下的 HTML 结构：\n\n<div class=\"grandparent\">\n  <div class=\"parent\">\n    <div class=\"child\">1</div>\n  </div>\n</div>\n\n对应的JS代码：\nfunction addEvent(el, event, callback, isCapture = false) {\n  if (!el || !event || !callback || typeof callback !== 'function') return;\n  if (typeof el === 'string') {\n    el = document.querySelector(el);\n  };\n  el.addEventListener(event, callback, isCapture);\n}\n\naddEvent(document, 'DOMContentLoaded', () => {\n  const child = document.querySelector('.child');\n  const parent = document.querySelector('.parent');\n  const grandparent = document.querySelector('.grandparent');\n\n  addEvent(child, 'click', function (e) {\n    console.log('child');\n  });\n\n  addEvent(parent, 'click', function (e) {\n    console.log('parent');\n  });\n\n  addEvent(grandparent, 'click', function (e) {\n    console.log('grandparent');\n  });\n\n  addEvent(document, 'click', function (e) {\n    console.log('document');\n  });\n\n  addEvent('html', 'click', function (e) {\n    console.log('html');\n  })\n\n  addEvent(window, 'click', function (e) {\n    console.log('window');\n  })\n\n});\n\naddEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。\n\n\n```\n\n#### DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\n（1）创建新节点\n```\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n```\n（2）添加、移除、替换、插入\n```\nappendChild(node)\nremoveChild(node)\nreplaceChild(new,old)\ninsertBefore(new,old)\n```\n（3）查找\n```\ngetElementById();\ngetElementsByName();\ngetElementsByTagName();\ngetElementsByClassName();\nquerySelector();\nquerySelectorAll();\n```\n（4）属性操作\n```\ngetAttribute(key);\nsetAttribute(key, value);\nhasAttribute(key);\nremoveAttribute(key);\n```\n\n####  js数组和对象有哪些原生方法,列举一下\n[image](https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n```\n\n```\n\n#### 常用的正则表达式\n\n#### Ajax 是什么? 如何创建一个 Ajax？\n\n#### js 延迟加载的方式有哪些？\n\n#### 谈谈你对模块化开发的理解？\n\n####  js 的几种模块规范？\n\n#### AMD和CMD 规范的区别？\n\n#### ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\n\n#### requireJS的核心原理是什么？ 33. 谈谈JS的运行机制\n\n#### arguments 的对象是什么？\n\n#### 为什么在调用这个函数时，代码中的b会变成一个全局变量?\n\n#### 简单介绍一下V8引擎的垃圾回收机制\n\n#### 哪些操作会造成内存泄漏？ 38. ECMAScript 是什么？\n\n#### ECMAScript 2015（ES6）有哪些新特性？\n\n#### var,let和const的区别是什么？\n\n#### 什么是箭头函数？\n\n#### 什么是类？\n\n#### 什么是模板字符串？\n\n#### 什么是对象解构？\n\n#### 什么是Set对象，它是如何工作的？\n\n#### 什么是Proxy？\n\n#### 写一个通用的事件侦听器函数，为什么要用它？\n\n#### 什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\n\n#### 什么是高阶函数？\n\n#### 为什么函数被称为一等公民？\n\n#### 手动实现Array.prototype.map 方法\n\n#### 手动实现Array.prototype.filter方法\n\n#### 手动实现Array.prototype.reduce方法\n\n#### js的深浅拷贝\n\n#### 手写call、apply及bind函数\n\n#### 函数柯里化的实现\n\n#### js模拟new操作符的实现\n\n#### 什么是回调函数？回调函数有什么缺点\n\n#### Promise是什么，可以手写实现一下吗？\n\n#### Iterator是什么，有什么作用？\n\n#### Generator函数是什么，有什么作用？\n\n#### 什么是 async/await及其如何工作,有什么优缺点？\n\n#### instanceof的原理是什么，如何实现\n\n#### js的节流与防抖\n\n#### 什么是设计模式？\n\n#### 9种前端常见的设计模式\n\n\n\n","slug":"问题整理","published":1,"updated":"2020-07-20T02:20:36.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzix00061wekghpraedi","content":"<h4 id=\"介绍一下js的数据类型有哪些-值是如何存储的\"><a href=\"#介绍一下js的数据类型有哪些-值是如何存储的\" class=\"headerlink\" title=\"介绍一下js的数据类型有哪些,值是如何存储的\"></a>介绍一下js的数据类型有哪些,值是如何存储的</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一共有8种数据类型，7种基本数据类型</span><br><span class=\"line\">String </span><br><span class=\"line\">Number </span><br><span class=\"line\">Boolean </span><br><span class=\"line\">Null </span><br><span class=\"line\">Undefined </span><br><span class=\"line\">Symbol（es6 新增类型，表示第一无二的值） </span><br><span class=\"line\">BigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）</span><br><span class=\"line\">Object（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）</span><br><span class=\"line\"></span><br><span class=\"line\">原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class=\"line\"></span><br><span class=\"line\">引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure>\n<h3 id=\"amp-amp-、-和-运算符分别能做什么\"><a href=\"#amp-amp-、-和-运算符分别能做什么\" class=\"headerlink\" title=\"&amp;&amp; 、 ||和!! 运算符分别能做什么\"></a>&amp;&amp; 、 ||和!! 运算符分别能做什么</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;&amp; 并且符，使用时两边的值结果都必须为true才返回true</span><br><span class=\"line\">|| 或者符，两边的值结果有一个为true最终判断结果就位true</span><br><span class=\"line\">!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）</span><br></pre></td></tr></table></figure>\n<h4 id=\"JS的数据类型的转换\"><a href=\"#JS的数据类型的转换\" class=\"headerlink\" title=\"JS的数据类型的转换\"></a>JS的数据类型的转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在 JS 中类型转换只有三种情况，分别是：</span><br><span class=\"line\"></span><br><span class=\"line\">- 转换为布尔值（调用Boolean()方法）</span><br><span class=\"line\">- 转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class=\"line\">- 转换为字符串（调用.toString()或者String()方法）</span><br><span class=\"line\"></span><br><span class=\"line\">null和underfined没有.toString方法</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h4 id=\"JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\"><a href=\"#JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\" class=\"headerlink\" title=\"JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()\"></a>JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()</h4><blockquote>\n<p>（1）typeof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typeof 对于原始类型来说，除了 null 都可以显示正确的类型</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof 2);               // number</span><br><span class=\"line\">console.log(typeof true);            // boolean</span><br><span class=\"line\">console.log(typeof &apos;str&apos;);           // string</span><br><span class=\"line\">console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object</span><br><span class=\"line\">console.log(typeof function()&#123;&#125;);    // function</span><br><span class=\"line\">console.log(typeof &#123;&#125;);              // object</span><br><span class=\"line\">console.log(typeof undefined);       // undefined</span><br><span class=\"line\">console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object</span><br><span class=\"line\"></span><br><span class=\"line\">typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（2）instanceof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//重点</span><br><span class=\"line\">instanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断</span><br><span class=\"line\">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class=\"line\">其意思就是判断对象是否是某一数据类型（如Array）的实例</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(2 instanceof Number);                    // false</span><br><span class=\"line\">console.log(true instanceof Boolean);                // false </span><br><span class=\"line\">console.log(&apos;str&apos; instanceof String);                // false  </span><br><span class=\"line\">console.log([] instanceof Array);                    // true</span><br><span class=\"line\">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class=\"line\">console.log(&#123;&#125; instanceof Object);                   // true    </span><br><span class=\"line\">// console.log(undefined instanceof Undefined);      //报错</span><br><span class=\"line\">// console.log(null instanceof Null);                //报错</span><br><span class=\"line\">复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。</span><br><span class=\"line\">我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，&apos;str&apos;不是实例，所以判断值为false。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（3）constructor<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log((2).constructor === Number); // true</span><br><span class=\"line\">console.log((true).constructor === Boolean); // true</span><br><span class=\"line\">console.log((&apos;str&apos;).constructor === String); // true</span><br><span class=\"line\">console.log(([]).constructor === Array); // true</span><br><span class=\"line\">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class=\"line\">console.log((&#123;&#125;).constructor === Object); // true</span><br><span class=\"line\"></span><br><span class=\"line\">这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了</span><br><span class=\"line\"></span><br><span class=\"line\">function Fn()&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">Fn.prototype=new Array();</span><br><span class=\"line\"> </span><br><span class=\"line\">var f=new Fn();</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(f.constructor===Fn);    // false</span><br><span class=\"line\">console.log(f.constructor===Array); // true</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = Object.prototype.toString;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(a.call(2));</span><br><span class=\"line\">console.log(a.call(true));</span><br><span class=\"line\">console.log(a.call(&apos;str&apos;));</span><br><span class=\"line\">console.log(a.call([]));</span><br><span class=\"line\">console.log(a.call(function()&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(undefined));</span><br><span class=\"line\">console.log(a.call(null));</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"介绍-JS-有哪些内置对象？\"><a href=\"#介绍-JS-有哪些内置对象？\" class=\"headerlink\" title=\"介绍 JS 有哪些内置对象？\"></a>介绍 JS 有哪些内置对象？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class=\"line\">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class=\"line\"></span><br><span class=\"line\">标准内置对象的分类</span><br><span class=\"line\"></span><br><span class=\"line\">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Infinity、NaN、undefined、null 字面量</span><br><span class=\"line\"></span><br><span class=\"line\">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 eval()、parseFloat()、parseInt() 等</span><br><span class=\"line\"></span><br><span class=\"line\">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class=\"line\"></span><br><span class=\"line\">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Number、Math、Date</span><br><span class=\"line\"></span><br><span class=\"line\">（5）字符串，用来表示和操作字符串的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 String、RegExp</span><br><span class=\"line\"></span><br><span class=\"line\">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class=\"line\"></span><br><span class=\"line\">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Map、Set、WeakMap、WeakSet</span><br><span class=\"line\"></span><br><span class=\"line\">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 SIMD 等</span><br><span class=\"line\"></span><br><span class=\"line\">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 JSON 等</span><br><span class=\"line\"></span><br><span class=\"line\">（10）控制抽象对象</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Promise、Generator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（11）反射</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Reflect、Proxy</span><br><span class=\"line\"></span><br><span class=\"line\">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Intl、Intl.Collator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（13）WebAssembly</span><br><span class=\"line\"></span><br><span class=\"line\">（14）其他</span><br><span class=\"line\"></span><br><span class=\"line\">例如 arguments</span><br></pre></td></tr></table></figure>\n<h4 id=\"undefined-与-undeclared-的区别？\"><a href=\"#undefined-与-undeclared-的区别？\" class=\"headerlink\" title=\"undefined 与 undeclared 的区别？\"></a>undefined 与 undeclared 的区别？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。</span><br><span class=\"line\">对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ</span><br><span class=\"line\">eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</span><br></pre></td></tr></table></figure>\n<h4 id=\"null-和-undefined-的区别？\"><a href=\"#null-和-undefined-的区别？\" class=\"headerlink\" title=\"null 和 undefined 的区别？\"></a>null 和 undefined 的区别？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class=\"line\">undefined 代表的含义是未定义，</span><br><span class=\"line\">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class=\"line\">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class=\"line\">/*</span><br><span class=\"line\">    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，</span><br><span class=\"line\">    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class=\"line\">    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</span><br><span class=\"line\">*/</span><br><span class=\"line\">undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它</span><br><span class=\"line\">会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</span><br><span class=\"line\">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等</span><br><span class=\"line\">号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>\n<h4 id=\"和-的valueOf和toString的结果是什么？\"><a href=\"#和-的valueOf和toString的结果是什么？\" class=\"headerlink\" title=\"{}和[]的valueOf和toString的结果是什么？\"></a>{}和[]的valueOf和toString的结果是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Javascript-的作用域和作用域链？\"><a href=\"#Javascript-的作用域和作用域链？\" class=\"headerlink\" title=\"Javascript 的作用域和作用域链？\"></a>Javascript 的作用域和作用域链？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class=\"line\">【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</span><br></pre></td></tr></table></figure>\n<h4 id=\"javascript-创建对象的几种方式？\"><a href=\"#javascript-创建对象的几种方式？\" class=\"headerlink\" title=\"javascript 创建对象的几种方式？\"></a>javascript 创建对象的几种方式？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>\n<h4 id=\"JavaScript-继承的几种实现方式？\"><a href=\"#JavaScript-继承的几种实现方式？\" class=\"headerlink\" title=\"JavaScript 继承的几种实现方式？\"></a>JavaScript 继承的几种实现方式？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</span><br></pre></td></tr></table></figure>\n<h4 id=\"寄生式组合继承的实现？\"><a href=\"#寄生式组合继承的实现？\" class=\"headerlink\" title=\"寄生式组合继承的实现？\"></a>寄生式组合继承的实现？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person</span><br><span class=\"line\">Student</span><br><span class=\"line\"></span><br><span class=\"line\">function Person(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Student(name, grade)&#123;</span><br><span class=\"line\">    Person.call(this,name);</span><br><span class=\"line\">    this.grade = grade;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype = Object.create(Person.prototype);</span><br><span class=\"line\">Student.prototype.constructor = Student;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.sayMyGrade = function() &#123;</span><br><span class=\"line\">  console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"谈谈你对this、call、apply和bind的理解\"><a href=\"#谈谈你对this、call、apply和bind的理解\" class=\"headerlink\" title=\"谈谈你对this、call、apply和bind的理解\"></a>谈谈你对this、call、apply和bind的理解</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结:</span><br><span class=\"line\">1. 在浏览器里，在全局范围内this 指向window对象；</span><br><span class=\"line\">2. 在函数中，this永远指向最后调用他的那个对象；</span><br><span class=\"line\">3. 构造函数中，this指向new出来的那个新的对象；</span><br><span class=\"line\">4. call、apply、bind中的this被强绑定在指定的那个对象上；</span><br><span class=\"line\">5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</span><br><span class=\"line\">6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</span><br><span class=\"line\"></span><br><span class=\"line\">区别:</span><br><span class=\"line\">- call/apply改变了函数的this上下文后马上执行该函数</span><br><span class=\"line\">- bind则是返回改变了上下文后的函数,不执行该函数</span><br></pre></td></tr></table></figure>\n<h4 id=\"JavaScript-原型，原型链？-有什么特点？\"><a href=\"#JavaScript-原型，原型链？-有什么特点？\" class=\"headerlink\" title=\"JavaScript 原型，原型链？ 有什么特点？\"></a>JavaScript 原型，原型链？ 有什么特点？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">prototype就是JS的原型，里面可以定义属性和方法</span><br><span class=\"line\">当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。</span><br><span class=\"line\">原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br></pre></td></tr></table></figure>\n<h4 id=\"js-获取原型的方法？\"><a href=\"#js-获取原型的方法？\" class=\"headerlink\" title=\"js 获取原型的方法？\"></a>js 获取原型的方法？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p.proto</span><br><span class=\"line\">p.constructor.prototype</span><br><span class=\"line\">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是闭包，为什么要用它？\"><a href=\"#什么是闭包，为什么要用它？\" class=\"headerlink\" title=\"什么是闭包，为什么要用它？\"></a>什么是闭包，为什么要用它？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">闭包是指有权访问另一个函数作用域内变量的函数</span><br><span class=\"line\">创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。</span><br><span class=\"line\"></span><br><span class=\"line\">闭包有两个常用的用途:</span><br><span class=\"line\">- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class=\"line\">- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</span><br><span class=\"line\"></span><br><span class=\"line\">function a()&#123;</span><br><span class=\"line\">    var n = 0;</span><br><span class=\"line\">    function add()&#123;</span><br><span class=\"line\">       n++;</span><br><span class=\"line\">       console.log(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span><br><span class=\"line\">a1();    //1</span><br><span class=\"line\">a1();    //2  第二次调用n变量还在内存中</span><br><span class=\"line\"></span><br><span class=\"line\">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是-DOM-和-BOM？\"><a href=\"#什么是-DOM-和-BOM？\" class=\"headerlink\" title=\"什么是 DOM 和 BOM？\"></a>什么是 DOM 和 BOM？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class=\"line\"></span><br><span class=\"line\">BOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM</span><br><span class=\"line\">的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）</span><br><span class=\"line\">对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati</span><br><span class=\"line\">on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对</span><br><span class=\"line\">象的子对象。</span><br></pre></td></tr></table></figure>\n<h4 id=\"三种事件模型是什么？\"><a href=\"#三种事件模型是什么？\" class=\"headerlink\" title=\"三种事件模型是什么？\"></a>三种事件模型是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class=\"line\">IE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class=\"line\">DOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure>\n<h4 id=\"事件委托是什么？\"><a href=\"#事件委托是什么？\" class=\"headerlink\" title=\"事件委托是什么？\"></a>事件委托是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class=\"line\">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class=\"line\">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是事件传播\"><a href=\"#什么是事件传播\" class=\"headerlink\" title=\"什么是事件传播?\"></a>什么是事件传播?</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。</span><br><span class=\"line\">事件传播有三个阶段：</span><br><span class=\"line\">1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class=\"line\">2. 目标阶段–事件已达到目标元素。</span><br><span class=\"line\">3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是事件捕获？\"><a href=\"#什么是事件捕获？\" class=\"headerlink\" title=\"什么是事件捕获？\"></a>什么是事件捕获？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----&gt; document----&gt; html----&gt; body ----&gt;目标元素</span><br><span class=\"line\"></span><br><span class=\"line\">html:</span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">js:</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是事件冒泡？\"><a href=\"#什么是事件冒泡？\" class=\"headerlink\" title=\"什么是事件冒泡？\"></a>什么是事件冒泡？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br><span class=\"line\">假设有如下的 HTML 结构：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">对应的JS代码：</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。</span><br></pre></td></tr></table></figure>\n<h4 id=\"DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\"><a href=\"#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\" class=\"headerlink\" title=\"DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h4><p>（1）创建新节点<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">createDocumentFragment()    //创建一个DOM片段</span><br><span class=\"line\">createElement()   //创建一个具体的元素</span><br><span class=\"line\">createTextNode()   //创建一个文本节点</span><br></pre></td></tr></table></figure></p>\n<p>（2）添加、移除、替换、插入<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendChild(node)</span><br><span class=\"line\">removeChild(node)</span><br><span class=\"line\">replaceChild(new,old)</span><br><span class=\"line\">insertBefore(new,old)</span><br></pre></td></tr></table></figure></p>\n<p>（3）查找<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getElementById();</span><br><span class=\"line\">getElementsByName();</span><br><span class=\"line\">getElementsByTagName();</span><br><span class=\"line\">getElementsByClassName();</span><br><span class=\"line\">querySelector();</span><br><span class=\"line\">querySelectorAll();</span><br></pre></td></tr></table></figure></p>\n<p>（4）属性操作<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getAttribute(key);</span><br><span class=\"line\">setAttribute(key, value);</span><br><span class=\"line\">hasAttribute(key);</span><br><span class=\"line\">removeAttribute(key);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"js数组和对象有哪些原生方法-列举一下\"><a href=\"#js数组和对象有哪些原生方法-列举一下\" class=\"headerlink\" title=\"js数组和对象有哪些原生方法,列举一下\"></a>js数组和对象有哪些原生方法,列举一下</h4><p><a href=\"https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" target=\"_blank\" rel=\"noopener\">image</a><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h4><h4 id=\"Ajax-是什么-如何创建一个-Ajax？\"><a href=\"#Ajax-是什么-如何创建一个-Ajax？\" class=\"headerlink\" title=\"Ajax 是什么? 如何创建一个 Ajax？\"></a>Ajax 是什么? 如何创建一个 Ajax？</h4><h4 id=\"js-延迟加载的方式有哪些？\"><a href=\"#js-延迟加载的方式有哪些？\" class=\"headerlink\" title=\"js 延迟加载的方式有哪些？\"></a>js 延迟加载的方式有哪些？</h4><h4 id=\"谈谈你对模块化开发的理解？\"><a href=\"#谈谈你对模块化开发的理解？\" class=\"headerlink\" title=\"谈谈你对模块化开发的理解？\"></a>谈谈你对模块化开发的理解？</h4><h4 id=\"js-的几种模块规范？\"><a href=\"#js-的几种模块规范？\" class=\"headerlink\" title=\"js 的几种模块规范？\"></a>js 的几种模块规范？</h4><h4 id=\"AMD和CMD-规范的区别？\"><a href=\"#AMD和CMD-规范的区别？\" class=\"headerlink\" title=\"AMD和CMD 规范的区别？\"></a>AMD和CMD 规范的区别？</h4><h4 id=\"ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\"><a href=\"#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\" class=\"headerlink\" title=\"ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h4><h4 id=\"requireJS的核心原理是什么？-33-谈谈JS的运行机制\"><a href=\"#requireJS的核心原理是什么？-33-谈谈JS的运行机制\" class=\"headerlink\" title=\"requireJS的核心原理是什么？ 33. 谈谈JS的运行机制\"></a>requireJS的核心原理是什么？ 33. 谈谈JS的运行机制</h4><h4 id=\"arguments-的对象是什么？\"><a href=\"#arguments-的对象是什么？\" class=\"headerlink\" title=\"arguments 的对象是什么？\"></a>arguments 的对象是什么？</h4><h4 id=\"为什么在调用这个函数时，代码中的b会变成一个全局变量\"><a href=\"#为什么在调用这个函数时，代码中的b会变成一个全局变量\" class=\"headerlink\" title=\"为什么在调用这个函数时，代码中的b会变成一个全局变量?\"></a>为什么在调用这个函数时，代码中的b会变成一个全局变量?</h4><h4 id=\"简单介绍一下V8引擎的垃圾回收机制\"><a href=\"#简单介绍一下V8引擎的垃圾回收机制\" class=\"headerlink\" title=\"简单介绍一下V8引擎的垃圾回收机制\"></a>简单介绍一下V8引擎的垃圾回收机制</h4><h4 id=\"哪些操作会造成内存泄漏？-38-ECMAScript-是什么？\"><a href=\"#哪些操作会造成内存泄漏？-38-ECMAScript-是什么？\" class=\"headerlink\" title=\"哪些操作会造成内存泄漏？ 38. ECMAScript 是什么？\"></a>哪些操作会造成内存泄漏？ 38. ECMAScript 是什么？</h4><h4 id=\"ECMAScript-2015（ES6）有哪些新特性？\"><a href=\"#ECMAScript-2015（ES6）有哪些新特性？\" class=\"headerlink\" title=\"ECMAScript 2015（ES6）有哪些新特性？\"></a>ECMAScript 2015（ES6）有哪些新特性？</h4><h4 id=\"var-let和const的区别是什么？\"><a href=\"#var-let和const的区别是什么？\" class=\"headerlink\" title=\"var,let和const的区别是什么？\"></a>var,let和const的区别是什么？</h4><h4 id=\"什么是箭头函数？\"><a href=\"#什么是箭头函数？\" class=\"headerlink\" title=\"什么是箭头函数？\"></a>什么是箭头函数？</h4><h4 id=\"什么是类？\"><a href=\"#什么是类？\" class=\"headerlink\" title=\"什么是类？\"></a>什么是类？</h4><h4 id=\"什么是模板字符串？\"><a href=\"#什么是模板字符串？\" class=\"headerlink\" title=\"什么是模板字符串？\"></a>什么是模板字符串？</h4><h4 id=\"什么是对象解构？\"><a href=\"#什么是对象解构？\" class=\"headerlink\" title=\"什么是对象解构？\"></a>什么是对象解构？</h4><h4 id=\"什么是Set对象，它是如何工作的？\"><a href=\"#什么是Set对象，它是如何工作的？\" class=\"headerlink\" title=\"什么是Set对象，它是如何工作的？\"></a>什么是Set对象，它是如何工作的？</h4><h4 id=\"什么是Proxy？\"><a href=\"#什么是Proxy？\" class=\"headerlink\" title=\"什么是Proxy？\"></a>什么是Proxy？</h4><h4 id=\"写一个通用的事件侦听器函数，为什么要用它？\"><a href=\"#写一个通用的事件侦听器函数，为什么要用它？\" class=\"headerlink\" title=\"写一个通用的事件侦听器函数，为什么要用它？\"></a>写一个通用的事件侦听器函数，为什么要用它？</h4><h4 id=\"什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\"><a href=\"#什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\" class=\"headerlink\" title=\"什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\"></a>什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？</h4><h4 id=\"什么是高阶函数？\"><a href=\"#什么是高阶函数？\" class=\"headerlink\" title=\"什么是高阶函数？\"></a>什么是高阶函数？</h4><h4 id=\"为什么函数被称为一等公民？\"><a href=\"#为什么函数被称为一等公民？\" class=\"headerlink\" title=\"为什么函数被称为一等公民？\"></a>为什么函数被称为一等公民？</h4><h4 id=\"手动实现Array-prototype-map-方法\"><a href=\"#手动实现Array-prototype-map-方法\" class=\"headerlink\" title=\"手动实现Array.prototype.map 方法\"></a>手动实现Array.prototype.map 方法</h4><h4 id=\"手动实现Array-prototype-filter方法\"><a href=\"#手动实现Array-prototype-filter方法\" class=\"headerlink\" title=\"手动实现Array.prototype.filter方法\"></a>手动实现Array.prototype.filter方法</h4><h4 id=\"手动实现Array-prototype-reduce方法\"><a href=\"#手动实现Array-prototype-reduce方法\" class=\"headerlink\" title=\"手动实现Array.prototype.reduce方法\"></a>手动实现Array.prototype.reduce方法</h4><h4 id=\"js的深浅拷贝\"><a href=\"#js的深浅拷贝\" class=\"headerlink\" title=\"js的深浅拷贝\"></a>js的深浅拷贝</h4><h4 id=\"手写call、apply及bind函数\"><a href=\"#手写call、apply及bind函数\" class=\"headerlink\" title=\"手写call、apply及bind函数\"></a>手写call、apply及bind函数</h4><h4 id=\"函数柯里化的实现\"><a href=\"#函数柯里化的实现\" class=\"headerlink\" title=\"函数柯里化的实现\"></a>函数柯里化的实现</h4><h4 id=\"js模拟new操作符的实现\"><a href=\"#js模拟new操作符的实现\" class=\"headerlink\" title=\"js模拟new操作符的实现\"></a>js模拟new操作符的实现</h4><h4 id=\"什么是回调函数？回调函数有什么缺点\"><a href=\"#什么是回调函数？回调函数有什么缺点\" class=\"headerlink\" title=\"什么是回调函数？回调函数有什么缺点\"></a>什么是回调函数？回调函数有什么缺点</h4><h4 id=\"Promise是什么，可以手写实现一下吗？\"><a href=\"#Promise是什么，可以手写实现一下吗？\" class=\"headerlink\" title=\"Promise是什么，可以手写实现一下吗？\"></a>Promise是什么，可以手写实现一下吗？</h4><h4 id=\"Iterator是什么，有什么作用？\"><a href=\"#Iterator是什么，有什么作用？\" class=\"headerlink\" title=\"Iterator是什么，有什么作用？\"></a>Iterator是什么，有什么作用？</h4><h4 id=\"Generator函数是什么，有什么作用？\"><a href=\"#Generator函数是什么，有什么作用？\" class=\"headerlink\" title=\"Generator函数是什么，有什么作用？\"></a>Generator函数是什么，有什么作用？</h4><h4 id=\"什么是-async-await及其如何工作-有什么优缺点？\"><a href=\"#什么是-async-await及其如何工作-有什么优缺点？\" class=\"headerlink\" title=\"什么是 async/await及其如何工作,有什么优缺点？\"></a>什么是 async/await及其如何工作,有什么优缺点？</h4><h4 id=\"instanceof的原理是什么，如何实现\"><a href=\"#instanceof的原理是什么，如何实现\" class=\"headerlink\" title=\"instanceof的原理是什么，如何实现\"></a>instanceof的原理是什么，如何实现</h4><h4 id=\"js的节流与防抖\"><a href=\"#js的节流与防抖\" class=\"headerlink\" title=\"js的节流与防抖\"></a>js的节流与防抖</h4><h4 id=\"什么是设计模式？\"><a href=\"#什么是设计模式？\" class=\"headerlink\" title=\"什么是设计模式？\"></a>什么是设计模式？</h4><h4 id=\"9种前端常见的设计模式\"><a href=\"#9种前端常见的设计模式\" class=\"headerlink\" title=\"9种前端常见的设计模式\"></a>9种前端常见的设计模式</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"介绍一下js的数据类型有哪些-值是如何存储的\"><a href=\"#介绍一下js的数据类型有哪些-值是如何存储的\" class=\"headerlink\" title=\"介绍一下js的数据类型有哪些,值是如何存储的\"></a>介绍一下js的数据类型有哪些,值是如何存储的</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一共有8种数据类型，7种基本数据类型</span><br><span class=\"line\">String </span><br><span class=\"line\">Number </span><br><span class=\"line\">Boolean </span><br><span class=\"line\">Null </span><br><span class=\"line\">Undefined </span><br><span class=\"line\">Symbol（es6 新增类型，表示第一无二的值） </span><br><span class=\"line\">BigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）</span><br><span class=\"line\">Object（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）</span><br><span class=\"line\"></span><br><span class=\"line\">原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class=\"line\"></span><br><span class=\"line\">引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure>\n<h3 id=\"amp-amp-、-和-运算符分别能做什么\"><a href=\"#amp-amp-、-和-运算符分别能做什么\" class=\"headerlink\" title=\"&amp;&amp; 、 ||和!! 运算符分别能做什么\"></a>&amp;&amp; 、 ||和!! 运算符分别能做什么</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;&amp; 并且符，使用时两边的值结果都必须为true才返回true</span><br><span class=\"line\">|| 或者符，两边的值结果有一个为true最终判断结果就位true</span><br><span class=\"line\">!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）</span><br></pre></td></tr></table></figure>\n<h4 id=\"JS的数据类型的转换\"><a href=\"#JS的数据类型的转换\" class=\"headerlink\" title=\"JS的数据类型的转换\"></a>JS的数据类型的转换</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">在 JS 中类型转换只有三种情况，分别是：</span><br><span class=\"line\"></span><br><span class=\"line\">- 转换为布尔值（调用Boolean()方法）</span><br><span class=\"line\">- 转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class=\"line\">- 转换为字符串（调用.toString()或者String()方法）</span><br><span class=\"line\"></span><br><span class=\"line\">null和underfined没有.toString方法</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<h4 id=\"JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\"><a href=\"#JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call\" class=\"headerlink\" title=\"JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()\"></a>JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()</h4><blockquote>\n<p>（1）typeof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typeof 对于原始类型来说，除了 null 都可以显示正确的类型</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof 2);               // number</span><br><span class=\"line\">console.log(typeof true);            // boolean</span><br><span class=\"line\">console.log(typeof &apos;str&apos;);           // string</span><br><span class=\"line\">console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object</span><br><span class=\"line\">console.log(typeof function()&#123;&#125;);    // function</span><br><span class=\"line\">console.log(typeof &#123;&#125;);              // object</span><br><span class=\"line\">console.log(typeof undefined);       // undefined</span><br><span class=\"line\">console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object</span><br><span class=\"line\"></span><br><span class=\"line\">typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（2）instanceof<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//重点</span><br><span class=\"line\">instanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断</span><br><span class=\"line\">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class=\"line\">其意思就是判断对象是否是某一数据类型（如Array）的实例</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(2 instanceof Number);                    // false</span><br><span class=\"line\">console.log(true instanceof Boolean);                // false </span><br><span class=\"line\">console.log(&apos;str&apos; instanceof String);                // false  </span><br><span class=\"line\">console.log([] instanceof Array);                    // true</span><br><span class=\"line\">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class=\"line\">console.log(&#123;&#125; instanceof Object);                   // true    </span><br><span class=\"line\">// console.log(undefined instanceof Undefined);      //报错</span><br><span class=\"line\">// console.log(null instanceof Null);                //报错</span><br><span class=\"line\">复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。</span><br><span class=\"line\">我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，&apos;str&apos;不是实例，所以判断值为false。</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（3）constructor<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log((2).constructor === Number); // true</span><br><span class=\"line\">console.log((true).constructor === Boolean); // true</span><br><span class=\"line\">console.log((&apos;str&apos;).constructor === String); // true</span><br><span class=\"line\">console.log(([]).constructor === Array); // true</span><br><span class=\"line\">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class=\"line\">console.log((&#123;&#125;).constructor === Object); // true</span><br><span class=\"line\"></span><br><span class=\"line\">这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了</span><br><span class=\"line\"></span><br><span class=\"line\">function Fn()&#123;&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">Fn.prototype=new Array();</span><br><span class=\"line\"> </span><br><span class=\"line\">var f=new Fn();</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(f.constructor===Fn);    // false</span><br><span class=\"line\">console.log(f.constructor===Array); // true</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = Object.prototype.toString;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(a.call(2));</span><br><span class=\"line\">console.log(a.call(true));</span><br><span class=\"line\">console.log(a.call(&apos;str&apos;));</span><br><span class=\"line\">console.log(a.call([]));</span><br><span class=\"line\">console.log(a.call(function()&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(&#123;&#125;));</span><br><span class=\"line\">console.log(a.call(undefined));</span><br><span class=\"line\">console.log(a.call(null));</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"介绍-JS-有哪些内置对象？\"><a href=\"#介绍-JS-有哪些内置对象？\" class=\"headerlink\" title=\"介绍 JS 有哪些内置对象？\"></a>介绍 JS 有哪些内置对象？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class=\"line\">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class=\"line\"></span><br><span class=\"line\">标准内置对象的分类</span><br><span class=\"line\"></span><br><span class=\"line\">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Infinity、NaN、undefined、null 字面量</span><br><span class=\"line\"></span><br><span class=\"line\">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 eval()、parseFloat()、parseInt() 等</span><br><span class=\"line\"></span><br><span class=\"line\">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class=\"line\"></span><br><span class=\"line\">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Number、Math、Date</span><br><span class=\"line\"></span><br><span class=\"line\">（5）字符串，用来表示和操作字符串的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 String、RegExp</span><br><span class=\"line\"></span><br><span class=\"line\">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class=\"line\"></span><br><span class=\"line\">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Map、Set、WeakMap、WeakSet</span><br><span class=\"line\"></span><br><span class=\"line\">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 SIMD 等</span><br><span class=\"line\"></span><br><span class=\"line\">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 JSON 等</span><br><span class=\"line\"></span><br><span class=\"line\">（10）控制抽象对象</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Promise、Generator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（11）反射</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Reflect、Proxy</span><br><span class=\"line\"></span><br><span class=\"line\">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">例如 Intl、Intl.Collator 等</span><br><span class=\"line\"></span><br><span class=\"line\">（13）WebAssembly</span><br><span class=\"line\"></span><br><span class=\"line\">（14）其他</span><br><span class=\"line\"></span><br><span class=\"line\">例如 arguments</span><br></pre></td></tr></table></figure>\n<h4 id=\"undefined-与-undeclared-的区别？\"><a href=\"#undefined-与-undeclared-的区别？\" class=\"headerlink\" title=\"undefined 与 undeclared 的区别？\"></a>undefined 与 undeclared 的区别？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。</span><br><span class=\"line\">对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ</span><br><span class=\"line\">eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</span><br></pre></td></tr></table></figure>\n<h4 id=\"null-和-undefined-的区别？\"><a href=\"#null-和-undefined-的区别？\" class=\"headerlink\" title=\"null 和 undefined 的区别？\"></a>null 和 undefined 的区别？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class=\"line\">undefined 代表的含义是未定义，</span><br><span class=\"line\">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class=\"line\">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class=\"line\">/*</span><br><span class=\"line\">    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，</span><br><span class=\"line\">    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class=\"line\">    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</span><br><span class=\"line\">*/</span><br><span class=\"line\">undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它</span><br><span class=\"line\">会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</span><br><span class=\"line\">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等</span><br><span class=\"line\">号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>\n<h4 id=\"和-的valueOf和toString的结果是什么？\"><a href=\"#和-的valueOf和toString的结果是什么？\" class=\"headerlink\" title=\"{}和[]的valueOf和toString的结果是什么？\"></a>{}和[]的valueOf和toString的结果是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Javascript-的作用域和作用域链？\"><a href=\"#Javascript-的作用域和作用域链？\" class=\"headerlink\" title=\"Javascript 的作用域和作用域链？\"></a>Javascript 的作用域和作用域链？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class=\"line\">【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</span><br></pre></td></tr></table></figure>\n<h4 id=\"javascript-创建对象的几种方式？\"><a href=\"#javascript-创建对象的几种方式？\" class=\"headerlink\" title=\"javascript 创建对象的几种方式？\"></a>javascript 创建对象的几种方式？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>\n<h4 id=\"JavaScript-继承的几种实现方式？\"><a href=\"#JavaScript-继承的几种实现方式？\" class=\"headerlink\" title=\"JavaScript 继承的几种实现方式？\"></a>JavaScript 继承的几种实现方式？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</span><br><span class=\"line\"></span><br><span class=\"line\">（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</span><br><span class=\"line\"></span><br><span class=\"line\">（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</span><br><span class=\"line\"></span><br><span class=\"line\">（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</span><br></pre></td></tr></table></figure>\n<h4 id=\"寄生式组合继承的实现？\"><a href=\"#寄生式组合继承的实现？\" class=\"headerlink\" title=\"寄生式组合继承的实现？\"></a>寄生式组合继承的实现？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person</span><br><span class=\"line\">Student</span><br><span class=\"line\"></span><br><span class=\"line\">function Person(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(123);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Student(name, grade)&#123;</span><br><span class=\"line\">    Person.call(this,name);</span><br><span class=\"line\">    this.grade = grade;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype = Object.create(Person.prototype);</span><br><span class=\"line\">Student.prototype.constructor = Student;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.sayMyGrade = function() &#123;</span><br><span class=\"line\">  console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"谈谈你对this、call、apply和bind的理解\"><a href=\"#谈谈你对this、call、apply和bind的理解\" class=\"headerlink\" title=\"谈谈你对this、call、apply和bind的理解\"></a>谈谈你对this、call、apply和bind的理解</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结:</span><br><span class=\"line\">1. 在浏览器里，在全局范围内this 指向window对象；</span><br><span class=\"line\">2. 在函数中，this永远指向最后调用他的那个对象；</span><br><span class=\"line\">3. 构造函数中，this指向new出来的那个新的对象；</span><br><span class=\"line\">4. call、apply、bind中的this被强绑定在指定的那个对象上；</span><br><span class=\"line\">5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</span><br><span class=\"line\">6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</span><br><span class=\"line\"></span><br><span class=\"line\">区别:</span><br><span class=\"line\">- call/apply改变了函数的this上下文后马上执行该函数</span><br><span class=\"line\">- bind则是返回改变了上下文后的函数,不执行该函数</span><br></pre></td></tr></table></figure>\n<h4 id=\"JavaScript-原型，原型链？-有什么特点？\"><a href=\"#JavaScript-原型，原型链？-有什么特点？\" class=\"headerlink\" title=\"JavaScript 原型，原型链？ 有什么特点？\"></a>JavaScript 原型，原型链？ 有什么特点？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">prototype就是JS的原型，里面可以定义属性和方法</span><br><span class=\"line\">当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。</span><br><span class=\"line\">原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br></pre></td></tr></table></figure>\n<h4 id=\"js-获取原型的方法？\"><a href=\"#js-获取原型的方法？\" class=\"headerlink\" title=\"js 获取原型的方法？\"></a>js 获取原型的方法？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p.proto</span><br><span class=\"line\">p.constructor.prototype</span><br><span class=\"line\">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是闭包，为什么要用它？\"><a href=\"#什么是闭包，为什么要用它？\" class=\"headerlink\" title=\"什么是闭包，为什么要用它？\"></a>什么是闭包，为什么要用它？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">闭包是指有权访问另一个函数作用域内变量的函数</span><br><span class=\"line\">创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。</span><br><span class=\"line\"></span><br><span class=\"line\">闭包有两个常用的用途:</span><br><span class=\"line\">- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class=\"line\">- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</span><br><span class=\"line\"></span><br><span class=\"line\">function a()&#123;</span><br><span class=\"line\">    var n = 0;</span><br><span class=\"line\">    function add()&#123;</span><br><span class=\"line\">       n++;</span><br><span class=\"line\">       console.log(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span><br><span class=\"line\">a1();    //1</span><br><span class=\"line\">a1();    //2  第二次调用n变量还在内存中</span><br><span class=\"line\"></span><br><span class=\"line\">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是-DOM-和-BOM？\"><a href=\"#什么是-DOM-和-BOM？\" class=\"headerlink\" title=\"什么是 DOM 和 BOM？\"></a>什么是 DOM 和 BOM？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class=\"line\"></span><br><span class=\"line\">BOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM</span><br><span class=\"line\">的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）</span><br><span class=\"line\">对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati</span><br><span class=\"line\">on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对</span><br><span class=\"line\">象的子对象。</span><br></pre></td></tr></table></figure>\n<h4 id=\"三种事件模型是什么？\"><a href=\"#三种事件模型是什么？\" class=\"headerlink\" title=\"三种事件模型是什么？\"></a>三种事件模型是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class=\"line\">IE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class=\"line\">DOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure>\n<h4 id=\"事件委托是什么？\"><a href=\"#事件委托是什么？\" class=\"headerlink\" title=\"事件委托是什么？\"></a>事件委托是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class=\"line\">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class=\"line\">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是事件传播\"><a href=\"#什么是事件传播\" class=\"headerlink\" title=\"什么是事件传播?\"></a>什么是事件传播?</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。</span><br><span class=\"line\">事件传播有三个阶段：</span><br><span class=\"line\">1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class=\"line\">2. 目标阶段–事件已达到目标元素。</span><br><span class=\"line\">3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是事件捕获？\"><a href=\"#什么是事件捕获？\" class=\"headerlink\" title=\"什么是事件捕获？\"></a>什么是事件捕获？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----&gt; document----&gt; html----&gt; body ----&gt;目标元素</span><br><span class=\"line\"></span><br><span class=\"line\">html:</span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">js:</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。</span><br></pre></td></tr></table></figure>\n<h4 id=\"什么是事件冒泡？\"><a href=\"#什么是事件冒泡？\" class=\"headerlink\" title=\"什么是事件冒泡？\"></a>什么是事件冒泡？</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br><span class=\"line\">假设有如下的 HTML 结构：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">对应的JS代码：</span><br><span class=\"line\">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class=\"line\">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class=\"line\">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class=\"line\">    el = document.querySelector(el);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  el.addEventListener(event, callback, isCapture);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class=\"line\">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class=\"line\">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class=\"line\">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;child&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;parent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;grandparent&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;document&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;html&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">    console.log(&apos;window&apos;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。</span><br></pre></td></tr></table></figure>\n<h4 id=\"DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\"><a href=\"#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？\" class=\"headerlink\" title=\"DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？\"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h4><p>（1）创建新节点<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">createDocumentFragment()    //创建一个DOM片段</span><br><span class=\"line\">createElement()   //创建一个具体的元素</span><br><span class=\"line\">createTextNode()   //创建一个文本节点</span><br></pre></td></tr></table></figure></p>\n<p>（2）添加、移除、替换、插入<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendChild(node)</span><br><span class=\"line\">removeChild(node)</span><br><span class=\"line\">replaceChild(new,old)</span><br><span class=\"line\">insertBefore(new,old)</span><br></pre></td></tr></table></figure></p>\n<p>（3）查找<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getElementById();</span><br><span class=\"line\">getElementsByName();</span><br><span class=\"line\">getElementsByTagName();</span><br><span class=\"line\">getElementsByClassName();</span><br><span class=\"line\">querySelector();</span><br><span class=\"line\">querySelectorAll();</span><br></pre></td></tr></table></figure></p>\n<p>（4）属性操作<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getAttribute(key);</span><br><span class=\"line\">setAttribute(key, value);</span><br><span class=\"line\">hasAttribute(key);</span><br><span class=\"line\">removeAttribute(key);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"js数组和对象有哪些原生方法-列举一下\"><a href=\"#js数组和对象有哪些原生方法-列举一下\" class=\"headerlink\" title=\"js数组和对象有哪些原生方法,列举一下\"></a>js数组和对象有哪些原生方法,列举一下</h4><p><a href=\"https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" target=\"_blank\" rel=\"noopener\">image</a><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"常用的正则表达式\"><a href=\"#常用的正则表达式\" class=\"headerlink\" title=\"常用的正则表达式\"></a>常用的正则表达式</h4><h4 id=\"Ajax-是什么-如何创建一个-Ajax？\"><a href=\"#Ajax-是什么-如何创建一个-Ajax？\" class=\"headerlink\" title=\"Ajax 是什么? 如何创建一个 Ajax？\"></a>Ajax 是什么? 如何创建一个 Ajax？</h4><h4 id=\"js-延迟加载的方式有哪些？\"><a href=\"#js-延迟加载的方式有哪些？\" class=\"headerlink\" title=\"js 延迟加载的方式有哪些？\"></a>js 延迟加载的方式有哪些？</h4><h4 id=\"谈谈你对模块化开发的理解？\"><a href=\"#谈谈你对模块化开发的理解？\" class=\"headerlink\" title=\"谈谈你对模块化开发的理解？\"></a>谈谈你对模块化开发的理解？</h4><h4 id=\"js-的几种模块规范？\"><a href=\"#js-的几种模块规范？\" class=\"headerlink\" title=\"js 的几种模块规范？\"></a>js 的几种模块规范？</h4><h4 id=\"AMD和CMD-规范的区别？\"><a href=\"#AMD和CMD-规范的区别？\" class=\"headerlink\" title=\"AMD和CMD 规范的区别？\"></a>AMD和CMD 规范的区别？</h4><h4 id=\"ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\"><a href=\"#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。\" class=\"headerlink\" title=\"ES6 模块与 CommonJS 模块、AMD、CMD 的差异。\"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h4><h4 id=\"requireJS的核心原理是什么？-33-谈谈JS的运行机制\"><a href=\"#requireJS的核心原理是什么？-33-谈谈JS的运行机制\" class=\"headerlink\" title=\"requireJS的核心原理是什么？ 33. 谈谈JS的运行机制\"></a>requireJS的核心原理是什么？ 33. 谈谈JS的运行机制</h4><h4 id=\"arguments-的对象是什么？\"><a href=\"#arguments-的对象是什么？\" class=\"headerlink\" title=\"arguments 的对象是什么？\"></a>arguments 的对象是什么？</h4><h4 id=\"为什么在调用这个函数时，代码中的b会变成一个全局变量\"><a href=\"#为什么在调用这个函数时，代码中的b会变成一个全局变量\" class=\"headerlink\" title=\"为什么在调用这个函数时，代码中的b会变成一个全局变量?\"></a>为什么在调用这个函数时，代码中的b会变成一个全局变量?</h4><h4 id=\"简单介绍一下V8引擎的垃圾回收机制\"><a href=\"#简单介绍一下V8引擎的垃圾回收机制\" class=\"headerlink\" title=\"简单介绍一下V8引擎的垃圾回收机制\"></a>简单介绍一下V8引擎的垃圾回收机制</h4><h4 id=\"哪些操作会造成内存泄漏？-38-ECMAScript-是什么？\"><a href=\"#哪些操作会造成内存泄漏？-38-ECMAScript-是什么？\" class=\"headerlink\" title=\"哪些操作会造成内存泄漏？ 38. ECMAScript 是什么？\"></a>哪些操作会造成内存泄漏？ 38. ECMAScript 是什么？</h4><h4 id=\"ECMAScript-2015（ES6）有哪些新特性？\"><a href=\"#ECMAScript-2015（ES6）有哪些新特性？\" class=\"headerlink\" title=\"ECMAScript 2015（ES6）有哪些新特性？\"></a>ECMAScript 2015（ES6）有哪些新特性？</h4><h4 id=\"var-let和const的区别是什么？\"><a href=\"#var-let和const的区别是什么？\" class=\"headerlink\" title=\"var,let和const的区别是什么？\"></a>var,let和const的区别是什么？</h4><h4 id=\"什么是箭头函数？\"><a href=\"#什么是箭头函数？\" class=\"headerlink\" title=\"什么是箭头函数？\"></a>什么是箭头函数？</h4><h4 id=\"什么是类？\"><a href=\"#什么是类？\" class=\"headerlink\" title=\"什么是类？\"></a>什么是类？</h4><h4 id=\"什么是模板字符串？\"><a href=\"#什么是模板字符串？\" class=\"headerlink\" title=\"什么是模板字符串？\"></a>什么是模板字符串？</h4><h4 id=\"什么是对象解构？\"><a href=\"#什么是对象解构？\" class=\"headerlink\" title=\"什么是对象解构？\"></a>什么是对象解构？</h4><h4 id=\"什么是Set对象，它是如何工作的？\"><a href=\"#什么是Set对象，它是如何工作的？\" class=\"headerlink\" title=\"什么是Set对象，它是如何工作的？\"></a>什么是Set对象，它是如何工作的？</h4><h4 id=\"什么是Proxy？\"><a href=\"#什么是Proxy？\" class=\"headerlink\" title=\"什么是Proxy？\"></a>什么是Proxy？</h4><h4 id=\"写一个通用的事件侦听器函数，为什么要用它？\"><a href=\"#写一个通用的事件侦听器函数，为什么要用它？\" class=\"headerlink\" title=\"写一个通用的事件侦听器函数，为什么要用它？\"></a>写一个通用的事件侦听器函数，为什么要用它？</h4><h4 id=\"什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\"><a href=\"#什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？\" class=\"headerlink\" title=\"什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？\"></a>什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？</h4><h4 id=\"什么是高阶函数？\"><a href=\"#什么是高阶函数？\" class=\"headerlink\" title=\"什么是高阶函数？\"></a>什么是高阶函数？</h4><h4 id=\"为什么函数被称为一等公民？\"><a href=\"#为什么函数被称为一等公民？\" class=\"headerlink\" title=\"为什么函数被称为一等公民？\"></a>为什么函数被称为一等公民？</h4><h4 id=\"手动实现Array-prototype-map-方法\"><a href=\"#手动实现Array-prototype-map-方法\" class=\"headerlink\" title=\"手动实现Array.prototype.map 方法\"></a>手动实现Array.prototype.map 方法</h4><h4 id=\"手动实现Array-prototype-filter方法\"><a href=\"#手动实现Array-prototype-filter方法\" class=\"headerlink\" title=\"手动实现Array.prototype.filter方法\"></a>手动实现Array.prototype.filter方法</h4><h4 id=\"手动实现Array-prototype-reduce方法\"><a href=\"#手动实现Array-prototype-reduce方法\" class=\"headerlink\" title=\"手动实现Array.prototype.reduce方法\"></a>手动实现Array.prototype.reduce方法</h4><h4 id=\"js的深浅拷贝\"><a href=\"#js的深浅拷贝\" class=\"headerlink\" title=\"js的深浅拷贝\"></a>js的深浅拷贝</h4><h4 id=\"手写call、apply及bind函数\"><a href=\"#手写call、apply及bind函数\" class=\"headerlink\" title=\"手写call、apply及bind函数\"></a>手写call、apply及bind函数</h4><h4 id=\"函数柯里化的实现\"><a href=\"#函数柯里化的实现\" class=\"headerlink\" title=\"函数柯里化的实现\"></a>函数柯里化的实现</h4><h4 id=\"js模拟new操作符的实现\"><a href=\"#js模拟new操作符的实现\" class=\"headerlink\" title=\"js模拟new操作符的实现\"></a>js模拟new操作符的实现</h4><h4 id=\"什么是回调函数？回调函数有什么缺点\"><a href=\"#什么是回调函数？回调函数有什么缺点\" class=\"headerlink\" title=\"什么是回调函数？回调函数有什么缺点\"></a>什么是回调函数？回调函数有什么缺点</h4><h4 id=\"Promise是什么，可以手写实现一下吗？\"><a href=\"#Promise是什么，可以手写实现一下吗？\" class=\"headerlink\" title=\"Promise是什么，可以手写实现一下吗？\"></a>Promise是什么，可以手写实现一下吗？</h4><h4 id=\"Iterator是什么，有什么作用？\"><a href=\"#Iterator是什么，有什么作用？\" class=\"headerlink\" title=\"Iterator是什么，有什么作用？\"></a>Iterator是什么，有什么作用？</h4><h4 id=\"Generator函数是什么，有什么作用？\"><a href=\"#Generator函数是什么，有什么作用？\" class=\"headerlink\" title=\"Generator函数是什么，有什么作用？\"></a>Generator函数是什么，有什么作用？</h4><h4 id=\"什么是-async-await及其如何工作-有什么优缺点？\"><a href=\"#什么是-async-await及其如何工作-有什么优缺点？\" class=\"headerlink\" title=\"什么是 async/await及其如何工作,有什么优缺点？\"></a>什么是 async/await及其如何工作,有什么优缺点？</h4><h4 id=\"instanceof的原理是什么，如何实现\"><a href=\"#instanceof的原理是什么，如何实现\" class=\"headerlink\" title=\"instanceof的原理是什么，如何实现\"></a>instanceof的原理是什么，如何实现</h4><h4 id=\"js的节流与防抖\"><a href=\"#js的节流与防抖\" class=\"headerlink\" title=\"js的节流与防抖\"></a>js的节流与防抖</h4><h4 id=\"什么是设计模式？\"><a href=\"#什么是设计模式？\" class=\"headerlink\" title=\"什么是设计模式？\"></a>什么是设计模式？</h4><h4 id=\"9种前端常见的设计模式\"><a href=\"#9种前端常见的设计模式\" class=\"headerlink\" title=\"9种前端常见的设计模式\"></a>9种前端常见的设计模式</h4>"},{"title":"让h5页面强制横屏","date":"2018-07-25T07:51:43.000Z","_content":"\n>转载至：https://blog.csdn.net/qq_36457584/article/details/80967278\n\n```\n//注意设置*{padding:0;margin:0;} 不然有滚动条\n/**\n    * H5强制横屏\n    * @param {Object}\n    */   \nvar wrapper = document.getElementById(\"root\");      \nvar mark = window.orientation == 90 || window.orientation == -90;    //初始角度\n//不同角度宽高需要互换\nvar width = document.documentElement[mark ? 'clientHeight' : 'clientWidth']; \nvar height = document.documentElement[mark ? 'clientWidth' : 'clientHeight'];                         \nvar detectOrient = function() {\n    var style = \"\";                            \n    if (window.orientation == 90 || window.orientation == -90) { //横屏                             \n        style += \"width:100%;\"; \n        style += \"height:100%;\";\n        style += \"-webkit-transform: rotate(0); transform: rotate(0);\";\n        style += \"-webkit-transform-origin: 0 0;\";\n        style += \"transform-origin: 0 0;\";\n    } else if(window.orientation == 180 || window.orientation == 0){ //竖屏                    \n        style += \"width:\" + height + \"px;\";// 注意旋转后的宽高切换\n        style += \"height:\"+  width + \"px;\";\n        style += \"-webkit-transform: rotate(90deg); transform: rotate(90deg);\";\n        // 注意旋转中点的处理\n        style += \"-webkit-transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n        style += \"transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n    }\n    style += \"visibility: initial;\";\n    wrapper.style.cssText = style;\n    $(\"#progress\").addClass(\"animate-progress\");\n}        \nwindow.addEventListener(\"load\", detectOrient, false);\nwindow.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", detectOrient, false);\ndetectOrient();  \n\n```","source":"_posts/让h5页面强制横屏.md","raw":"---\ntitle: 让h5页面强制横屏\ndate: 2018-07-25 15:51:43\ntags: [javaScript,技巧]\ncategories: 技术\n---\n\n>转载至：https://blog.csdn.net/qq_36457584/article/details/80967278\n\n```\n//注意设置*{padding:0;margin:0;} 不然有滚动条\n/**\n    * H5强制横屏\n    * @param {Object}\n    */   \nvar wrapper = document.getElementById(\"root\");      \nvar mark = window.orientation == 90 || window.orientation == -90;    //初始角度\n//不同角度宽高需要互换\nvar width = document.documentElement[mark ? 'clientHeight' : 'clientWidth']; \nvar height = document.documentElement[mark ? 'clientWidth' : 'clientHeight'];                         \nvar detectOrient = function() {\n    var style = \"\";                            \n    if (window.orientation == 90 || window.orientation == -90) { //横屏                             \n        style += \"width:100%;\"; \n        style += \"height:100%;\";\n        style += \"-webkit-transform: rotate(0); transform: rotate(0);\";\n        style += \"-webkit-transform-origin: 0 0;\";\n        style += \"transform-origin: 0 0;\";\n    } else if(window.orientation == 180 || window.orientation == 0){ //竖屏                    \n        style += \"width:\" + height + \"px;\";// 注意旋转后的宽高切换\n        style += \"height:\"+  width + \"px;\";\n        style += \"-webkit-transform: rotate(90deg); transform: rotate(90deg);\";\n        // 注意旋转中点的处理\n        style += \"-webkit-transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n        style += \"transform-origin: \" + width / 2 + \"px \" + width / 2 + \"px;\";\n    }\n    style += \"visibility: initial;\";\n    wrapper.style.cssText = style;\n    $(\"#progress\").addClass(\"animate-progress\");\n}        \nwindow.addEventListener(\"load\", detectOrient, false);\nwindow.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", detectOrient, false);\ndetectOrient();  \n\n```","slug":"让h5页面强制横屏","published":1,"updated":"2019-10-23T07:39:13.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzj500071wek0tyq6vov","content":"<blockquote>\n<p>转载至：<a href=\"https://blog.csdn.net/qq_36457584/article/details/80967278\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_36457584/article/details/80967278</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//注意设置*&#123;padding:0;margin:0;&#125; 不然有滚动条</span><br><span class=\"line\">/**</span><br><span class=\"line\">    * H5强制横屏</span><br><span class=\"line\">    * @param &#123;Object&#125;</span><br><span class=\"line\">    */   </span><br><span class=\"line\">var wrapper = document.getElementById(&quot;root&quot;);      </span><br><span class=\"line\">var mark = window.orientation == 90 || window.orientation == -90;    //初始角度</span><br><span class=\"line\">//不同角度宽高需要互换</span><br><span class=\"line\">var width = document.documentElement[mark ? &apos;clientHeight&apos; : &apos;clientWidth&apos;]; </span><br><span class=\"line\">var height = document.documentElement[mark ? &apos;clientWidth&apos; : &apos;clientHeight&apos;];                         </span><br><span class=\"line\">var detectOrient = function() &#123;</span><br><span class=\"line\">    var style = &quot;&quot;;                            </span><br><span class=\"line\">    if (window.orientation == 90 || window.orientation == -90) &#123; //横屏                             </span><br><span class=\"line\">        style += &quot;width:100%;&quot;; </span><br><span class=\"line\">        style += &quot;height:100%;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(0); transform: rotate(0);&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: 0 0;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: 0 0;&quot;;</span><br><span class=\"line\">    &#125; else if(window.orientation == 180 || window.orientation == 0)&#123; //竖屏                    </span><br><span class=\"line\">        style += &quot;width:&quot; + height + &quot;px;&quot;;// 注意旋转后的宽高切换</span><br><span class=\"line\">        style += &quot;height:&quot;+  width + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(90deg); transform: rotate(90deg);&quot;;</span><br><span class=\"line\">        // 注意旋转中点的处理</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    style += &quot;visibility: initial;&quot;;</span><br><span class=\"line\">    wrapper.style.cssText = style;</span><br><span class=\"line\">    $(&quot;#progress&quot;).addClass(&quot;animate-progress&quot;);</span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&quot;load&quot;, detectOrient, false);</span><br><span class=\"line\">window.addEventListener(&quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;, detectOrient, false);</span><br><span class=\"line\">detectOrient();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>转载至：<a href=\"https://blog.csdn.net/qq_36457584/article/details/80967278\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_36457584/article/details/80967278</a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//注意设置*&#123;padding:0;margin:0;&#125; 不然有滚动条</span><br><span class=\"line\">/**</span><br><span class=\"line\">    * H5强制横屏</span><br><span class=\"line\">    * @param &#123;Object&#125;</span><br><span class=\"line\">    */   </span><br><span class=\"line\">var wrapper = document.getElementById(&quot;root&quot;);      </span><br><span class=\"line\">var mark = window.orientation == 90 || window.orientation == -90;    //初始角度</span><br><span class=\"line\">//不同角度宽高需要互换</span><br><span class=\"line\">var width = document.documentElement[mark ? &apos;clientHeight&apos; : &apos;clientWidth&apos;]; </span><br><span class=\"line\">var height = document.documentElement[mark ? &apos;clientWidth&apos; : &apos;clientHeight&apos;];                         </span><br><span class=\"line\">var detectOrient = function() &#123;</span><br><span class=\"line\">    var style = &quot;&quot;;                            </span><br><span class=\"line\">    if (window.orientation == 90 || window.orientation == -90) &#123; //横屏                             </span><br><span class=\"line\">        style += &quot;width:100%;&quot;; </span><br><span class=\"line\">        style += &quot;height:100%;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(0); transform: rotate(0);&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: 0 0;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: 0 0;&quot;;</span><br><span class=\"line\">    &#125; else if(window.orientation == 180 || window.orientation == 0)&#123; //竖屏                    </span><br><span class=\"line\">        style += &quot;width:&quot; + height + &quot;px;&quot;;// 注意旋转后的宽高切换</span><br><span class=\"line\">        style += &quot;height:&quot;+  width + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;-webkit-transform: rotate(90deg); transform: rotate(90deg);&quot;;</span><br><span class=\"line\">        // 注意旋转中点的处理</span><br><span class=\"line\">        style += &quot;-webkit-transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">        style += &quot;transform-origin: &quot; + width / 2 + &quot;px &quot; + width / 2 + &quot;px;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    style += &quot;visibility: initial;&quot;;</span><br><span class=\"line\">    wrapper.style.cssText = style;</span><br><span class=\"line\">    $(&quot;#progress&quot;).addClass(&quot;animate-progress&quot;);</span><br><span class=\"line\">&#125;        </span><br><span class=\"line\">window.addEventListener(&quot;load&quot;, detectOrient, false);</span><br><span class=\"line\">window.addEventListener(&quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;, detectOrient, false);</span><br><span class=\"line\">detectOrient();</span><br></pre></td></tr></table></figure>"},{"title":"react Context(上下文方法使用)","date":"2019-03-29T06:41:51.000Z","_content":"\n> 使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件\n\n```\n//定义\nconst defaultValue = 'aaa';\nconst LocaleContext = React.createContext(defaultValue);\n\n//父组件\nclass LocaleProvider extends React.Component{\n    state = {\n        locale: defaultValue\n    }\n    render(){\n        return (\n            <LocaleContext.Provider value={this.state.locale}>\n                <button onClick={()=>this.setState({locale: 'bbb')})} >\n                    切换\n                </button>\n                {this.props.children]\n            </LocaleContext.Provider>\n        )\n    }\n}\n\n//子组件\nclass LocaledButtons extends React.Componet{\n    render(){\n        return (\n            <LocaleContext.Consumer>\n                {locale => (\n                    <div>\n                        <span>{locale}</span>\n                    </div>\n                }\n            </LocaleContext.Consumer>        \n        )\n    }\n}\n\n//实际使用\nexport default () => (\n    <LocaleProvider>\n        <LocaledButtons />\n    </LocaleProvider>\n)\n\n\n```\n","source":"_posts/react-Context-上下文方法使用.md","raw":"---\ntitle: react Context(上下文方法使用)\ndate: 2019-03-29 14:41:51\ntags: react\ncategories: 技术\n---\n\n> 使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件\n\n```\n//定义\nconst defaultValue = 'aaa';\nconst LocaleContext = React.createContext(defaultValue);\n\n//父组件\nclass LocaleProvider extends React.Component{\n    state = {\n        locale: defaultValue\n    }\n    render(){\n        return (\n            <LocaleContext.Provider value={this.state.locale}>\n                <button onClick={()=>this.setState({locale: 'bbb')})} >\n                    切换\n                </button>\n                {this.props.children]\n            </LocaleContext.Provider>\n        )\n    }\n}\n\n//子组件\nclass LocaledButtons extends React.Componet{\n    render(){\n        return (\n            <LocaleContext.Consumer>\n                {locale => (\n                    <div>\n                        <span>{locale}</span>\n                    </div>\n                }\n            </LocaleContext.Consumer>        \n        )\n    }\n}\n\n//实际使用\nexport default () => (\n    <LocaleProvider>\n        <LocaledButtons />\n    </LocaleProvider>\n)\n\n\n```\n","slug":"react-Context-上下文方法使用","published":1,"updated":"2019-10-23T10:30:36.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzj900081wek5nzhm0ja","content":"<blockquote>\n<p>使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">const defaultValue = &apos;aaa&apos;;</span><br><span class=\"line\">const LocaleContext = React.createContext(defaultValue);</span><br><span class=\"line\"></span><br><span class=\"line\">//父组件</span><br><span class=\"line\">class LocaleProvider extends React.Component&#123;</span><br><span class=\"line\">    state = &#123;</span><br><span class=\"line\">        locale: defaultValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Provider value=&#123;this.state.locale&#125;&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;locale: &apos;bbb&apos;)&#125;)&#125; &gt;</span><br><span class=\"line\">                    切换</span><br><span class=\"line\">                &lt;/button&gt;</span><br><span class=\"line\">                &#123;this.props.children]</span><br><span class=\"line\">            &lt;/LocaleContext.Provider&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子组件</span><br><span class=\"line\">class LocaledButtons extends React.Componet&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Consumer&gt;</span><br><span class=\"line\">                &#123;locale =&gt; (</span><br><span class=\"line\">                    &lt;div&gt;</span><br><span class=\"line\">                        &lt;span&gt;&#123;locale&#125;&lt;/span&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &lt;/LocaleContext.Consumer&gt;        </span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//实际使用</span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">    &lt;LocaleProvider&gt;</span><br><span class=\"line\">        &lt;LocaledButtons /&gt;</span><br><span class=\"line\">    &lt;/LocaleProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>使用React.createContext创建上下文，父组件使用 LocaleContext.Provider 创建组件，包裹的子组件使用 LocaleContext.Consumer 创建组件。当父组件的value值改变时就会重新渲染子组件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">const defaultValue = &apos;aaa&apos;;</span><br><span class=\"line\">const LocaleContext = React.createContext(defaultValue);</span><br><span class=\"line\"></span><br><span class=\"line\">//父组件</span><br><span class=\"line\">class LocaleProvider extends React.Component&#123;</span><br><span class=\"line\">    state = &#123;</span><br><span class=\"line\">        locale: defaultValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Provider value=&#123;this.state.locale&#125;&gt;</span><br><span class=\"line\">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;locale: &apos;bbb&apos;)&#125;)&#125; &gt;</span><br><span class=\"line\">                    切换</span><br><span class=\"line\">                &lt;/button&gt;</span><br><span class=\"line\">                &#123;this.props.children]</span><br><span class=\"line\">            &lt;/LocaleContext.Provider&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子组件</span><br><span class=\"line\">class LocaledButtons extends React.Componet&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            &lt;LocaleContext.Consumer&gt;</span><br><span class=\"line\">                &#123;locale =&gt; (</span><br><span class=\"line\">                    &lt;div&gt;</span><br><span class=\"line\">                        &lt;span&gt;&#123;locale&#125;&lt;/span&gt;</span><br><span class=\"line\">                    &lt;/div&gt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &lt;/LocaleContext.Consumer&gt;        </span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//实际使用</span><br><span class=\"line\">export default () =&gt; (</span><br><span class=\"line\">    &lt;LocaleProvider&gt;</span><br><span class=\"line\">        &lt;LocaledButtons /&gt;</span><br><span class=\"line\">    &lt;/LocaleProvider&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n"},{"title":"forEach兼容写法","date":"2018-07-25T07:51:43.000Z","_content":"\n最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。\n\n最后在网上找到这段(兼容IE8)\n\n```\n\n    if ( !Array.prototype.forEach ) {\n        Array.prototype.forEach = function forEach( callback, thisArg ) {\n            var T, k;\n            if ( this == null ) {\n                throw new TypeError( \"this is null or not defined\" );\n            }\n            var O = Object(this);\n            var len = O.length >>> 0;\n            if ( typeof callback !== \"function\" ) {\n                throw new TypeError( callback + \" is not a function\" );\n            }\n            if ( arguments.length > 1 ) {\n                T = thisArg;\n            }\n            k = 0;\n            while( k < len ) {\n    \n                var kValue;\n                if ( k in O ) {\n                    kValue = O[ k ];\n                    callback.call( T, kValue, k, O );\n                }\n                k++;\n            }\n        };\n    }\n\n```\n","source":"_posts/forEach兼容写法.md","raw":"---\ntitle: forEach兼容写法\ndate: 2018-07-25 15:51:43\ntags: javaScript\ncategories: 技术\n---\n\n最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。\n\n最后在网上找到这段(兼容IE8)\n\n```\n\n    if ( !Array.prototype.forEach ) {\n        Array.prototype.forEach = function forEach( callback, thisArg ) {\n            var T, k;\n            if ( this == null ) {\n                throw new TypeError( \"this is null or not defined\" );\n            }\n            var O = Object(this);\n            var len = O.length >>> 0;\n            if ( typeof callback !== \"function\" ) {\n                throw new TypeError( callback + \" is not a function\" );\n            }\n            if ( arguments.length > 1 ) {\n                T = thisArg;\n            }\n            k = 0;\n            while( k < len ) {\n    \n                var kValue;\n                if ( k in O ) {\n                    kValue = O[ k ];\n                    callback.call( T, kValue, k, O );\n                }\n                k++;\n            }\n        };\n    }\n\n```\n","slug":"forEach兼容写法","published":1,"updated":"2019-10-21T06:40:59.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckctvtzjc000c1wekqeb8rq6n","content":"<p>最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。</p>\n<p>最后在网上找到这段(兼容IE8)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if ( !Array.prototype.forEach ) &#123;</span><br><span class=\"line\">    Array.prototype.forEach = function forEach( callback, thisArg ) &#123;</span><br><span class=\"line\">        var T, k;</span><br><span class=\"line\">        if ( this == null ) &#123;</span><br><span class=\"line\">            throw new TypeError( &quot;this is null or not defined&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var O = Object(this);</span><br><span class=\"line\">        var len = O.length &gt;&gt;&gt; 0;</span><br><span class=\"line\">        if ( typeof callback !== &quot;function&quot; ) &#123;</span><br><span class=\"line\">            throw new TypeError( callback + &quot; is not a function&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if ( arguments.length &gt; 1 ) &#123;</span><br><span class=\"line\">            T = thisArg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k = 0;</span><br><span class=\"line\">        while( k &lt; len ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            var kValue;</span><br><span class=\"line\">            if ( k in O ) &#123;</span><br><span class=\"line\">                kValue = O[ k ];</span><br><span class=\"line\">                callback.call( T, kValue, k, O );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>最近写代码写到循环的时候没有多想就直接用了forEach，最后测试在IE的环境下测出了不兼容，为了不改动代码就打算定义一个 Array.prototype.forEach。</p>\n<p>最后在网上找到这段(兼容IE8)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if ( !Array.prototype.forEach ) &#123;</span><br><span class=\"line\">    Array.prototype.forEach = function forEach( callback, thisArg ) &#123;</span><br><span class=\"line\">        var T, k;</span><br><span class=\"line\">        if ( this == null ) &#123;</span><br><span class=\"line\">            throw new TypeError( &quot;this is null or not defined&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var O = Object(this);</span><br><span class=\"line\">        var len = O.length &gt;&gt;&gt; 0;</span><br><span class=\"line\">        if ( typeof callback !== &quot;function&quot; ) &#123;</span><br><span class=\"line\">            throw new TypeError( callback + &quot; is not a function&quot; );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if ( arguments.length &gt; 1 ) &#123;</span><br><span class=\"line\">            T = thisArg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        k = 0;</span><br><span class=\"line\">        while( k &lt; len ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            var kValue;</span><br><span class=\"line\">            if ( k in O ) &#123;</span><br><span class=\"line\">                kValue = O[ k ];</span><br><span class=\"line\">                callback.call( T, kValue, k, O );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckctvtzj500071wek0tyq6vov","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzje000d1wekykf2dk3e"},{"post_id":"ckctvtzig00001wekstb5te7h","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzji000g1wekui4m90t1"},{"post_id":"ckctvtzj900081wek5nzhm0ja","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzji000h1wekkxw16h2t"},{"post_id":"ckctvtzjc000c1wekqeb8rq6n","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzjk000j1wekp72ev8wt"},{"post_id":"ckctvtzip00021wekqviyz8gt","category_id":"ckctvtzja00091weks4qeceql","_id":"ckctvtzjl000l1weka7ugd6k4"},{"post_id":"ckctvtzix00061wekghpraedi","category_id":"ckctvtziv00041wek7qorz1br","_id":"ckctvtzjm000o1wekjbokwphf"}],"PostTag":[{"post_id":"ckctvtzig00001wekstb5te7h","tag_id":"ckctvtziw00051wekusqz81mk","_id":"ckctvtzjc000b1weka61s6hiw"},{"post_id":"ckctvtzip00021wekqviyz8gt","tag_id":"ckctvtzjb000a1wek7rg8kmal","_id":"ckctvtzjk000k1wekhi1zlcv0"},{"post_id":"ckctvtzip00021wekqviyz8gt","tag_id":"ckctvtzjg000f1wekutqrxhf8","_id":"ckctvtzjl000m1wekg0v5oujq"},{"post_id":"ckctvtzix00061wekghpraedi","tag_id":"ckctvtzjg000f1wekutqrxhf8","_id":"ckctvtzjn000p1wekpuzhthfg"},{"post_id":"ckctvtzj500071wek0tyq6vov","tag_id":"ckctvtzjl000n1wek7pw7zbt4","_id":"ckctvtzjp000s1wekaic7iyya"},{"post_id":"ckctvtzj500071wek0tyq6vov","tag_id":"ckctvtzjo000q1wekgg7kl9k4","_id":"ckctvtzjp000t1wek0veqdd9w"},{"post_id":"ckctvtzj900081wek5nzhm0ja","tag_id":"ckctvtzjo000r1wekaf5u99ej","_id":"ckctvtzjq000v1wek9zt4cest"},{"post_id":"ckctvtzjc000c1wekqeb8rq6n","tag_id":"ckctvtzjl000n1wek7pw7zbt4","_id":"ckctvtzjq000w1wekibtkdhov"}],"Tag":[{"name":"HTML","_id":"ckctvtziw00051wekusqz81mk"},{"name":"心得","_id":"ckctvtzjb000a1wek7rg8kmal"},{"name":"文章","_id":"ckctvtzjg000f1wekutqrxhf8"},{"name":"javaScript","_id":"ckctvtzjl000n1wek7pw7zbt4"},{"name":"技巧","_id":"ckctvtzjo000q1wekgg7kl9k4"},{"name":"react","_id":"ckctvtzjo000r1wekaf5u99ej"}]}}